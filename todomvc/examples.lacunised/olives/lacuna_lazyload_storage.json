{
    "node_modules/todomvc-common/base.js[197:548]": "\n\t\t\tif (!object) {\n\t\t\t\treturn object;\n\t\t\t}\n\t\t\tfor (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {\n\t\t\t\tvar iterable = arguments[argsIndex];\n\t\t\t\tif (iterable) {\n\t\t\t\t\tfor (var key in iterable) {\n\t\t\t\t\t\tif (object[key] == null) {\n\t\t\t\t\t\t\tobject[key] = iterable[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t",
    "node_modules/todomvc-common/base.js[1588:3332]": "\n\t\t\tvar render;\n\t\t\tsettings = _.defaults({}, settings, _.templateSettings);\n\n\t\t\t// Combine delimiters into one regular expression via alternation.\n\t\t\tvar matcher = new RegExp([\n\t\t\t\t(settings.escape || noMatch).source,\n\t\t\t\t(settings.interpolate || noMatch).source,\n\t\t\t\t(settings.evaluate || noMatch).source\n\t\t\t].join('|') + '|$', 'g');\n\n\t\t\t// Compile the template source, escaping string literals appropriately.\n\t\t\tvar index = 0;\n\t\t\tvar source = \"__p+='\";\n\t\t\ttext.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n\t\t\t\tsource += text.slice(index, offset)\n\t\t\t\t\t.replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n\t\t\t\tif (escape) {\n\t\t\t\t\tsource += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n\t\t\t\t}\n\t\t\t\tif (interpolate) {\n\t\t\t\t\tsource += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n\t\t\t\t}\n\t\t\t\tif (evaluate) {\n\t\t\t\t\tsource += \"';\\n\" + evaluate + \"\\n__p+='\";\n\t\t\t\t}\n\t\t\t\tindex = offset + match.length;\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tsource += \"';\\n\";\n\n\t\t\t// If a variable is not specified, place data values in local scope.\n\t\t\tif (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n\t\t\tsource = \"var __t,__p='',__j=Array.prototype.join,\" +\n\t\t\t\t\"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n\t\t\t\tsource + \"return __p;\\n\";\n\n\t\t\ttry {\n\t\t\t\trender = new Function(settings.variable || 'obj', '_', source);\n\t\t\t} catch (e) {\n\t\t\t\te.source = source;\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tif (data) return render(data, _);\n\t\t\tvar template = function(data) {\n\t\t\t\treturn render.call(this, data, _);\n\t\t\t};\n\n\t\t\t// Provide the compiled function source as a convenience for precompilation.\n\t\t\ttemplate.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n\t\t\treturn template;\n\t\t",
    "node_modules/todomvc-common/base.js[3427:3646]": "i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n\t\t(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n\t\tm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n\t\t",
    "node_modules/todomvc-common/base.js[4521:5446]": "\n\t\tif (!(this instanceof Learn)) {\n\t\t\treturn new Learn(learnJSON, config);\n\t\t}\n\n\t\tvar template, framework;\n\n\t\tif (typeof learnJSON !== 'object') {\n\t\t\ttry {\n\t\t\t\tlearnJSON = JSON.parse(learnJSON);\n\t\t\t} catch (e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (config) {\n\t\t\ttemplate = config.template;\n\t\t\tframework = config.framework;\n\t\t}\n\n\t\tif (!template && learnJSON.templates) {\n\t\t\ttemplate = learnJSON.templates.todomvc;\n\t\t}\n\n\t\tif (!framework && document.querySelector('[data-framework]')) {\n\t\t\tframework = document.querySelector('[data-framework]').dataset.framework;\n\t\t}\n\n\t\tthis.template = template;\n\n\t\tif (learnJSON.backend) {\n\t\t\tthis.frameworkJSON = learnJSON.backend;\n\t\t\tthis.frameworkJSON.issueLabel = framework;\n\t\t\tthis.append({\n\t\t\t\tbackend: true\n\t\t\t});\n\t\t} else if (learnJSON[framework]) {\n\t\t\tthis.frameworkJSON = learnJSON[framework];\n\t\t\tthis.frameworkJSON.issueLabel = framework;\n\t\t\tthis.append();\n\t\t}\n\n\t\tthis.fetchIssueCount();\n\t",
    "node_modules/todomvc-common/base.js[5490:6529]": "\n\t\tvar aside = document.createElement('aside');\n\t\taside.innerHTML = _.template(this.template, this.frameworkJSON);\n\t\taside.className = 'learn';\n\n\t\tif (opts && opts.backend) {\n\t\t\t// Remove demo link\n\t\t\tvar sourceLinks = aside.querySelector('.source-links');\n\t\t\tvar heading = sourceLinks.firstElementChild;\n\t\t\tvar sourceLink = sourceLinks.lastElementChild;\n\t\t\t// Correct link path\n\t\t\tvar href = sourceLink.getAttribute('href');\n\t\t\tsourceLink.setAttribute('href', href.substr(href.lastIndexOf('http')));\n\t\t\tsourceLinks.innerHTML = heading.outerHTML + sourceLink.outerHTML;\n\t\t} else {\n\t\t\t// Localize demo links\n\t\t\tvar demoLinks = aside.querySelectorAll('.demo-link');\n\t\t\tArray.prototype.forEach.call(demoLinks, function (demoLink) {\n\t\t\t\tif (demoLink.getAttribute('href').substr(0, 4) !== 'http') {\n\t\t\t\t\tdemoLink.setAttribute('href', findRoot() + demoLink.getAttribute('href'));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tdocument.body.className = (document.body.className + ' learn-bar').trim();\n\t\tdocument.body.insertAdjacentHTML('afterBegin', aside.outerHTML);\n\t",
    "node_modules/todomvc-common/base.js[6579:7199]": "\n\t\tvar issueLink = document.getElementById('issue-count-link');\n\t\tif (issueLink) {\n\t\t\tvar url = issueLink.href.replace('https://github.com', 'https://api.github.com/repos');\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\txhr.open('GET', url, true);\n\t\t\txhr.onload = function (e) {\n\t\t\t\tvar parsedResponse = JSON.parse(e.target.responseText);\n\t\t\t\tif (parsedResponse instanceof Array) {\n\t\t\t\t\tvar count = parsedResponse.length;\n\t\t\t\t\tif (count !== 0) {\n\t\t\t\t\t\tissueLink.innerHTML = 'This app has ' + count + ' open issues';\n\t\t\t\t\t\tdocument.getElementById('issue-count').style.display = 'inline';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\txhr.send();\n\t\t}\n\t",
    "olives-todo.js[2279:2364]": "\n            tools.toggleClass.call(link, link.hash === route, className);\n        ",
    "olives-todo.js[2861:2885]": "\n    return [ hash ];\n",
    "olives-todo.js[4191:4251]": "\n\t\t\tif (value.completed) {\n\t\t\t\tcompleted.push(id);\n\t\t\t}\n\t\t",
    "olives-todo.js[4911:4947]": "\n\t\tmodel.delAll(getCompleted());\n\t",
    "olives-todo.js[5942:6111]": "\n\t\tif (event.keyCode === ENTER_KEY && node.value.trim()) {\n\t\t\tmodel.alter('push', {\n\t\t\t\ttitle: node.value.trim(),\n\t\t\t\tcompleted: false\n\t\t\t});\n\t\t\tnode.value = '';\n\t\t}\n\t",
    "olives-todo.js[7274:7327]": "\n\t\tmodel.del(node.getAttribute('data-model_id'));\n\t",
    "olives-todo.js[7403:7533]": "\n\t\tvar checked = !!node.checked;\n\n\t\tmodel.loop(function (value, idx) {\n\t\t\tthis.update(idx, 'completed', checked);\n\t\t}, model);\n\t",
    "olives-todo.js[7606:7742]": "\n\t\tvar taskId = modelPlugin.getItemIndex(node);\n\n\t\ttoggleEditing(taskId, true);\n\t\tgetElementByModelId('input.edit', taskId).focus();\n\t",
    "olives-todo.js[7813:8494]": "\n\t\tvar taskId = modelPlugin.getItemIndex(node);\n\t\tvar value;\n\n\t\tif (event.keyCode === ENTER_KEY || event.type === 'blur') {\n\t\t\tvalue = node.value.trim();\n\n\t\t\tif (value) {\n\t\t\t\tmodel.update(taskId, 'title', value);\n\t\t\t} else {\n\t\t\t\tmodel.del(taskId);\n\t\t\t}\n\n\t\t\t// When task #n is removed, #n+1 becomes #n, the dom node is updated to the new value, so editing mode should exit anyway\n\t\t\tif (model.has(taskId)) {\n\t\t\t\ttoggleEditing(taskId, false);\n\t\t\t}\n\t\t} else if (event.keyCode === ESC_KEY) {\n\t\t\ttoggleEditing(taskId, false);\n\t\t\t// Also reset the input field to the previous value so that the blur event doesn't pick up the discarded one\n\t\t\tnode.value = model.get(taskId).title;\n\t\t}\n\t",
    "olives-todo.js[8602:8699]": "\n\t\tvar li = getElementByModelId('li', taskId);\n\t\ttools.toggleClass.call(li, bool, 'editing');\n\t",
    "olives-todo.js[8749:8829]": "\n\t\treturn view.querySelector(selector + '[data-model_id=\"' + taskId + '\"]');\n\t",
    "olives-todo.js[10996:12016]": "\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n  else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = stackStartFunction.name;\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n",
    "olives-todo.js[12137:12388]": "\n  if (util.isUndefined(value)) {\n    return '' + value;\n  }\n  if (util.isNumber(value) && !isFinite(value)) {\n    return value.toString();\n  }\n  if (util.isFunction(value) || util.isRegExp(value)) {\n    return value.toString();\n  }\n  return value;\n",
    "olives-todo.js[12414:12517]": "\n  if (util.isString(s)) {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n",
    "olives-todo.js[12545:12714]": "\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(JSON.stringify(self.expected, replacer), 128);\n",
    "olives-todo.js[13283:13461]": "\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n",
    "olives-todo.js[14126:14208]": "\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n",
    "olives-todo.js[14411:14506]": "\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n",
    "olives-todo.js[14691:14805]": "\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n",
    "olives-todo.js[14846:16697]": "\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\n    return actual == expected;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n",
    "olives-todo.js[16728:16804]": "\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n",
    "olives-todo.js[16830:17989]": "\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b)) {\n    return a === b;\n  }\n  var aIsArgs = isArguments(a),\n      bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  var ka = objectKeys(a),\n      kb = objectKeys(b),\n      key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n",
    "olives-todo.js[18185:18304]": "\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n",
    "olives-todo.js[18512:18612]": "\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n",
    "olives-todo.js[18841:18944]": "\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n",
    "olives-todo.js[18992:19302]": "\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n",
    "olives-todo.js[19360:20019]": "\n  var actual;\n\n  if (util.isString(expected)) {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n",
    "olives-todo.js[20178:20243]": "\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n",
    "olives-todo.js[20366:20432]": "\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n",
    "olives-todo.js[20466:20490]": " if (err) {throw err;}",
    "olives-todo.js[20540:20651]": "\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n",
    "olives-todo.js[21191:21342]": "\n      if (number1 > number2) {\n        return 1;\n      } else if (number1 < number2) {\n        return -1;\n      } else {\n         return 0;\n      }\n",
    "olives-todo.js[21994:22048]": "\n      return compareNumbers(number2, number1);\n    ",
    "olives-todo.js[23596:23796]": "\n        if (_observers[id]) {\n            _observers[id].forEach(function (handler) {\n                _model.unwatchValue(handler);\n            });\n            delete _observers[id];\n        }\n    ",
    "olives-todo.js[24206:24236]": "\n        return _model;\n    ",
    "olives-todo.js[25461:25498]": "\n            return _node;\n        ",
    "olives-todo.js[26141:26182]": "\n            return _rootNode;\n        ",
    "olives-todo.js[26650:26690]": "\n            return _plugins;\n        ",
    "olives-todo.js[27292:27330]": "\n            return _start;\n        ",
    "olives-todo.js[27822:27857]": "\n            return _nb;\n        ",
    "olives-todo.js[28074:28799]": "\n            var node,\n                next;\n\n            if (typeof id == \"number\" && !this.items[id]) {\n                next = this.getNextItem(id);\n                node = this.create(id);\n                if (node) {\n                    // IE (until 9) apparently fails to appendChild when insertBefore's second argument is null, hence this.\n                    if (next) {\n                        _rootNode.insertBefore(node, next);\n                    } else {\n                        _rootNode.appendChild(node);\n                    }\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        ",
    "olives-todo.js[29029:29460]": "\n            var keys = Object.keys(this.items).map(function (string) {\n                    return Number(string);\n                }),\n                closest = getClosest.greaterNumber(id, keys),\n                closestId = keys[closest];\n\n            // Only return if different\n            if (closestId != id) {\n                return this.items[closestId];\n            } else {\n                return;\n            }\n        ",
    "olives-todo.js[29694:29989]": "\n            var item = this.items[id];\n            if (item) {\n                _rootNode.removeChild(item);\n                delete this.items[id];\n                _removeObserversForId(id);\n                return true;\n            } else {\n                return false;\n            }\n        ",
    "olives-todo.js[30334:30759]": "\n            if (_model.has(id)) {\n                var newNode = _node.cloneNode(true),\n                nodes = getNodes(newNode);\n\n                toArray(nodes).forEach(function (child) {\n                    child.setAttribute(\"data-\" + _plugins.name+\"_id\", id);\n                });\n\n                this.items[id] = newNode;\n                _plugins.apply(newNode);\n                return newNode;\n            }\n        ",
    "olives-todo.js[31461:31764]": "\n                    // If an item is out of the boundary\n                    idx = Number(idx);\n\n                    if (idx < _start || idx >= (_start + _tmpNb) || !_model.has(idx)) {\n                        // Mark it\n                        marked.push(idx);\n                    }\n                ",
    "olives-todo.js[33096:33138]": "\n        return _itemRenderers[id];\n    ",
    "olives-todo.js[33763:33890]": "\n            itemRenderer.render();\n            // Also remove all observers\n            _removeObserversForId(idx);\n        ",
    "olives-todo.js[34236:34452]": "\n         var itemRenderer = this.getItemRenderer(id);\n         if (itemRenderer) {\n             itemRenderer.setStart(start);\n             return true;\n         } else {\n             return false;\n         }\n     ",
    "olives-todo.js[34739:34949]": "\n         var itemRenderer = this.getItemRenderer(id);\n         if (itemRenderer) {\n             itemRenderer.setNb(nb);\n             return true;\n         } else {\n             return false;\n         }\n     ",
    "olives-todo.js[35174:35376]": "\n        var itemRenderer = this.getItemRenderer(id);\n        if (itemRenderer) {\n            itemRenderer.render();\n            return true;\n        } else {\n            return false;\n        }\n     ",
    "olives-todo.js[37325:37618]": "\n                if (_model.has(modelIdx)) {\n                    if (prop) {\n                        _model.update(modelIdx, name, node[property]);\n                    } else {\n                        _model.set(modelIdx, node[property]);\n                    }\n                }\n            ",
    "olives-todo.js[38383:38540]": "\n        if (node.name) {\n            _model.set(node.name, node.value);\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[38594:38833]": "\n        var dataset = getDataset(dom);\n\n        if (dataset && typeof dataset[this.plugins.name + \"_id\"] != \"undefined\") {\n            return +dataset[this.plugins.name + \"_id\"];\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[39034:39414]": "\n        if (DOMform && DOMform.nodeName == \"FORM\") {\n            var that = this;\n            DOMform.addEventListener(\"submit\", function (event) {\n                toArray(DOMform.querySelectorAll(\"[name]\")).forEach(that.set, that);\n                event.preventDefault();\n            }, true);\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[40862:40901]": "\n        return _bindings[name];\n    ",
    "olives-todo.js[42107:48825]": "\n\n\t/**\n\t * The parent DOM element is a documentFragment by default\n\t * @private\n\t */\n\tvar _parent = document.createDocumentFragment(),\n\n\t/**\n\t * The place where the dom elements hide\n\t * @private\n\t */\n\t_hidePlace = document.createElement(\"div\"),\n\n\t/**\n\t * The list of dom elements that are part of the stack\n\t * Helps for excluding elements that are not part of it\n\t * @private\n\t */\n\t_childNodes = [],\n\n\t_lastTransit = null;\n\n\t/**\n\t * Add a DOM element to the stack. It will be appended.\n\t * @param {HTMLElement} dom the DOM element to add\n\t * @returns {HTMLElement} dom\n\t */\n\tthis.add = function add(dom) {\n\t\tif (!this.has(dom)) {\n\t\t\t_parent.appendChild(dom);\n\t\t\t_childNodes.push(dom);\n\t\t\treturn dom;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Remove a DOM element from the stack.\n\t * @param {HTMLElement} dom the DOM element to remove\n\t * @returns {HTMLElement} dom\n\t */\n\tthis.remove = function remove(dom) {\n\t\tvar index;\n\t\tif (this.has(dom)) {\n\t\t\tindex = _childNodes.indexOf(dom);\n\t\t\t_parent.removeChild(dom);\n\t\t\t_childNodes.splice(index, 1);\n\t\t\treturn dom;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Place a stack by appending its DOM elements to a new parent\n\t * @param {HTMLElement} newParentDom the new DOM element to append the stack to\n\t * @returns {HTMLElement} newParentDom\n\t */\n\tthis.place = function place(newParentDom) {\n\t\t[].slice.call(_parent.childNodes).forEach(function (childDom) {\n\t\t\tif (this.has(childDom)) {\n\t\t\t\tnewParentDom.appendChild(childDom);\n\t\t\t}\n\t\t}, this);\n\t\treturn this._setParent(newParentDom);\n\t};\n\n\t/**\n\t * Move an element up in the stack\n\t * @param {HTMLElement} dom the dom element to move up\n\t * @returns {HTMLElement} dom\n\t */\n\tthis.up = function up(dom) {\n\t\tif (this.has(dom)) {\n\t\t\tvar domPosition = this.getPosition(dom);\n\t\t\tthis.move(dom, domPosition + 1);\n\t\t\treturn dom;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Move an element down in the stack\n\t * @param {HTMLElement} dom the dom element to move down\n\t * @returns {HTMLElement} dom\n\t */\n\tthis.down = function down(dom) {\n\t\tif (this.has(dom)) {\n\t\t\tvar domPosition = this.getPosition(dom);\n\t\t\tthis.move(dom, domPosition - 1);\n\t\t\treturn dom;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Move an element that is already in the stack to a new position\n\t * @param {HTMLElement} dom the dom element to move\n\t * @param {Number} position the position to which to move the DOM element\n\t * @returns {HTMLElement} dom\n\t */\n\tthis.move = function move(dom, position) {\n\t\tif (this.has(dom)) {\n\t\t\tvar domIndex = _childNodes.indexOf(dom);\n\t\t\t_childNodes.splice(domIndex, 1);\n\t\t\t// Preventing a bug in IE when insertBefore is not given a valid\n\t\t\t// second argument\n\t\t\tvar nextElement = getNextElementInDom(position);\n\t\t\tif (nextElement) {\n\t\t\t\t_parent.insertBefore(dom, nextElement);\n\t\t\t} else {\n\t\t\t\t_parent.appendChild(dom);\n\t\t\t}\n\t\t\t_childNodes.splice(position, 0, dom);\n\t\t\treturn dom;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tfunction getNextElementInDom(position) {\n\t\tif (position >= _childNodes.length) {\n\t\t\treturn;\n\t\t}\n\t\tvar nextElement = _childNodes[position];\n\t\tif (toArray(_parent.childNodes).indexOf(nextElement) == -1) {\n\t\t\treturn getNextElementInDom(position +1);\n\t\t} else {\n\t\t\treturn nextElement;\n\t\t}\n\t}\n\n\t/**\n\t * Insert a new element at a specific position in the stack\n\t * @param {HTMLElement} dom the dom element to insert\n\t * @param {Number} position the position to which to insert the DOM element\n\t * @returns {HTMLElement} dom\n\t */\n\tthis.insert = function insert(dom, position) {\n\t\tif (!this.has(dom)) {\n\t\t\t_childNodes.splice(position, 0, dom);\n\t\t\t_parent.insertBefore(dom, _parent.childNodes[position]);\n\t\t\treturn dom;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Get the position of an element in the stack\n\t * @param {HTMLElement} dom the dom to get the position from\n\t * @returns {HTMLElement} dom\n\t */\n\tthis.getPosition = function getPosition(dom) {\n\t\treturn _childNodes.indexOf(dom);\n\t};\n\n\t/**\n\t * Count the number of elements in a stack\n\t * @returns {Number} the number of items\n\t */\n\tthis.count = function count() {\n\t\treturn _parent.childNodes.length;\n\t};\n\n\t/**\n\t * Tells if a DOM element is in the stack\n\t * @param {HTMLElement} dom the dom to tell if its in the stack\n\t * @returns {HTMLElement} dom\n\t */\n\tthis.has = function has(childDom) {\n\t\treturn this.getPosition(childDom) >= 0;\n\t};\n\n\t/**\n\t * Hide a dom element that was previously added to the stack\n\t * It will be taken out of the dom until displayed again\n\t * @param {HTMLElement} dom the dom to hide\n\t * @return {boolean} if dom element is in the stack\n\t */\n\tthis.hide = function hide(dom) {\n\t\tif (this.has(dom)) {\n\t\t\t_hidePlace.appendChild(dom);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Show a dom element that was previously hidden\n\t * It will be added back to the dom\n\t * @param {HTMLElement} dom the dom to show\n\t * @return {boolean} if dom element is current hidden\n\t */\n\tthis.show = function show(dom) {\n\t\tif (this.has(dom) && dom.parentNode === _hidePlace) {\n\t\t\tthis.move(dom, _childNodes.indexOf(dom));\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Helper function for hiding all the dom elements\n\t */\n\tthis.hideAll = function hideAll() {\n\t\t_childNodes.forEach(this.hide, this);\n\t};\n\n\t/**\n\t * Helper function for showing all the dom elements\n\t */\n\tthis.showAll = function showAll() {\n\t\t_childNodes.forEach(this.show, this);\n\t};\n\n\t/**\n\t * Get the parent node that a stack is currently attached to\n\t * @returns {HTMLElement} parent node\n\t */\n\tthis.getParent = function getParent() {\n\t\treturn _parent;\n\t};\n\n\t/**\n\t * Set the parent element (without appending the stacks dom elements to)\n\t * @private\n\t */\n\tthis._setParent = function _setParent(parent) {\n\t\t_parent = parent;\n\t\treturn _parent;\n    };\n\n\t/**\n\t * Get the place where the DOM elements are hidden\n\t * @private\n\t */\n\tthis.getHidePlace = function getHidePlace() {\n\t\treturn _hidePlace;\n\t};\n\n\t/**\n\t * Set the place where the DOM elements are hidden\n\t * @private\n\t */\n\tthis.setHidePlace = function setHidePlace(hidePlace) {\n\t\t_hidePlace = hidePlace;\n\t};\n\n\t/**\n\t * Get the last dom element that the stack transitted to\n\t * @returns {HTMLElement} the last dom element\n\t */\n\tthis.getLastTransit = function getLastTransit() {\n\t\treturn _lastTransit;\n\t};\n\n\t/**\n\t * Transit between views, will show the new one and hide the previous\n\t * element that the stack transitted to, if any.\n\t * @param {HTMLElement} dom the element to transit to\n\t * @returns {Boolean} false if the element can't be shown\n\t */\n\tthis.transit = function transit(dom) {\n\t\tif (_lastTransit) {\n\t\t\tthis.hide(_lastTransit);\n\t\t}\n\t\tif (this.show(dom)) {\n\t\t\t_lastTransit = dom;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n    if ($parent) {\n\t    this._setParent($parent);\n    }\n\n",
    "olives-todo.js[50655:57703]": "\n\n    /**\n     * The fulfilled value\n     * @private\n     */\n    var _value = null,\n\n    /**\n     * The rejection reason\n     * @private\n     */\n    _reason = null,\n\n    /**\n     * The funky observable\n     * @private\n     */\n    _observable = new Observable(),\n\n    /**\n     * The stateMachine\n     * @private\n     */\n    _stateMachine = new StateMachine(\"Pending\", {\n\n        // The promise is pending\n        \"Pending\": [\n\n            // It can only be fulfilled when pending\n            [\"fulfill\", function onFulfill(value) {\n                _value = value;\n                _observable.notify(\"fulfill\", value);\n            // Then it transits to the fulfilled state\n            }, \"Fulfilled\"],\n\n            // it can only be rejected when pending\n            [\"reject\", function onReject(reason) {\n                _reason = reason;\n                _observable.notify(\"reject\", reason);\n            // Then it transits to the rejected state\n            }, \"Rejected\"],\n\n            // When pending, add the resolver to an observable\n            [\"toFulfill\", function toFulfill(resolver) {\n                _observable.watch(\"fulfill\", resolver);\n            }],\n\n            // When pending, add the resolver to an observable\n            [\"toReject\", function toReject(resolver) {\n                _observable.watch(\"reject\", resolver);\n            }]],\n\n        // When fulfilled,\n        \"Fulfilled\": [\n            // We directly call the resolver with the value\n            [\"toFulfill\", function toFulfill(resolver) {\n                   resolver(_value);\n            }]],\n\n        // When rejected\n        \"Rejected\": [\n            // We directly call the resolver with the reason\n            [\"toReject\", function toReject(resolver) {\n                   resolver(_reason);\n            }]]\n    });\n\n    /**\n     * Fulfilled the promise.\n     * A promise can be fulfilld only once.\n     * @param the fulfillment value\n     * @returns the promise\n     */\n    this.fulfill = function fulfill(value) {\n        setTimeout(function () {\n            _stateMachine.event(\"fulfill\", value);\n        }, 0);\n        return this;\n\n    };\n\n    /**\n     * Reject the promise.\n     * A promise can be rejected only once.\n     * @param the rejection value\n     * @returns true if the rejection function was called\n     */\n    this.reject = function reject(reason) {\n        setTimeout(function () {\n            _stateMachine.event(\"reject\", reason);\n        }, 0);\n        return this;\n    };\n\n    /**\n     * The callbacks to call after fulfillment or rejection\n     * @param {Function} fulfillmentCallback the first parameter is a success function, it can be followed by a scope\n     * @param {Function} the second, or third parameter is the rejection callback, it can also be followed by a scope\n     * @examples:\n     *\n     * then(fulfillment)\n     * then(fulfillment, scope, rejection, scope)\n     * then(fulfillment, rejection)\n     * then(fulfillment, rejection, scope)\n     * then(null, rejection, scope)\n     * @returns {Promise} the new promise\n     */\n    this.then = function then() {\n        var promise = new PromiseConstructor();\n\n        // If a fulfillment callback is given\n        if (arguments[0] instanceof Function) {\n            // If the second argument is also a function, then no scope is given\n            if (arguments[1] instanceof Function) {\n                _stateMachine.event(\"toFulfill\", this.makeResolver(promise, arguments[0]));\n            } else {\n                // If the second argument is not a function, it's the scope\n                _stateMachine.event(\"toFulfill\", this.makeResolver(promise, arguments[0], arguments[1]));\n            }\n        } else {\n            // If no fulfillment callback given, give a default one\n            _stateMachine.event(\"toFulfill\", this.makeResolver(promise, function () {\n                promise.fulfill(_value);\n            }));\n        }\n\n        // if the second arguments is a callback, it's the rejection one, and the next argument is the scope\n        if (arguments[1] instanceof Function) {\n            _stateMachine.event(\"toReject\", this.makeResolver(promise, arguments[1], arguments[2]));\n        }\n\n        // if the third arguments is a callback, it's the rejection one, and the next arguments is the sopce\n        if (arguments[2] instanceof Function) {\n            _stateMachine.event(\"toReject\", this.makeResolver(promise, arguments[2], arguments[3]));\n        }\n\n        // If no rejection callback is given, give a default one\n        if (!(arguments[1] instanceof Function) &&\n            !(arguments[2] instanceof Function)) {\n            _stateMachine.event(\"toReject\", this.makeResolver(promise, function () {\n                promise.reject(_reason);\n            }));\n        }\n\n        return promise;\n    };\n\n    /**\n     * Cast a thenable into an Emily promise\n     * @returns {Boolean} false if the given promise is not a thenable\n     */\n    this.cast = function cast(thenable) {\n        if (thenable instanceof PromiseConstructor ||\n            typeof thenable == \"object\" ||\n            typeof thenable == \"function\") {\n\n            thenable.then(this.fulfill.bind(this),\n                    this.reject.bind(this));\n\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Make a resolver\n     * for debugging only\n     * @private\n     * @returns {Function} a closure\n     */\n    this.makeResolver = function makeResolver(promise, func, scope) {\n        return function resolver(value) {\n            var returnedPromise;\n\n            try {\n                returnedPromise = func.call(scope, value);\n                if (returnedPromise === promise) {\n                    throw new TypeError(\"Promise A+ 2.3.1: If `promise` and `x` refer to the same object, reject `promise` with a `TypeError' as the reason.\");\n                }\n                if (!promise.cast(returnedPromise)) {\n                    promise.fulfill(returnedPromise);\n                }\n            } catch (err) {\n                promise.reject(err);\n            }\n\n        };\n    };\n\n    /**\n     * Returns the reason\n     * for debugging only\n     * @private\n     */\n    this.getReason = function getReason() {\n        return _reason;\n    };\n\n    /**\n     * Returns the reason\n     * for debugging only\n     * @private\n     */\n    this.getValue = function getValue() {\n        return _value;\n    };\n\n    /**\n     * Get the promise's observable\n     * for debugging only\n     * @private\n     * @returns {Observable}\n     */\n    this.getObservable = function getObservable() {\n        return _observable;\n    };\n\n    /**\n     * Get the promise's stateMachine\n     * for debugging only\n     * @private\n     * @returns {StateMachine}\n     */\n    this.getStateMachine = function getStateMachine() {\n        return _stateMachine;\n    };\n\n    /**\n     * Get the statesMachine's states\n     * for debugging only\n     * @private\n     * @returns {Object}\n     */\n    this.getStates = function getStates() {\n        return _states;\n    };\n",
    "olives-todo.js[59576:59641]": "\n            _parent[listener].call(_parent, e, node);\n        ",
    "olives-todo.js[60077:60304]": "\n        this.addEventListener(node, name, function(event){\n            if (matchesSelector(event.target, selector)) {\n                _parent[listener].call(_parent, event, node);\n            }\n        }, !!useCapture);\n    ",
    "olives-todo.js[60437:60468]": "\n        return _parent;\n    ",
    "olives-todo.js[61282:61457]": "\n        if (typeof name == \"string\" &&\n            typeof value == \"string\") {\n            _map[name] = value;\n            return true;\n        }\n        return false;\n    ",
    "olives-todo.js[62144:62570]": "\n    var closest,\n        diff;\n\n    assert(Array.isArray(array), \"Get closest expects an array as second argument\");\n\n    array.forEach(function (comparedItem, comparedItemIndex) {\n        var thisDiff = getDiff(comparedItem, item);\n\n        if (thisDiff >= 0 && (typeof diff == \"undefined\" || thisDiff < diff)) {\n            diff = thisDiff;\n            closest = comparedItemIndex;\n        }\n    });\n\n    return closest;\n",
    "olives-todo.js[62963:63096]": "\n      return _getClosest(item, array, function (comparedItem, item) {\n          return Math.abs(comparedItem - item);\n      });\n  ",
    "olives-todo.js[63500:63623]": "\n      return _getClosest(item, array, function (comparedItem, item) {\n          return comparedItem - item;\n      });\n  ",
    "olives-todo.js[64019:64136]": "\n    return _getClosest(item, array, function (comparedItem, item) {\n        return item - comparedItem;\n    });\n  ",
    "olives-todo.js[64812:64866]": "\n    return _getClosest(item, array, comparator);\n  ",
    "olives-todo.js[66337:66378]": "\n    return Function('return this')();\n",
    "olives-todo.js[67275:72785]": "\n\n    /**\n     * The routes observable (the applications use it)\n     * @private\n     */\n    var _routes = new Observable(),\n\n    /**\n     * The events observable (used by Routing)\n     * @private\n     */\n    _events = new Observable(),\n\n    /**\n     * The routing history\n     * @private\n     */\n    _history = [],\n\n    /**\n     * For navigating through the history, remembers the current position\n     * @private\n     */\n    _currentPos = -1,\n\n    /**\n     * The depth of the history\n     * @private\n     */\n    _maxHistory = 10;\n\n    /**\n     * Only for debugging\n     * @private\n     */\n    this.getRoutesObservable = function getRoutesObservable() {\n        return _routes;\n    };\n\n    /**\n     * Only for debugging\n     * @private\n     */\n    this.getEventsObservable = function getEventsObservable() {\n        return _events;\n    };\n\n    /**\n     * Set the maximum length of history\n     * As the user navigates through the application, the\n     * routeur keeps track of the history. Set the depth of the history\n     * depending on your need and the amount of memory that you can allocate it\n     * @param {Number} maxHistory the depth of history\n     * @returns {Boolean} true if maxHistory is equal or greater than 0\n     */\n    this.setMaxHistory = function setMaxHistory(maxHistory) {\n        if (maxHistory >= 0) {\n            _maxHistory = maxHistory;\n            return true;\n        } else {\n            return false;\n        }\n\n    };\n\n    /**\n     * Get the current max history setting\n     * @returns {Number} the depth of history\n     */\n    this.getMaxHistory = function getMaxHistory() {\n        return _maxHistory;\n    };\n\n    /**\n     * Set a new route\n     * @param {String} route the name of the route\n     * @param {Function} func the function to be execute when navigating to the route\n     * @param {Object} scope the scope in which to execute the function\n     * @returns a handle to remove the route\n     */\n    this.set = function set() {\n        return _routes.watch.apply(_routes, arguments);\n    };\n\n    /**\n     * Remove a route\n     * @param {Object} handle the handle provided by the set method\n     * @returns true if successfully removed\n     */\n    this.unset = function unset(handle) {\n        return _routes.unwatch(handle);\n    };\n\n    /**\n     * Navigate to a route\n     * @param {String} route the route to navigate to\n     * @param {*} *params\n     * @returns\n     */\n    this.navigate = function get(route) {\n        if (this.load.apply(this, arguments)) {\n            // Before adding a new route to the history, we must clear the forward history\n            _history.splice(_currentPos +1, _history.length);\n            _history.push(toArray(arguments));\n            this.ensureMaxHistory(_history);\n            _currentPos = _history.length -1;\n            return true;\n        } else {\n            return false;\n        }\n\n    };\n\n    /**\n     * Ensure that history doesn't grow bigger than the max history setting\n     * @param {Store} history the history store\n     * @private\n     */\n    this.ensureMaxHistory = function ensureMaxHistory(history) {\n        var count = history.length,\n            max = this.getMaxHistory(),\n            excess = count - max;\n\n        if (excess > 0) {\n            history.splice(0, excess);\n        }\n    };\n\n    /**\n     * Actually loads the route\n     * @private\n     */\n    this.load = function load() {\n        var copy = toArray(arguments);\n\n        if (_routes.notify.apply(_routes, copy)) {\n            copy.unshift(\"route\");\n            _events.notify.apply(_events, copy);\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Watch for route changes\n     * @param {Function} func the func to execute when the route changes\n     * @param {Object} scope the scope in which to execute the function\n     * @returns {Object} the handle to unwatch for route changes\n     */\n    this.watch = function watch(func, scope) {\n        return _events.watch(\"route\", func, scope);\n    };\n\n    /**\n     * Unwatch routes changes\n     * @param {Object} handle the handle was returned by the watch function\n     * @returns true if unwatch\n     */\n    this.unwatch = function unwatch(handle) {\n        return _events.unwatch(handle);\n    };\n\n    /**\n     * Get the history store, for debugging only\n     * @private\n     */\n    this.getHistoryStore = function getHistoryStore() {\n        return _history;\n    };\n\n    /**\n     * Get the current length of history\n     * @returns {Number} the length of history\n     */\n    this.getHistoryCount = function getHistoryCount() {\n        return _history.length;\n    };\n\n    /**\n     * Flush the entire history\n     */\n    this.clearHistory = function clearHistory() {\n        _history.length = 0;\n    };\n\n    /**\n     * Go back and forth in the history\n     * @param {Number} nb the amount of history to rewind/forward\n     * @returns true if history exists\n     */\n    this.go = function go(nb) {\n        var history = _history[_currentPos + nb];\n        if (history) {\n            _currentPos += nb;\n            this.load.apply(this, history);\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Go back in the history, short for go(-1)\n     * @returns\n     */\n    this.back = function back() {\n        return this.go(-1);\n    };\n\n    /**\n     * Go forward in the history, short for go(1)\n     * @returns\n     */\n    this.forward = function forward() {\n        return this.go(1);\n    };\n\n",
    "olives-todo.js[73346:73532]": "\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  ",
    "olives-todo.js[74764:74964]": "\n        if (local$torage && typeof local$torage.setItem == \"function\") {\n            _localStorage = local$torage;\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[75118:75155]": "\n        return _localStorage;\n    ",
    "olives-todo.js[75568:75681]": "\n                if (!this.has(idx)) {\n                    this.set(idx, value);\n                }\n            ",
    "olives-todo.js[77823:78030]": "\n  if (vendor) return vendor.call(el, selector);\n  var nodes = el.parentNode.querySelectorAll(selector);\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] == el) return true;\n  }\n  return false;\n",
    "olives-todo.js[78436:78506]": "\n      return this.has(object, property, options || {own: true});\n  ",
    "olives-todo.js[79134:79190]": "\n                return obj && obj[prop];\n            ",
    "olives-todo.js[79949:80764]": "\n    options = options || {};\n\n    if (object && typeof object == \"object\") {\n        if (typeof property == \"string\" && property !== \"\") {\n            var split = property.split(\".\");\n            return split.reduce(function (obj, prop, idx, array) {\n                if (idx == array.length - 1) {\n                    if (options.own) {\n                        return !!(obj && obj.hasOwnProperty(prop));\n                    } else {\n                        return !!(obj !== null && typeof obj == \"object\" && prop in obj);\n                    }\n                }\n                return obj && obj[prop];\n            }, object);\n        } else if (typeof property == \"number\") {\n            return property in object;\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n",
    "olives-todo.js[81112:81759]": "\n    if (object && typeof object == \"object\") {\n        if (typeof property == \"string\" && property !== \"\") {\n            var split = property.split(\".\");\n            return split.reduce(function (obj, prop, idx) {\n                obj[prop] = obj[prop] || {};\n                if (split.length == (idx + 1)) {\n                    obj[prop] = value;\n                }\n                return obj[prop];\n            }, object);\n        } else if (typeof property == \"number\") {\n            object[property] = value;\n            return object[property];\n        } else {\n            return object;\n        }\n    } else {\n        return object;\n    }\n",
    "olives-todo.js[82325:83032]": "\n    options = options || {};\n\n    if (object && typeof object == \"object\") {\n        if (typeof property == \"string\" && property !== \"\") {\n            var split = property.split(\".\"),\n                isIn = false,\n                pathExists;\n\n            pathExists = !!split.reduce(function (obj, prop) {\n                isIn = isIn || obj === objectInPath || (!!obj && obj[prop] === objectInPath);\n                return obj && obj[prop];\n            }, object);\n\n            if (options.validPath) {\n                return isIn && pathExists;\n            } else {\n                return isIn;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n",
    "olives-todo.js[85211:85648]": "\n        var diffs = diff(previousData, _data);\n        [\"updated\",\n         \"deleted\",\n         \"added\"].forEach(function (value) {\n             diffs[value].forEach(function (dataIndex) {\n                    _storeObservable.notify(value, dataIndex, _data[dataIndex], previousData[dataIndex]);\n                    _valueObservable.notify(dataIndex, _data[dataIndex], value, previousData[dataIndex]);\n             });\n        });\n    ",
    "olives-todo.js[87363:87711]": "\n        var item;\n        if (this.has(name)) {\n            item = this.get(name);\n            nestedProperty.set(item, property, value);\n            _storeObservable.notify(\"updated\", property, value);\n            _valueObservable.notify(name, item, \"updated\");\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[87926:88363]": "\n        var previous;\n        if (this.has(name)) {\n            if (!this.alter(\"splice\", name, 1)) {\n                previous = _data[name];\n                delete _data[name];\n                _storeObservable.notify(\"deleted\", name, undefined, previous);\n                _valueObservable.notify(name, _data[name], \"deleted\", previous);\n            }\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[88568:88996]": "\n        if (Array.isArray(indexes)) {\n            // Indexes must be removed from the greatest to the lowest\n            // To avoid trying to remove indexes that don't exist.\n            // i.e: given [0, 1, 2], remove 1, then 2, 2 doesn't exist anymore\n            indexes.sort(compareNumbers.desc)\n                .forEach(this.del, this);\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[89448:89812]": "\n        var apply,\n            previousData;\n\n        if (_data[func]) {\n            previousData = clone(_data);\n            apply = this.proxy.apply(this, arguments);\n            _notifyDiffs(previousData);\n            _storeObservable.notify(\"altered\", _data, previousData);\n            return apply;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[90214:90388]": "\n        if (_data[func]) {\n            return _data[func].apply(_data, Array.prototype.slice.call(arguments, 1));\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[90997:91053]": "\n        return _storeObservable.unwatch(handle);\n    ",
    "olives-todo.js[91283:91323]": "\n        return _storeObservable;\n    ",
    "olives-todo.js[91987:92044]": "\n        return _valueObservable.unwatch(handler);\n    ",
    "olives-todo.js[92290:92330]": "\n        return _valueObservable;\n    ",
    "olives-todo.js[92786:93105]": "\n        if (typeof data == \"object\") {\n            var previousData = clone(_data);\n            _data = clone(data) || {};\n            _notifyDiffs(previousData);\n            _storeObservable.notify(\"resetted\", _data, previousData);\n            return true;\n        } else {\n            return false;\n        }\n\n    ",
    "olives-todo.js[93712:94317]": "\n        var args = [];\n\n        if (typeof name == \"string\" &&\n            typeof computeFrom == \"object\" &&\n            typeof callback == \"function\" &&\n            !this.isCompute(name)) {\n\n            _computed[name] = [];\n\n            simpleLoop(computeFrom, function (property) {\n                _computed[name].push(this.watchValue(property, function () {\n                    this.set(name, callback.call(scope));\n                }, this));\n            }, this);\n\n            this.set(name, callback.call(scope));\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[94545:94856]": "\n        if (this.isCompute(name)) {\n            simpleLoop(_computed[name], function (handle) {\n                this.unwatchValue(handle);\n            }, this);\n            this.del(name);\n\n            delete _computed[name];\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[95091:95132]": "\n        return !!_computed[name];\n    ",
    "olives-todo.js[95487:95516]": "\n        return _data;\n    ",
    "olives-todo.js[96610:97612]": "\n  assert(typeof base == \"object\", \"the first object to compare with shallowDiff needs to be an object\");\n  assert(typeof compared == \"object\", \"the second object to compare with shallowDiff needs to be an object\");\n\n  var unchanged = [],\n      updated = [],\n      deleted = [],\n      added = [];\n\n   // Loop through the compared object\n   loop(compared, function (value, idx) {\n\n       // To get the added\n       if (typeof base[idx] == \"undefined\") {\n           added.push(idx);\n\n       // The updated\n     } else if (value !== base[idx]) {\n           updated.push(idx);\n\n       // And the unchanged\n     } else if (value === base[idx]) {\n           unchanged.push(idx);\n       }\n\n   });\n\n   // Loop through the before object\n   loop(base, function (value, idx) {\n\n      // To get the deleted\n      if (typeof compared[idx] == \"undefined\") {\n          deleted.push(idx);\n      }\n   });\n\n  return {\n      updated: updated,\n      unchanged: unchanged,\n      added: added,\n      deleted: deleted\n  };\n",
    "olives-todo.js[99357:104867]": "\n\n    /**\n     * The routes observable (the applications use it)\n     * @private\n     */\n    var _routes = new Observable(),\n\n    /**\n     * The events observable (used by Routing)\n     * @private\n     */\n    _events = new Observable(),\n\n    /**\n     * The routing history\n     * @private\n     */\n    _history = [],\n\n    /**\n     * For navigating through the history, remembers the current position\n     * @private\n     */\n    _currentPos = -1,\n\n    /**\n     * The depth of the history\n     * @private\n     */\n    _maxHistory = 10;\n\n    /**\n     * Only for debugging\n     * @private\n     */\n    this.getRoutesObservable = function getRoutesObservable() {\n        return _routes;\n    };\n\n    /**\n     * Only for debugging\n     * @private\n     */\n    this.getEventsObservable = function getEventsObservable() {\n        return _events;\n    };\n\n    /**\n     * Set the maximum length of history\n     * As the user navigates through the application, the\n     * routeur keeps track of the history. Set the depth of the history\n     * depending on your need and the amount of memory that you can allocate it\n     * @param {Number} maxHistory the depth of history\n     * @returns {Boolean} true if maxHistory is equal or greater than 0\n     */\n    this.setMaxHistory = function setMaxHistory(maxHistory) {\n        if (maxHistory >= 0) {\n            _maxHistory = maxHistory;\n            return true;\n        } else {\n            return false;\n        }\n\n    };\n\n    /**\n     * Get the current max history setting\n     * @returns {Number} the depth of history\n     */\n    this.getMaxHistory = function getMaxHistory() {\n        return _maxHistory;\n    };\n\n    /**\n     * Set a new route\n     * @param {String} route the name of the route\n     * @param {Function} func the function to be execute when navigating to the route\n     * @param {Object} scope the scope in which to execute the function\n     * @returns a handle to remove the route\n     */\n    this.set = function set() {\n        return _routes.watch.apply(_routes, arguments);\n    };\n\n    /**\n     * Remove a route\n     * @param {Object} handle the handle provided by the set method\n     * @returns true if successfully removed\n     */\n    this.unset = function unset(handle) {\n        return _routes.unwatch(handle);\n    };\n\n    /**\n     * Navigate to a route\n     * @param {String} route the route to navigate to\n     * @param {*} *params\n     * @returns\n     */\n    this.navigate = function get(route) {\n        if (this.load.apply(this, arguments)) {\n            // Before adding a new route to the history, we must clear the forward history\n            _history.splice(_currentPos +1, _history.length);\n            _history.push(toArray(arguments));\n            this.ensureMaxHistory(_history);\n            _currentPos = _history.length -1;\n            return true;\n        } else {\n            return false;\n        }\n\n    };\n\n    /**\n     * Ensure that history doesn't grow bigger than the max history setting\n     * @param {Store} history the history store\n     * @private\n     */\n    this.ensureMaxHistory = function ensureMaxHistory(history) {\n        var count = history.length,\n            max = this.getMaxHistory(),\n            excess = count - max;\n\n        if (excess > 0) {\n            history.splice(0, excess);\n        }\n    };\n\n    /**\n     * Actually loads the route\n     * @private\n     */\n    this.load = function load() {\n        var copy = toArray(arguments);\n\n        if (_routes.notify.apply(_routes, copy)) {\n            copy.unshift(\"route\");\n            _events.notify.apply(_events, copy);\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Watch for route changes\n     * @param {Function} func the func to execute when the route changes\n     * @param {Object} scope the scope in which to execute the function\n     * @returns {Object} the handle to unwatch for route changes\n     */\n    this.watch = function watch(func, scope) {\n        return _events.watch(\"route\", func, scope);\n    };\n\n    /**\n     * Unwatch routes changes\n     * @param {Object} handle the handle was returned by the watch function\n     * @returns true if unwatch\n     */\n    this.unwatch = function unwatch(handle) {\n        return _events.unwatch(handle);\n    };\n\n    /**\n     * Get the history store, for debugging only\n     * @private\n     */\n    this.getHistoryStore = function getHistoryStore() {\n        return _history;\n    };\n\n    /**\n     * Get the current length of history\n     * @returns {Number} the length of history\n     */\n    this.getHistoryCount = function getHistoryCount() {\n        return _history.length;\n    };\n\n    /**\n     * Flush the entire history\n     */\n    this.clearHistory = function clearHistory() {\n        _history.length = 0;\n    };\n\n    /**\n     * Go back and forth in the history\n     * @param {Number} nb the amount of history to rewind/forward\n     * @returns true if history exists\n     */\n    this.go = function go(nb) {\n        var history = _history[_currentPos + nb];\n        if (history) {\n            _currentPos += nb;\n            this.load.apply(this, history);\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Go back in the history, short for go(-1)\n     * @returns\n     */\n    this.back = function back() {\n        return this.go(-1);\n    };\n\n    /**\n     * Go forward in the history, short for go(1)\n     * @returns\n     */\n    this.forward = function forward() {\n        return this.go(1);\n    };\n\n",
    "olives-todo.js[105476:110342]": "\n\n    /**\n     * The handle on the watch\n     * @private\n     */\n    var _watchHandle,\n\n    /**\n     * The default route to navigate to when nothing is supplied in the url\n     * @private\n     */\n    _defaultRoute = \"\",\n\n    /**\n     * The last route that was navigated to\n     * @private\n     */\n    _lastRoute = window.location.hash;\n\n    /**\n     * Navigates to the current hash or to the default route if none is supplied in the url\n     * @private\n     */\n     /*jshint validthis:true*/\n    function doNavigate() {\n        if (!hashIsEmpty()) {\n            var parsedHash = this.parse(window.location.hash);\n            this.navigate.apply(this, parsedHash);\n        } else {\n            this.navigate(_defaultRoute);\n        }\n    }\n\n    /**\n     * An empty string or # are both empty hashes\n     */\n    function hashIsEmpty() {\n        return !window.location.hash || window.location.hash == \"#\";\n    }\n\n    /**\n     * Set the default route to navigate to when nothing is defined in the url\n     * @param {String} defaultRoute the defaultRoute to navigate to\n     * @returns {Boolean} true if it's not an empty string\n     */\n    this.setDefaultRoute = function setDefaultRoute(defaultRoute) {\n        if (defaultRoute && typeof defaultRoute == \"string\") {\n            _defaultRoute = defaultRoute;\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Get the currently set default route\n     * @returns {String} the default route\n     */\n    this.getDefaultRoute = function getDefaultRoute() {\n        return _defaultRoute;\n    };\n\n    /**\n     * The function that parses the url to determine the route to navigate to.\n     * It has a default behavior explained below, but can be overriden as long as\n     * it has the same contract.\n     * @param {String} hash the hash coming from window.location.has\n     * @returns {Array} has to return an array with the list of arguments to call\n     *    navigate with. The first item of the array must be the name of the route.\n     *\n     * Example: #album/holiday/2013\n     *      will navigate to the route \"album\" and give two arguments \"holiday\" and \"2013\"\n     */\n    this.parse = function parse(hash) {\n        return hash.split(\"#\").pop().split(\"/\");\n    };\n\n    /**\n     * The function that converts, or serialises the route and its arguments to a valid URL.\n     * It has a default behavior below, but can be overriden as long as it has the same contract.\n     * @param {Array} args the list of arguments to serialize\n     * @returns {String} the serialized arguments to add to the url hashmark\n     *\n     * Example:\n     *      [\"album\", \"holiday\", \"2013\"];\n     *      will give \"album/holiday/2013\"\n     *\n     */\n    this.toUrl = function toUrl(args) {\n        return args.join(\"/\");\n    };\n\n    /**\n     * When all the routes and handlers have been defined, start the location router\n     * so it parses the URL and navigates to the corresponding route.\n     * It will also start listening to route changes and hashmark changes to navigate.\n     * While navigating, the hashmark itself will also change to reflect the current route state\n     */\n    this.start = function start(defaultRoute) {\n        this.setDefaultRoute(defaultRoute);\n        doNavigate.call(this);\n        this.bindOnHashChange();\n        this.bindOnRouteChange();\n    };\n\n    /**\n     * Remove the events handler for cleaning.\n     */\n    this.destroy = function destroy() {\n        this.unwatch(_watchHandle);\n        window.removeEventListener(\"hashchange\", this.boundOnHashChange, true);\n    };\n\n    /**\n     * Parse the hash and navigate to the corresponding url\n     * @private\n     */\n    this.onHashChange  = function onHashChange() {\n        if (window.location.hash != _lastRoute) {\n            doNavigate.call(this);\n        }\n    };\n\n    /**\n     * The bound version of onHashChange for add/removeEventListener\n     * @private\n     */\n    this.boundOnHashChange = this.onHashChange.bind(this);\n\n    /**\n     * Add an event listener to hashchange to navigate to the corresponding route\n     * when it changes\n     * @private\n     */\n    this.bindOnHashChange = function bindOnHashChange() {\n        window.addEventListener(\"hashchange\", this.boundOnHashChange, true);\n    };\n\n    /**\n     * Watch route change events from the router to update the location\n     * @private\n     */\n    this.bindOnRouteChange = function bindOnRouteChange() {\n        _watchHandle = this.watch(this.onRouteChange, this);\n    };\n\n    /**\n     * The handler for when the route changes\n     * It updates the location\n     * @private\n     */\n    this.onRouteChange = function onRouteChange() {\n        window.location.hash = this.toUrl(toArray(arguments));\n        _lastRoute = window.location.hash;\n    };\n\n    this.getLastRoute = function getLastRoute() {\n        return _lastRoute;\n    };\n\n",
    "olives-todo.js[110390:110502]": "\n    UrlHighway.prototype = new Highway();\n    UrlHighway.constructor = Highway;\n    return new UrlHighway();\n",
    "olives-todo.js[111123:114626]": "\n\n    /**\n     * The list of topics\n     * @private\n     */\n    var _topics = {};\n\n    /**\n     * Add an observer\n     * @param {String} topic the topic to observe\n     * @param {Function} callback the callback to execute\n     * @param {Object} scope the scope in which to execute the callback\n     * @returns handle\n     */\n    this.watch = function watch(topic, callback, scope) {\n        if (typeof callback == \"function\") {\n            var observers = _topics[topic] = _topics[topic] || [],\n            observer = [callback, scope];\n\n            observers.push(observer);\n            return [topic,observers.indexOf(observer)];\n\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Listen to an event just once before removing the handler\n     * @param {String} topic the topic to observe\n     * @param {Function} callback the callback to execute\n     * @param {Object} scope the scope in which to execute the callback\n     * @returns handle\n     */\n    this.once = function once(topic, callback, scope) {\n        var handle = this.watch(topic, function () {\n            callback.apply(scope, arguments);\n            this.unwatch(handle);\n        }, this);\n        return handle;\n    };\n\n    /**\n     * Remove an observer\n     * @param {Handle} handle returned by the watch method\n     * @returns {Boolean} true if there were subscribers\n     */\n    this.unwatch = function unwatch(handle) {\n        var topic = handle[0], idx = handle[1];\n        if (_topics[topic] && _topics[topic][idx]) {\n            // delete value so the indexes don't move\n            delete _topics[topic][idx];\n            // If the topic is only set with falsy values, delete it;\n            if (!_topics[topic].some(function (value) {\n                return !!value;\n            })) {\n                delete _topics[topic];\n            }\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Notifies observers that a topic has a new message\n     * @param {String} topic the name of the topic to publish to\n     * @param subject\n     * @returns {Boolean} true if there was subscribers\n     */\n    this.notify = function notify(topic) {\n        var observers = _topics[topic],\n            args = toArray(arguments).slice(1);\n\n        if (observers) {\n            loop(observers, function (value) {\n                try {\n                    if (value) {\n                        value[0].apply(value[1] || null, args);\n                    }\n                } catch (err) { }\n            });\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Check if topic has the described observer\n     * @param {Handle}\n     * @returns {Boolean} true if exists\n     */\n    this.hasObserver = function hasObserver(handle) {\n        return !!( handle && _topics[handle[0]] && _topics[handle[0]][handle[1]]);\n    };\n\n    /**\n     * Check if a topic has observers\n     * @param {String} topic the name of the topic\n     * @returns {Boolean} true if topic is listened\n     */\n    this.hasTopic = function hasTopic(topic) {\n        return !!_topics[topic];\n    };\n\n    /**\n     * Unwatch all or unwatch all from topic\n     * @param {String} topic optional unwatch all from topic\n     * @returns {Boolean} true if ok\n     */\n    this.unwatchAll = function unwatchAll(topic) {\n        if (_topics[topic]) {\n            delete _topics[topic];\n        } else {\n            _topics = {};\n        }\n        return true;\n    };\n",
    "olives-todo.js[115847:115925]": "\n    return typeof ui == \"object\" &&\n        typeof ui.place == \"function\";\n",
    "olives-todo.js[116193:117936]": "\n\n    /**\n     * The list of uis currently set in this place plugin\n     * @private\n     */\n    var _uis = {};\n\n    /**\n     * Attach a SeamView to this DOM element\n     * @param {HTML|SVGElement} node the dom node where to attach the SeamView\n     * @param {String} the name of the SeamView to attach\n     * @throws {NoSuchSeamView} an error if there's no SeamView for the given name\n     */\n    this.place = function place(node, name) {\n        if (_uis[name]) {\n            _uis[name].place(node);\n        } else {\n            throw new Error(name + \" is not a SeamView UI in place: \" + name);\n        }\n    };\n\n    /**\n     * Add an SeamView that can be attached to a dom element\n     * @param {String} the name of the SeamView to add to the list\n     * @param {SeamView} ui the SeamView to add the list\n     * @returns {Boolean} true if the SeamView was added\n     */\n    this.set = function set(name, ui) {\n        if (typeof name == \"string\" && isSeamView(ui)) {\n            _uis[name] = ui;\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Add multiple dom elements at once\n     * @param {Object} $uis a list of SeamViews such as:\n     *   {\n     *      \"header\": new SeamView(),\n     *      \"list\": new SeamView()\n     *   }\n     */\n    this.setAll = function setAll(uis) {\n        simpleLoop(uis, function (ui, name) {\n            this.set(name, ui);\n        }, this);\n    };\n\n    /**\n     * Returns a SeamView from the list given its name\n     * @param {String} the name of the SeamView to get\n     * @returns {SeamView} SeamView for the given name\n     */\n    this.get = function get(name) {\n        return _uis[name];\n    };\n\n    if ($uis) {\n        this.setAll($uis);\n    }\n\n",
    "olives-todo.js[118241:118569]": "\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n",
    "olives-todo.js[118604:118690]": "\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n",
    "olives-todo.js[118882:118884]": "",
    "olives-todo.js[119096:119156]": "\n    throw new Error('process.binding is not supported');\n",
    "olives-todo.js[119203:119217]": " return '/' ",
    "olives-todo.js[119250:119308]": "\n    throw new Error('process.chdir is not supported');\n",
    "olives-todo.js[119337:119350]": " return 0; ",
    "olives-todo.js[124067:124119]": "\n        _stateMachine.event(\"render\", this);\n    ",
    "olives-todo.js[125321:125358]": "\n        return _currentPlace;\n    ",
    "olives-todo.js[128236:128325]": "\n                        return this.apply.apply(this, arguments);\n                    ",
    "olives-todo.js[128939:128977]": "\n        return _plugins[name];\n    ",
    "olives-todo.js[129160:129205]": "\n        return delete _plugins[name];\n    ",
    "olives-todo.js[130546:130680]": "\n    var keys = [];\n    for (var key in obj) {\n        if ({}.hasOwnProperty.call(obj, key)) keys.push(key);\n    }\n    return keys;\n",
    "olives-todo.js[130728:130785]": "\n    return {}.toString.call(xs) === '[object Array]';\n",
    "olives-todo.js[131050:131134]": "\n    if (assertion) {\n        throw new TypeError(\"simple-loop: \" + error);\n    }\n",
    "olives-todo.js[131847:132880]": "\n    assert(typeof base != \"object\", \"the first object to compare with shallowDiff needs to be an object\");\n    assert(typeof compared != \"object\", \"the second object to compare with shallowDiff needs to be an object\");\n\n    var unchanged = [],\n        updated = [],\n        deleted = [],\n        added = [];\n\n    // Loop through the compared object\n    loop(compared, function(value, idx) {\n        // To get the added items\n        if (!(idx in base)) {\n            added.push(idx);\n\n        // The updated items\n        } else if (value !== base[idx]) {\n            updated.push(idx);\n\n        // And the unchanged\n        } else if (value === base[idx]) {\n            unchanged.push(idx);\n        }\n    });\n\n    // Loop through the before object\n    loop(base, function(value, idx) {\n        // To get the deleted items\n        if (!(idx in compared)) {\n            deleted.push(idx);\n        }\n    });\n\n    return {\n        updated: updated,\n        unchanged: unchanged,\n        added: added,\n        deleted: deleted\n    };\n",
    "olives-todo.js[134763:134943]": "\n    loop(source, function (value, idx) {\n        if (!destination[idx] || !dontOverride) {\n            destination[idx] = source[idx];\n        }\n    });\n    return destination;\n",
    "olives-todo.js[135470:139026]": "\n\n\t/**\n\t * @private\n\t * The socket.io's socket\n\t */\n\tvar _socket = null;\n\n\t/**\n\t * Set the socket created by SocketIO\n\t * @param {Object} socket the socket.io socket\n\t * @returns true if it seems to be a socket.io socket\n\t */\n\tthis.setSocket = function setSocket(socket) {\n\t\tif (socket && typeof socket.emit == \"function\") {\n\t\t\t_socket = socket;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Get the socket, for debugging purpose\n\t * @private\n\t * @returns {Object} the socket\n\t */\n\tthis.getSocket = function getSocket() {\n\t\treturn _socket;\n\t};\n\n\t/**\n\t * Subscribe to a socket event\n\t * @param {String} event the name of the event\n\t * @param {Function} func the function to execute when the event fires\n\t */\n\tthis.on = function on(event, func) {\n\t\treturn _socket.on(event, func);\n\t};\n\n\t/**\n\t * Subscribe to a socket event but disconnect as soon as it fires.\n\t * @param {String} event the name of the event\n\t * @param {Function} func the function to execute when the event fires\n\t */\n\tthis.once = function once(event, func) {\n\t\treturn _socket.once(event, func);\n\t};\n\n\t/**\n\t * Publish an event on the socket\n\t * @param {String} event the event to publish\n\t * @param data\n\t * @param {Function} callback is the function to be called for ack\n\t */\n\tthis.emit = function emit(event, data, callback) {\n\t\treturn _socket.emit(event, data, callback);\n\t};\n\n\t/**\n\t * Stop listening to events on a channel\n\t * @param {String} event the event to publish\n\t * @param data\n\t * @param {Function} callback is the function to be called for ack\n\t */\n\tthis.removeListener = function removeListener(event, data, callback) {\n\t\treturn _socket.removeListener(event, data, callback);\n\t};\n\n\t/**\n\t * Make a request on the node server\n\t * @param {String} channel watch the server's documentation to see available channels\n\t * @param data the request data, it could be anything\n\t * @param {Function} func the callback that will get the response.\n\t * @param {Object} scope the scope in which to execute the callback\n\t */\n\tthis.request = function request(channel, data, func, scope) {\n\t\tif (typeof channel == \"string\" &&\n\t\t\t\ttypeof data != \"undefined\") {\n\n\t\t\tvar reqData = {\n\t\t\t\t\teventId: Date.now() + Math.floor(Math.random()*1e6),\n\t\t\t\t\tdata: data\n\t\t\t\t},\n\t\t\t\tboundCallback = function () {\n\t\t\t\t\tif (func) {\n\t\t\t\t\t\tfunc.apply(scope || null, arguments);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tthis.once(reqData.eventId, boundCallback);\n\n\t\t\tthis.emit(channel, reqData);\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Listen to an url and get notified on new data\n\t * @param {String} channel watch the server's documentation to see available channels\n\t * @param data the request data, it could be anything\n\t * @param {Function} func the callback that will get the data\n\t * @param {Object} scope the scope in which to execute the callback\n\t * @returns\n\t */\n\tthis.listen = function listen(channel, data, func, scope) {\n\t\tif (typeof channel == \"string\" &&\n\t\t\t\ttypeof data != \"undefined\" &&\n\t\t\t\ttypeof func == \"function\") {\n\n\t\t\tvar reqData = {\n\t\t\t\t\teventId: Date.now() + Math.floor(Math.random()*1e6),\n\t\t\t\t\tdata: data,\n\t\t\t\t\tkeepAlive: true\n\t\t\t\t},\n\t\t\t\tboundCallback = function () {\n\t\t\t\t\tif (func) {\n\t\t\t\t\t\tfunc.apply(scope || null, arguments);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tthat = this;\n\n\t\t\tthis.on(reqData.eventId, boundCallback);\n\n\t\t\tthis.emit(channel, reqData);\n\n\t\t\treturn function stop() {\n\t\t\t\tthat.emit(\"disconnect-\" + reqData.eventId);\n\t\t\t\tthat.removeListener(reqData.eventId, boundCallback);\n\t\t\t};\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Sets the socket.io\n\t */\n\tthis.setSocket($socket);\n",
    "olives-todo.js[139695:141312]": "\n\n    if (isConnected) {\n        return false;\n    } else {\n\n        // On connection we'll reference the handlers in socket.io\n        io.sockets.on(\"connection\", function (socket) {\n\n            var connectHandler = function (func, handler) {\n                // When a handler is called\n                socket.on(handler, function (reqData) {\n\n                    // Add socket.io's handshake for session management\n                    reqData.data.handshake = socket.handshake;\n\n                    // pass it the requests data\n                    var stop = func(reqData.data,\n                        // The function to handle the result\n                        function onEnd(body) {\n                            socket.emit(reqData.eventId, body);\n                        },\n                        // The function to handle chunks for a kept alive socket\n                        function onData(chunk) {\n                            reqData.keepAlive && socket.emit(reqData.eventId, \"\"+chunk);\n                        });\n\n                    // If func returned a stop function\n                    if (typeof stop == \"function\") {\n                        // Subscribe to disconnect-eventId event\n                        socket.on(\"disconnect-\"+reqData.eventId, stop);\n                    }\n\n                });\n\n            };\n\n            // for each handler, described in Emily as they can be used from node.js as well\n            handlers.loop(connectHandler);\n            // Also connect on new handlers\n            handlers.watch(\"added\", connectHandler);\n\n        });\n\n        isConnected = true;\n    }\n",
    "olives-todo.js[143326:143363]": "\n        return _states[name];\n    ",
    "olives-todo.js[143480:143517]": "\n        return _currentState;\n    ",
    "olives-todo.js[143732:143785]": "\n        return _states.hasOwnProperty(state);\n    ",
    "olives-todo.js[144038:144189]": "\n        if (this.has(state)) {\n            _currentState = state;\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[147113:147158]": "\n        return !!_transitions[event];\n    ",
    "olives-todo.js[147349:147401]": "\n        return _transitions[event] || false;\n    ",
    "olives-todo.js[148993:151844]": "\n\n    /**\n     * The request handlers\n     * @private\n     */\n    var _reqHandlers = null;\n\n    /**\n     * Set the requests handlers object\n     * @param {Emily Store} reqHandlers an object containing the requests handlers\n     * @returns\n     */\n    this.setReqHandlers = function setReqHandlers(reqHandlers) {\n        if (typeof reqHandlers == \"object\") {\n            _reqHandlers = reqHandlers;\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Get the requests handlers\n     * @returns{ Emily Store} reqHandlers the object containing the requests handlers\n     */\n    this.getReqHandlers = function getReqHandlers() {\n        return _reqHandlers;\n    };\n\n    /**\n     * Issue a request to a request handler\n     * @param {String} reqHandler the name of the request handler to issue the request to\n     * @param {Object} data the data, or payload, to send to the request handler\n     * @param {Function} callback the function to execute with the result\n     * @param {Object} scope the scope in which to execute the callback\n     * @returns\n     */\n    this.request = function request(reqHandler, data, callback, scope) {\n        if (_reqHandlers.has(reqHandler) &&\n            typeof data != \"undefined\") {\n\n            _reqHandlers.get(reqHandler)(data, function () {\n                if (callback) {\n                    callback.apply(scope, arguments);\n                }\n            });\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n     * Issue a request to a reqHandler but keep listening for the response as it can be sent in several chunks\n     * or remain open as long as the abort funciton is not called\n     * @param {String} reqHandler the name of the request handler to issue the request to\n     * @param {Object} data the data, or payload, to send to the request handler\n     * @param {Function} callback the function to execute with the result\n     * @param {Object} scope the scope in which to execute the callback\n     * @returns {Function} the abort function to call to stop listening\n     */\n    this.listen = function listen(reqHandler, data, callback, scope) {\n        var func,\n            abort;\n\n        if (_reqHandlers.has(reqHandler) &&\n            typeof data != \"undefined\" &&\n            typeof callback == \"function\") {\n\n            func = callback.bind(scope);\n            abort = _reqHandlers.get(reqHandler)(data, func, func);\n\n            return function () {\n                if (typeof abort == \"function\") {\n                    abort();\n                } else if (typeof abort == \"object\" && typeof abort.func == \"function\") {\n                    abort.func.call(abort.scope);\n                }\n            };\n        } else {\n            return false;\n        }\n    };\n\n    this.setReqHandlers($reqHandlers);\n\n",
    "olives-todo.js[153848:153885]": "\n        return _defaultRoute;\n    ",
    "olives-todo.js[154505:154561]": "\n        return hash.split(\"#\").pop().split(\"/\");\n    ",
    "olives-todo.js[155752:155875]": "\n        this.unwatch(_watchHandle);\n        window.removeEventListener(\"hashchange\", this.boundOnHashChange, true);\n    ",
    "olives-todo.js[158812:158875]": "\n        return _routes.watch.apply(_routes, arguments);\n    ",
    "olives-todo.js[159069:159116]": "\n        return _routes.unwatch(handle);\n    ",
    "olives-todo.js[159734:159962]": "\n        var history = _history[_currentPos + nb];\n        if (history) {\n            _currentPos += nb;\n            load.apply(this, history);\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[160108:160143]": "\n        return this.go(-1);\n    ",
    "olives-todo.js[160300:160334]": "\n        return this.go(1);\n    ",
    "olives-todo.js[160899:160946]": "\n        return _events.unwatch(handle);\n    ",
    "olives-todo.js[161402:161588]": "\n        if (maxHistory >= 0) {\n            _maxHistory = maxHistory;\n            ensureMaxHistory();\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[161895:161934]": "\n        return _history.length;\n    ",
    "olives-todo.js[162033:162069]": "\n        _history.length = 0;\n    ",
    "olives-todo.js[162236:162400]": "\n        if (typeof index == \"undefined\") {\n            return _history;\n        } else {\n            return _history[_history.length - index - 1];\n        }\n    ",
    "olives-todo.js[163104:163267]": "\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n",
    "olives-todo.js[164534:165357]": "\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n",
    "olives-todo.js[165552:166167]": "\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n",
    "olives-todo.js[166239:166702]": "\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n",
    "olives-todo.js[167023:167728]": "\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n",
    "olives-todo.js[168439:168647]": "\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n",
    "olives-todo.js[168690:168707]": "\n  return str;\n",
    "olives-todo.js[168738:168840]": "\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n",
    "olives-todo.js[168890:171959]": "\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n",
    "olives-todo.js[171999:172628]": "\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n",
    "olives-todo.js[172659:172721]": "\n  return '[' + Error.prototype.toString.call(value) + ']';\n",
    "olives-todo.js[172790:173239]": "\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n",
    "olives-todo.js[173317:174859]": "\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n",
    "olives-todo.js[174914:175389]": "\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n",
    "olives-todo.js[175562:175593]": "\n  return Array.isArray(ar);\n",
    "olives-todo.js[175646:175684]": "\n  return typeof arg === 'boolean';\n",
    "olives-todo.js[175738:175764]": "\n  return arg === null;\n",
    "olives-todo.js[175823:175848]": "\n  return arg == null;\n",
    "olives-todo.js[175920:175957]": "\n  return typeof arg === 'number';\n",
    "olives-todo.js[176011:176048]": "\n  return typeof arg === 'string';\n",
    "olives-todo.js[176102:176139]": "\n  return typeof arg === 'symbol';\n",
    "olives-todo.js[176196:176224]": "\n  return arg === void 0;\n",
    "olives-todo.js[176283:176353]": "\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n",
    "olives-todo.js[176407:176460]": "\n  return typeof arg === 'object' && arg !== null;\n",
    "olives-todo.js[176510:176576]": "\n  return isObject(d) && objectToString(d) === '[object Date]';\n",
    "olives-todo.js[176623:176720]": "\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n",
    "olives-todo.js[176774:176813]": "\n  return typeof arg === 'function';\n",
    "olives-todo.js[176874:177099]": "\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n",
    "olives-todo.js[177214:177261]": "\n  return Object.prototype.toString.call(o);\n",
    "olives-todo.js[177280:177340]": "\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n",
    "olives-todo.js[177497:177698]": "\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n",
    "olives-todo.js[177797:177881]": "\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n",
    "olives-todo.js[178581:178803]": "\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n",
    "olives-todo.js[178841:178902]": "\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n",
    "olives-todo.js[180740:180921]": "\n        var handle = this.watch(topic, function () {\n            callback.apply(scope, arguments);\n            this.unwatch(handle);\n        }, this);\n        return handle;\n    ",
    "olives-todo.js[181126:181635]": "\n        var topic = handle[0], idx = handle[1];\n        if (_topics[topic] && _topics[topic][idx]) {\n            // delete value so the indexes don't move\n            delete _topics[topic][idx];\n            // If the topic is only set with falsy values, delete it;\n            if (!_topics[topic].some(function (value) {\n                return !!value;\n            })) {\n                delete _topics[topic];\n            }\n            return true;\n        } else {\n            return false;\n        }\n    ",
    "olives-todo.js[182639:182729]": "\n        return !!( handle && _topics[handle[0]] && _topics[handle[0]][handle[1]]);\n    ",
    "olives-todo.js[182934:182974]": "\n        return !!_topics[topic];\n    ",
    "olives-todo.js[183185:183331]": "\n        if (_topics[topic]) {\n            delete _topics[topic];\n        } else {\n            _topics = {};\n        }\n        return true;\n    "
}