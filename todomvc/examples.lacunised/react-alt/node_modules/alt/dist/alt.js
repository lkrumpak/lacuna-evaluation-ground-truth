// LACUNA LAZY LOAD FALLBACK
function lacuna_lazy_load(id, callback){
    fetch("http://127.0.0.1:8125/lazyload/", {
        method: "POST",
        headers: { "Accept": "application/json", "Content-Type": "application/json" },
        body: JSON.stringify({id})
    }).then(response => {
        return response.text();
    }).then(callback);
}
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Alt"] = factory();
	else
		root["Alt"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* global window */
	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var _bind = Function.prototype.bind;

	var _get = function get(_x3, _x4, _x5) {lacuna_lazy_load("node_modules/alt/dist/alt.js[2046:2676]", functionData => eval(functionData))};

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _toConsumableArray(arr) {lacuna_lazy_load("node_modules/alt/dist/alt.js[3657:3815]", functionData => eval(functionData))}

	function _inherits(subClass, superClass) {lacuna_lazy_load("node_modules/alt/dist/alt.js[3859:4312]", functionData => eval(functionData))}

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _flux = __webpack_require__(2);

	var _utilsStateFunctions = __webpack_require__(5);

	var StateFunctions = _interopRequireWildcard(_utilsStateFunctions);

	var _utilsFunctions = __webpack_require__(6);

	var fn = _interopRequireWildcard(_utilsFunctions);

	var _store = __webpack_require__(7);

	var store = _interopRequireWildcard(_store);

	var _utilsAltUtils = __webpack_require__(8);

	var utils = _interopRequireWildcard(_utilsAltUtils);

	var _actions = __webpack_require__(12);

	var _actions2 = _interopRequireDefault(_actions);

	var Alt = (function () {
	  function Alt() {
	    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Alt);

	    this.config = config;
	    this.serialize = config.serialize || JSON.stringify;
	    this.deserialize = config.deserialize || JSON.parse;
	    this.dispatcher = config.dispatcher || new _flux.Dispatcher();
	    this.batchingFunction = config.batchingFunction || function (callback) {lacuna_lazy_load("node_modules/alt/dist/alt.js[5473:5507]", functionData => eval(functionData))};
	    this.actions = { global: {} };
	    this.stores = {};
	    this.storeTransforms = config.storeTransforms || [];
	    this.trapAsync = false;
	    this._actionsRegistry = {};
	    this._initSnapshot = {};
	    this._lastSnapshot = {};
	  }

	  _createClass(Alt, [{
	    key: 'dispatch',
	    value: function dispatch(action, data, details) {lacuna_lazy_load("node_modules/alt/dist/alt.js[5853:6272]", functionData => eval(functionData))}
	  }, {
	    key: 'createUnsavedStore',
	    value: function createUnsavedStore(StoreModel) {lacuna_lazy_load("node_modules/alt/dist/alt.js[6365:6878]", functionData => eval(functionData))}
	  }, {
	    key: 'createStore',
	    value: function createStore(StoreModel, iden) {
	      var key = iden || StoreModel.displayName || StoreModel.name || '';
	      store.createStoreConfig(this.config, StoreModel);
	      var Store = store.transformStore(this.storeTransforms, StoreModel);

	      /* istanbul ignore next */
	      if (false) delete this.stores[key];

	      if (this.stores[key] || !key) {
	        if (this.stores[key]) {
	          utils.warn('A store named ' + key + ' already exists, double check your store ' + 'names or pass in your own custom identifier for each store');
	        } else {
	          utils.warn('Store name was not specified');
	        }

	        key = utils.uid(this.stores, key);
	      }

	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }

	      var storeInstance = fn.isFunction(Store) ? store.createStoreFromClass.apply(store, [this, Store, key].concat(args)) : store.createStoreFromObject(this, Store, key);

	      this.stores[key] = storeInstance;
	      StateFunctions.saveInitialSnapshot(this, key);

	      return storeInstance;
	    }
	  }, {
	    key: 'generateActions',
	    value: function generateActions() {
	      var actions = { name: 'global' };

	      for (var _len3 = arguments.length, actionNames = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        actionNames[_key3] = arguments[_key3];
	      }

	      return this.createActions(actionNames.reduce(function (obj, action) {
	        obj[action] = utils.dispatchIdentity;
	        return obj;
	      }, actions));
	    }
	  }, {
	    key: 'createAction',
	    value: function createAction(name, implementation, obj) {lacuna_lazy_load("node_modules/alt/dist/alt.js[8650:8742]", functionData => eval(functionData))}
	  }, {
	    key: 'createActions',
	    value: function createActions(ActionsClass) {
	      var _arguments2 = arguments,
	          _this2 = this;

	      var exportObj = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var actions = {};
	      var key = utils.uid(this._actionsRegistry, ActionsClass.displayName || ActionsClass.name || 'Unknown');

	      if (fn.isFunction(ActionsClass)) {
	        var _len4, argsForConstructor, _key4;

	        (function () {lacuna_lazy_load("node_modules/alt/dist/alt.js[9238:10773]", functionData => eval(functionData))})();
	      } else {
	        fn.assign(actions, ActionsClass);
	      }

	      this.actions[key] = this.actions[key] || {};

	      fn.eachObject(function (actionName, action) {
	        if (!fn.isFunction(action)) {
	          return;
	        }

	        // create the action
	        exportObj[actionName] = (0, _actions2['default'])(_this2, key, actionName, action, exportObj);

	        // generate a constant
	        var constant = utils.formatAsConstant(actionName);
	        exportObj[constant] = exportObj[actionName].id;
	      }, [actions]);
	      return exportObj;
	    }
	  }, {
	    key: 'takeSnapshot',
	    value: function takeSnapshot() {lacuna_lazy_load("node_modules/alt/dist/alt.js[11431:11746]", functionData => eval(functionData))}
	  }, {
	    key: 'rollback',
	    value: function rollback() {lacuna_lazy_load("node_modules/alt/dist/alt.js[11809:12002]", functionData => eval(functionData))}
	  }, {
	    key: 'recycle',
	    value: function recycle() {lacuna_lazy_load("node_modules/alt/dist/alt.js[12063:12553]", functionData => eval(functionData))}
	  }, {
	    key: 'flush',
	    value: function flush() {lacuna_lazy_load("node_modules/alt/dist/alt.js[12610:12728]", functionData => eval(functionData))}
	  }, {
	    key: 'bootstrap',
	    value: function bootstrap(data) {lacuna_lazy_load("node_modules/alt/dist/alt.js[12797:12975]", functionData => eval(functionData))}
	  }, {
	    key: 'prepare',
	    value: function prepare(storeInst, payload) {lacuna_lazy_load("node_modules/alt/dist/alt.js[13054:13286]", functionData => eval(functionData))}

	    // Instance type methods for injecting alt into your application as context

	  }, {
	    key: 'addActions',
	    value: function addActions(name, ActionsClass) {lacuna_lazy_load("node_modules/alt/dist/alt.js[13454:13805]", functionData => eval(functionData))}
	  }, {
	    key: 'addStore',
	    value: function addStore(name, StoreModel) {lacuna_lazy_load("node_modules/alt/dist/alt.js[13884:14146]", functionData => eval(functionData))}
	  }, {
	    key: 'getActions',
	    value: function getActions(name) {lacuna_lazy_load("node_modules/alt/dist/alt.js[14217:14259]", functionData => eval(functionData))}
	  }, {
	    key: 'getStore',
	    value: function getStore(name) {lacuna_lazy_load("node_modules/alt/dist/alt.js[14326:14367]", functionData => eval(functionData))}
	  }], [{
	    key: 'debug',
	    value: function debug(name, alt) {lacuna_lazy_load("node_modules/alt/dist/alt.js[14435:14641]", functionData => eval(functionData))}
	  }]);

	  return Alt;
	})();

	exports['default'] = Alt;
	module.exports = exports['default'];

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	module.exports.Dispatcher = __webpack_require__(3)


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Dispatcher
	 * @typechecks
	 */

	"use strict";

	var invariant = __webpack_require__(4);

	var _lastID = 1;
	var _prefix = 'ID_';

	/**
	 * Dispatcher is used to broadcast payloads to registered callbacks. This is
	 * different from generic pub-sub systems in two ways:
	 *
	 *   1) Callbacks are not subscribed to particular events. Every payload is
	 *      dispatched to every registered callback.
	 *   2) Callbacks can be deferred in whole or part until other callbacks have
	 *      been executed.
	 *
	 * For example, consider this hypothetical flight destination form, which
	 * selects a default city when a country is selected:
	 *
	 *   var flightDispatcher = new Dispatcher();
	 *
	 *   // Keeps track of which country is selected
	 *   var CountryStore = {country: null};
	 *
	 *   // Keeps track of which city is selected
	 *   var CityStore = {city: null};
	 *
	 *   // Keeps track of the base flight price of the selected city
	 *   var FlightPriceStore = {price: null}
	 *
	 * When a user changes the selected city, we dispatch the payload:
	 *
	 *   flightDispatcher.dispatch({
	 *     actionType: 'city-update',
	 *     selectedCity: 'paris'
	 *   });
	 *
	 * This payload is digested by `CityStore`:
	 *
	 *   flightDispatcher.register(function(payload) {
	 *     if (payload.actionType === 'city-update') {
	 *       CityStore.city = payload.selectedCity;
	 *     }
	 *   });
	 *
	 * When the user selects a country, we dispatch the payload:
	 *
	 *   flightDispatcher.dispatch({
	 *     actionType: 'country-update',
	 *     selectedCountry: 'australia'
	 *   });
	 *
	 * This payload is digested by both stores:
	 *
	 *    CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
	 *     if (payload.actionType === 'country-update') {
	 *       CountryStore.country = payload.selectedCountry;
	 *     }
	 *   });
	 *
	 * When the callback to update `CountryStore` is registered, we save a reference
	 * to the returned token. Using this token with `waitFor()`, we can guarantee
	 * that `CountryStore` is updated before the callback that updates `CityStore`
	 * needs to query its data.
	 *
	 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
	 *     if (payload.actionType === 'country-update') {
	 *       // `CountryStore.country` may not be updated.
	 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
	 *       // `CountryStore.country` is now guaranteed to be updated.
	 *
	 *       // Select the default city for the new country
	 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
	 *     }
	 *   });
	 *
	 * The usage of `waitFor()` can be chained, for example:
	 *
	 *   FlightPriceStore.dispatchToken =
	 *     flightDispatcher.register(function(payload) {
	 *       switch (payload.actionType) {
	 *         case 'country-update':
	 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
	 *           FlightPriceStore.price =
	 *             getFlightPriceStore(CountryStore.country, CityStore.city);
	 *           break;
	 *
	 *         case 'city-update':
	 *           FlightPriceStore.price =
	 *             FlightPriceStore(CountryStore.country, CityStore.city);
	 *           break;
	 *     }
	 *   });
	 *
	 * The `country-update` payload will be guaranteed to invoke the stores'
	 * registered callbacks in order: `CountryStore`, `CityStore`, then
	 * `FlightPriceStore`.
	 */

	  function Dispatcher() {
	    this.$Dispatcher_callbacks = {};
	    this.$Dispatcher_isPending = {};
	    this.$Dispatcher_isHandled = {};
	    this.$Dispatcher_isDispatching = false;
	    this.$Dispatcher_pendingPayload = null;
	  }

	  /**
	   * Registers a callback to be invoked with every dispatched payload. Returns
	   * a token that can be used with `waitFor()`.
	   *
	   * @param {function} callback
	   * @return {string}
	   */
	  Dispatcher.prototype.register=function(callback) {
	    var id = _prefix + _lastID++;
	    this.$Dispatcher_callbacks[id] = callback;
	    return id;
	  };

	  /**
	   * Removes a callback based on its token.
	   *
	   * @param {string} id
	   */
	  Dispatcher.prototype.unregister=function(id) {lacuna_lazy_load("node_modules/alt/dist/alt.js[19736:19941]", functionData => eval(functionData))};

	  /**
	   * Waits for the callbacks specified to be invoked before continuing execution
	   * of the current callback. This method should only be used by a callback in
	   * response to a dispatched payload.
	   *
	   * @param {array<string>} ids
	   */
	  Dispatcher.prototype.waitFor=function(ids) {lacuna_lazy_load("node_modules/alt/dist/alt.js[20245:20938]", functionData => eval(functionData))};

	  /**
	   * Dispatches a payload to all registered callbacks.
	   *
	   * @param {object} payload
	   */
	  Dispatcher.prototype.dispatch=function(payload) {lacuna_lazy_load("node_modules/alt/dist/alt.js[21098:21559]", functionData => eval(functionData))};

	  /**
	   * Is this Dispatcher currently dispatching.
	   *
	   * @return {boolean}
	   */
	  Dispatcher.prototype.isDispatching=function() {lacuna_lazy_load("node_modules/alt/dist/alt.js[21703:21753]", functionData => eval(functionData))};

	  /**
	   * Call the callback stored with the given id. Also do some internal
	   * bookkeeping.
	   *
	   * @param {string} id
	   * @internal
	   */
	  Dispatcher.prototype.$Dispatcher_invokeCallback=function(id) {lacuna_lazy_load("node_modules/alt/dist/alt.js[21972:22136]", functionData => eval(functionData))};

	  /**
	   * Set up bookkeeping needed when dispatching.
	   *
	   * @param {object} payload
	   * @internal
	   */
	  Dispatcher.prototype.$Dispatcher_startDispatching=function(payload) {lacuna_lazy_load("node_modules/alt/dist/alt.js[22326:22575]", functionData => eval(functionData))};

	  /**
	   * Clear bookkeeping used for dispatching.
	   *
	   * @internal
	   */
	  Dispatcher.prototype.$Dispatcher_stopDispatching=function() {lacuna_lazy_load("node_modules/alt/dist/alt.js[22723:22819]", functionData => eval(functionData))};


	module.exports = Dispatcher;


/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */

	"use strict";

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {lacuna_lazy_load("node_modules/alt/dist/alt.js[23710:24429]", functionData => eval(functionData))};

	module.exports = invariant;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.setAppState = setAppState;
	exports.snapshot = snapshot;
	exports.saveInitialSnapshot = saveInitialSnapshot;
	exports.filterSnapshots = filterSnapshots;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _utilsFunctions = __webpack_require__(6);

	var fn = _interopRequireWildcard(_utilsFunctions);

	function setAppState(instance, data, onStore) {lacuna_lazy_load("node_modules/alt/dist/alt.js[25206:25846]", functionData => eval(functionData))}

	function snapshot(instance) {lacuna_lazy_load("node_modules/alt/dist/alt.js[25877:26475]", functionData => eval(functionData))}

	function saveInitialSnapshot(instance, key) {
	  var state = instance.deserialize(instance.serialize(instance.stores[key].state));
	  instance._initSnapshot[key] = state;
	  instance._lastSnapshot[key] = state;
	}

	function filterSnapshots(instance, state, stores) {lacuna_lazy_load("node_modules/alt/dist/alt.js[26744:27020]", functionData => eval(functionData))}

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.isPojo = isPojo;
	exports.isPromise = isPromise;
	exports.eachObject = eachObject;
	exports.assign = assign;
	var isFunction = function isFunction(x) {
	  return typeof x === 'function';
	};

	exports.isFunction = isFunction;

	function isPojo(target) {lacuna_lazy_load("node_modules/alt/dist/alt.js[27419:27648]", functionData => eval(functionData))}

	function isPromise(obj) {lacuna_lazy_load("node_modules/alt/dist/alt.js[27675:27788]", functionData => eval(functionData))}

	function eachObject(f, o) {
	  o.forEach(function (from) {
	    Object.keys(Object(from)).forEach(function (key) {
	      f(key, from[key]);
	    });
	  });
	}

	function assign(target) {
	  for (var _len = arguments.length, source = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    source[_key - 1] = arguments[_key];
	  }

	  eachObject(function (key, value) {
	    return target[key] = value;
	  }, source);
	  return target;
	}

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var _bind = Function.prototype.bind;

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	exports.createStoreConfig = createStoreConfig;
	exports.transformStore = transformStore;
	exports.createStoreFromObject = createStoreFromObject;
	exports.createStoreFromClass = createStoreFromClass;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _utilsAltUtils = __webpack_require__(8);

	var utils = _interopRequireWildcard(_utilsAltUtils);

	var _utilsFunctions = __webpack_require__(6);

	var fn = _interopRequireWildcard(_utilsFunctions);

	var _AltStore = __webpack_require__(9);

	var _AltStore2 = _interopRequireDefault(_AltStore);

	var _StoreMixin = __webpack_require__(11);

	var _StoreMixin2 = _interopRequireDefault(_StoreMixin);

	function doSetState(store, storeInstance, state) {lacuna_lazy_load("node_modules/alt/dist/alt.js[30792:31126]", functionData => eval(functionData))}

	function createPrototype(proto, alt, key, extras) {
	  return fn.assign(proto, _StoreMixin2['default'], {
	    displayName: key,
	    alt: alt,
	    dispatcher: alt.dispatcher,
	    preventDefault: function preventDefault() {lacuna_lazy_load("node_modules/alt/dist/alt.js[31353:31410]", functionData => eval(functionData))},
	    boundListeners: [],
	    lifecycleEvents: {},
	    actionListeners: {},
	    publicMethods: {},
	    handlesOwnErrors: false
	  }, extras);
	}

	function createStoreConfig(globalConfig, StoreModel) {
	  StoreModel.config = fn.assign({
	    getState: function getState(state) {lacuna_lazy_load("node_modules/alt/dist/alt.js[31692:31873]", functionData => eval(functionData))},
	    setState: function setState(currentState, nextState) {lacuna_lazy_load("node_modules/alt/dist/alt.js[31933:32062]", functionData => eval(functionData))}
	  }, globalConfig, StoreModel.config);
	}

	function transformStore(transforms, StoreModel) {
	  return transforms.reduce(function (Store, transform) {lacuna_lazy_load("node_modules/alt/dist/alt.js[32214:32250]", functionData => eval(functionData))}, StoreModel);
	}

	function createStoreFromObject(alt, StoreModel, key) {lacuna_lazy_load("node_modules/alt/dist/alt.js[32323:33510]", functionData => eval(functionData))}

	function createStoreFromClass(alt, StoreModel, key) {
	  var storeInstance = undefined;
	  var config = StoreModel.config;

	  // Creating a class here so we don't overload the provided store's
	  // prototype with the mixin behaviour and I'm extending from StoreModel
	  // so we can inherit any extensions from the provided store.

	  var Store = (function (_StoreModel) {
	    _inherits(Store, _StoreModel);

	    function Store() {
	      _classCallCheck(this, Store);

	      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      _get(Object.getPrototypeOf(Store.prototype), 'constructor', this).apply(this, args);
	    }

	    return Store;
	  })(StoreModel);

	  createPrototype(Store.prototype, alt, key, {
	    type: 'AltStore',
	    getInstance: function getInstance() {lacuna_lazy_load("node_modules/alt/dist/alt.js[34389:34426]", functionData => eval(functionData))},
	    setState: function setState(nextState) {lacuna_lazy_load("node_modules/alt/dist/alt.js[34472:34531]", functionData => eval(functionData))}
	  });

	  for (var _len = arguments.length, argsForClass = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
	    argsForClass[_key - 3] = arguments[_key];
	  }

	  var store = new (_bind.apply(Store, [null].concat(argsForClass)))();

	  if (config.bindListeners) store.bindListeners(config.bindListeners);
	  if (config.datasource) store.registerAsync(config.datasource);

	  storeInstance = fn.assign(new _AltStore2['default'](alt, store, store.state !== undefined ? store.state : store, StoreModel), utils.getInternalMethods(StoreModel), config.publicMethods, { displayName: key });

	  return storeInstance;
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.getInternalMethods = getInternalMethods;
	exports.warn = warn;
	exports.uid = uid;
	exports.formatAsConstant = formatAsConstant;
	exports.dispatchIdentity = dispatchIdentity;
	exports.dispatch = dispatch;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _utilsFunctions = __webpack_require__(6);

	var fn = _interopRequireWildcard(_utilsFunctions);

	/*eslint-disable*/
	var builtIns = Object.getOwnPropertyNames(NoopClass);
	var builtInProto = Object.getOwnPropertyNames(NoopClass.prototype);
	/*eslint-enable*/

	function getInternalMethods(Obj, isProto) {
	  var excluded = isProto ? builtInProto : builtIns;
	  var obj = isProto ? Obj.prototype : Obj;
	  return Object.getOwnPropertyNames(obj).reduce(function (value, m) {
	    if (excluded.indexOf(m) !== -1) {
	      return value;
	    }

	    value[m] = obj[m];
	    return value;
	  }, {});
	}

	function warn(msg) {lacuna_lazy_load("node_modules/alt/dist/alt.js[36435:36602]", functionData => eval(functionData))}

	function uid(container, name) {
	  var count = 0;
	  var key = name;
	  while (Object.hasOwnProperty.call(container, key)) {
	    key = name + String(++count);
	  }
	  return key;
	}

	function formatAsConstant(name) {
	  return name.replace(/[a-z]([A-Z])/g, function (i) {
	    return i[0] + '_' + i[1].toLowerCase();
	  }).toUpperCase();
	}

	function dispatchIdentity(x) {lacuna_lazy_load("node_modules/alt/dist/alt.js[36979:37179]", functionData => eval(functionData))}

	function dispatch(id, actionObj, payload, alt) {lacuna_lazy_load("node_modules/alt/dist/alt.js[37229:37734]", functionData => eval(functionData))}

	/* istanbul ignore next */
	function NoopClass() {lacuna_lazy_load("node_modules/alt/dist/alt.js[37786:37788]", functionData => eval(functionData))}

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _utilsFunctions = __webpack_require__(6);

	var fn = _interopRequireWildcard(_utilsFunctions);

	var _transmitter = __webpack_require__(10);

	var _transmitter2 = _interopRequireDefault(_transmitter);

	var AltStore = (function () {
	  function AltStore(alt, model, state, StoreModel) {
	    var _this = this;

	    _classCallCheck(this, AltStore);

	    var lifecycleEvents = model.lifecycleEvents;
	    this.transmitter = (0, _transmitter2['default'])();
	    this.lifecycle = function (event, x) {
	      if (lifecycleEvents[event]) lifecycleEvents[event].push(x);
	    };
	    this.state = state;

	    this.alt = alt;
	    this.preventDefault = false;
	    this.displayName = model.displayName;
	    this.boundListeners = model.boundListeners;
	    this.StoreModel = StoreModel;
	    this.reduce = model.reduce || function (x) {lacuna_lazy_load("node_modules/alt/dist/alt.js[39885:39910]", functionData => eval(functionData))};

	    var output = model.output || function (x) {lacuna_lazy_load("node_modules/alt/dist/alt.js[39960:39985]", functionData => eval(functionData))};

	    this.emitChange = function () {lacuna_lazy_load("node_modules/alt/dist/alt.js[40023:40090]", functionData => eval(functionData))};

	    var handleDispatch = function handleDispatch(f, payload) {lacuna_lazy_load("node_modules/alt/dist/alt.js[40155:40460]", functionData => eval(functionData))};

	    fn.assign(this, model.publicMethods);

	    // Register dispatcher
	    this.dispatchToken = alt.dispatcher.register(function (payload) {lacuna_lazy_load("node_modules/alt/dist/alt.js[40604:41762]", functionData => eval(functionData))});

	    this.lifecycle('init');
	  }

	  _createClass(AltStore, [{
	    key: 'listen',
	    value: function listen(cb) {lacuna_lazy_load("node_modules/alt/dist/alt.js[41882:42112]", functionData => eval(functionData))}
	  }, {
	    key: 'unlisten',
	    value: function unlisten(cb) {lacuna_lazy_load("node_modules/alt/dist/alt.js[42177:42261]", functionData => eval(functionData))}
	  }, {
	    key: 'getState',
	    value: function getState() {lacuna_lazy_load("node_modules/alt/dist/alt.js[42324:42402]", functionData => eval(functionData))}
	  }]);

	  return AltStore;
	})();

	exports['default'] = AltStore;
	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";

	function transmitter() {
	  var subscriptions = [];

	  var unsubscribe = function unsubscribe(onChange) {lacuna_lazy_load("node_modules/alt/dist/alt.js[42686:42786]", functionData => eval(functionData))};

	  var subscribe = function subscribe(onChange) {lacuna_lazy_load("node_modules/alt/dist/alt.js[42837:42997]", functionData => eval(functionData))};

	  var push = function push(value) {lacuna_lazy_load("node_modules/alt/dist/alt.js[43035:43138]", functionData => eval(functionData))};

	  return { subscribe: subscribe, push: push, unsubscribe: unsubscribe };
	}

	module.exports = transmitter;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _transmitter = __webpack_require__(10);

	var _transmitter2 = _interopRequireDefault(_transmitter);

	var _utilsFunctions = __webpack_require__(6);

	var fn = _interopRequireWildcard(_utilsFunctions);

	var StoreMixin = {
	  waitFor: function waitFor() {lacuna_lazy_load("node_modules/alt/dist/alt.js[44043:44588]", functionData => eval(functionData))},

	  exportAsync: function exportAsync(asyncMethods) {lacuna_lazy_load("node_modules/alt/dist/alt.js[44642:44687]", functionData => eval(functionData))},

	  registerAsync: function registerAsync(asyncDef) {lacuna_lazy_load("node_modules/alt/dist/alt.js[44741:47077]", functionData => eval(functionData))},

	  exportPublicMethods: function exportPublicMethods(methods) {lacuna_lazy_load("node_modules/alt/dist/alt.js[47142:47410]", functionData => eval(functionData))},

	  emitChange: function emitChange() {lacuna_lazy_load("node_modules/alt/dist/alt.js[47450:47494]", functionData => eval(functionData))},

	  on: function on(lifecycleEvent, handler) {lacuna_lazy_load("node_modules/alt/dist/alt.js[47541:47798]", functionData => eval(functionData))},

	  bindAction: function bindAction(symbol, handler) {
	    if (!symbol) {
	      throw new ReferenceError('Invalid action reference passed in');
	    }
	    if (!fn.isFunction(handler)) {
	      throw new TypeError('bindAction expects a function');
	    }

	    if (handler.length > 1) {
	      throw new TypeError('Action handler in store ' + this.displayName + ' for ' + ((symbol.id || symbol).toString() + ' was defined with ') + 'two parameters. Only a single parameter is passed through the ' + 'dispatcher, did you mean to pass in an Object instead?');
	    }

	    // You can pass in the constant or the function itself
	    var key = symbol.id ? symbol.id : symbol;
	    this.actionListeners[key] = this.actionListeners[key] || [];
	    this.actionListeners[key].push(handler.bind(this));
	    this.boundListeners.push(key);
	  },

	  bindActions: function bindActions(actions) {lacuna_lazy_load("node_modules/alt/dist/alt.js[48687:49361]", functionData => eval(functionData))},

	  bindListeners: function bindListeners(obj) {
	    var _this4 = this;

	    fn.eachObject(function (methodName, symbol) {
	      var listener = _this4[methodName];

	      if (!listener) {
	        throw new ReferenceError(methodName + ' defined but does not exist in ' + _this4.displayName);
	      }

	      if (Array.isArray(symbol)) {
	        symbol.forEach(function (action) {lacuna_lazy_load("node_modules/alt/dist/alt.js[49747:49807]", functionData => eval(functionData))});
	      } else {
	        _this4.bindAction(symbol, listener);
	      }
	    }, [obj]);
	  }
	};

	exports['default'] = StoreMixin;
	module.exports = exports['default'];

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	exports['default'] = makeAction;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _utilsFunctions = __webpack_require__(6);

	var fn = _interopRequireWildcard(_utilsFunctions);

	var _utilsAltUtils = __webpack_require__(8);

	var utils = _interopRequireWildcard(_utilsAltUtils);

	var AltAction = (function () {
	  function AltAction(alt, id, action, actions, actionDetails) {
	    _classCallCheck(this, AltAction);

	    this.id = id;
	    this._dispatch = action.bind(this);
	    this.actions = actions;
	    this.actionDetails = actionDetails;
	    this.alt = alt;
	  }

	  _createClass(AltAction, [{
	    key: 'dispatch',
	    value: function dispatch(data) {lacuna_lazy_load("node_modules/alt/dist/alt.js[51759:51859]", functionData => eval(functionData))}
	  }]);

	  return AltAction;
	})();

	function makeAction(alt, namespace, name, implementation, obj) {
	  var id = utils.uid(alt._actionsRegistry, namespace + '.' + name);
	  alt._actionsRegistry[id] = 1;

	  var data = { id: id, namespace: namespace, name: name };

	  // Wrap the action so we can provide a dispatch method
	  var newAction = new AltAction(alt, id, implementation, obj, data);

	  var dispatch = function dispatch(payload) {lacuna_lazy_load("node_modules/alt/dist/alt.js[52302:52353]", functionData => eval(functionData))};

	  // the action itself
	  var action = function action() {lacuna_lazy_load("node_modules/alt/dist/alt.js[52414:53102]", functionData => eval(functionData))};
	  action.defer = function () {lacuna_lazy_load("node_modules/alt/dist/alt.js[53134:53362]", functionData => eval(functionData))};
	  action.id = id;
	  action.data = data;

	  // ensure each reference is unique in the namespace
	  var container = alt.actions[namespace];
	  var namespaceId = utils.uid(container, name);
	  container[namespaceId] = action;

	  return action;
	}

	module.exports = exports['default'];

/***/ }
/******/ ])
});
;