// LACUNA LAZY LOAD FALLBACK
function lacuna_lazy_load(id, callback){
    fetch("http://127.0.0.1:8125/lazyload/", {
        method: "POST",
        headers: { "Accept": "application/json", "Content-Type": "application/json" },
        body: JSON.stringify({id})
    }).then(response => {
        return response.text();
    }).then(callback);
}
/**
 * JSXTransformer v0.13.3
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.JSXTransformer = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
/* jshint browser: true */
/* jslint evil: true */
/*eslint-disable no-eval */
/*eslint-disable block-scoped-var */

'use strict';

var ReactTools = _dereq_('../main');
var inlineSourceMap = _dereq_('./inline-source-map');

var headEl;
var dummyAnchor;
var inlineScriptCount = 0;

// The source-map library relies on Object.defineProperty, but IE8 doesn't
// support it fully even with es5-sham. Indeed, es5-sham's defineProperty
// throws when Object.prototype.__defineGetter__ is missing, so we skip building
// the source map in that case.
var supportsAccessors = Object.prototype.hasOwnProperty('__defineGetter__');

/**
 * Run provided code through jstransform.
 *
 * @param {string} source Original source code
 * @param {object?} options Options to pass to jstransform
 * @return {object} object as returned from jstransform
 */
function transformReact(source, options) {
  options = options || {};

  // Force the sourcemaps option manually. We don't want to use it if it will
  // break (see above note about supportsAccessors). We'll only override the
  // value here if sourceMap was specified and is truthy. This guarantees that
  // we won't override any user intent (since this method is exposed publicly).
  if (options.sourceMap) {
    options.sourceMap = supportsAccessors;
  }

  // Otherwise just pass all options straight through to react-tools.
  return ReactTools.transformWithDetails(source, options);
}

/**
 * Eval provided source after transforming it.
 *
 * @param {string} source Original source code
 * @param {object?} options Options to pass to jstransform
 */
function exec(source, options) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[2814:2870]", functionData => eval(functionData))}

/**
 * This method returns a nicely formated line of code pointing to the exact
 * location of the error `e`. The line is limited in size so big lines of code
 * are also shown in a readable way.
 *
 * Example:
 * ... x', overflow:'scroll'}} id={} onScroll={this.scroll} class=" ...
 * ^
 *
 * @param {string} code The full string of code
 * @param {Error} e The error being thrown
 * @return {string} formatted message
 * @internal
 */
function createSourceCodeErrorMessage(code, e) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[3356:4659]", functionData => eval(functionData))}

/**
 * Actually transform the code.
 *
 * @param {string} code
 * @param {string?} url
 * @param {object?} options
 * @return {string} The transformed code.
 * @internal
 */
function transformCode(code, url, options) {
  try {
    var transformed = transformReact(code, options);
  } catch(e) {
    e.message += '\n    at ';
    if (url) {
      if ('fileName' in e) {
        // We set `fileName` if it's supported by this error object and
        // a `url` was provided.
        // The error will correctly point to `url` in Firefox.
        e.fileName = url;
      }
      e.message += url + ':' + e.lineNumber + ':' + e.columnNumber;
    } else {
      e.message += location.href;
    }
    e.message += createSourceCodeErrorMessage(code, e);
    throw e;
  }

  if (!transformed.sourceMap) {
    return transformed.code;
  }

  var source;
  if (url == null) {
    source = 'Inline JSX script';
    inlineScriptCount++;
    if (inlineScriptCount > 1) {
      source += ' (' + inlineScriptCount + ')';
    }
  } else if (dummyAnchor) {
    // Firefox has problems when the sourcemap source is a proper URL with a
    // protocol and hostname, so use the pathname. We could use just the
    // filename, but hopefully using the full path will prevent potential
    // issues where the same filename exists in multiple directories.
    dummyAnchor.href = url;
    source = dummyAnchor.pathname.substr(1);
  }

  return (
    transformed.code +
    '\n' +
    inlineSourceMap(transformed.sourceMap, code, source)
  );
}


/**
 * Appends a script element at the end of the <head> with the content of code,
 * after transforming it.
 *
 * @param {string} code The original source code
 * @param {string?} url Where the code came from. null if inline
 * @param {object?} options Options to pass to jstransform
 * @internal
 */
function run(code, url, options) {
  var scriptEl = document.createElement('script');
  scriptEl.text = transformCode(code, url, options);
  headEl.appendChild(scriptEl);
}

/**
 * Load script from the provided url and pass the content to the callback.
 *
 * @param {string} url The location of the script src
 * @param {function} callback Function to call with the content of url
 * @internal
 */
function load(url, successCallback, errorCallback) {
  var xhr;
  xhr = window.ActiveXObject ? new window.ActiveXObject('Microsoft.XMLHTTP')
                             : new XMLHttpRequest();

  // async, however scripts will be executed in the order they are in the
  // DOM to mirror normal script loading.
  xhr.open('GET', url, true);
  if ('overrideMimeType' in xhr) {
    xhr.overrideMimeType('text/plain');
  }
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
      if (xhr.status === 0 || xhr.status === 200) {
        successCallback(xhr.responseText);
      } else {
        errorCallback();
        throw new Error('Could not load ' + url);
      }
    }
  };
  return xhr.send(null);
}

/**
 * Loop over provided script tags and get the content, via innerHTML if an
 * inline script, or by using XHR. Transforms are applied if needed. The scripts
 * are executed in the order they are found on the page.
 *
 * @param {array} scripts The <script> elements to load and run.
 * @internal
 */
function loadScripts(scripts) {
  var result = [];
  var count = scripts.length;

  function check() {
    var script, i;

    for (i = 0; i < count; i++) {
      script = result[i];

      if (script.loaded && !script.executed) {
        script.executed = true;
        run(script.content, script.url, script.options);
      } else if (!script.loaded && !script.error && !script.async) {
        break;
      }
    }
  }

  scripts.forEach(function(script, i) {
    var options = {
      sourceMap: true
    };
    if (/;harmony=true(;|$)/.test(script.type)) {
      options.harmony = true;
    }
    if (/;stripTypes=true(;|$)/.test(script.type)) {
      options.stripTypes = true;
    }

    // script.async is always true for non-javascript script tags
    var async = script.hasAttribute('async');

    if (script.src) {
      result[i] = {
        async: async,
        error: false,
        executed: false,
        content: null,
        loaded: false,
        url: script.src,
        options: options
      };

      load(script.src, function(content) {
        result[i].loaded = true;
        result[i].content = content;
        check();
      }, function() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[9082:9140]", functionData => eval(functionData))});
    } else {
      result[i] = {
        async: async,
        error: false,
        executed: false,
        content: script.innerHTML,
        loaded: true,
        url: null,
        options: options
      };
    }
  });

  check();
}

/**
 * Find and run all script tags with type="text/jsx".
 *
 * @internal
 */
function runScripts() {
  var scripts = document.getElementsByTagName('script');

  // Array.prototype.slice cannot be used on NodeList on IE8
  var jsxScripts = [];
  for (var i = 0; i < scripts.length; i++) {
    if (/^text\/jsx(;|$)/.test(scripts.item(i).type)) {
      jsxScripts.push(scripts.item(i));
    }
  }

  if (jsxScripts.length < 1) {
    return;
  }

  console.warn(
    'You are using the in-browser JSX transformer. Be sure to precompile ' +
    'your JSX for production - ' +
    'http://facebook.github.io/react/docs/tooling-integration.html#jsx'
  );

  loadScripts(jsxScripts);
}

// Listen for load event if we're in a browser and then kick off finding and
// running of scripts.
if (typeof window !== 'undefined' && window !== null) {
  headEl = document.getElementsByTagName('head')[0];
  dummyAnchor = document.createElement('a');

  if (window.addEventListener) {
    window.addEventListener('DOMContentLoaded', runScripts, false);
  } else {
    window.attachEvent('onload', runScripts);
  }
}

module.exports = {
  transform: transformReact,
  exec: exec
};

},{"../main":2,"./inline-source-map":41}],2:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';
/*eslint-disable no-undef*/
var visitors = _dereq_('./vendor/fbtransform/visitors');
var transform = _dereq_('jstransform').transform;
var typesSyntax = _dereq_('jstransform/visitors/type-syntax');
var inlineSourceMap = _dereq_('./vendor/inline-source-map');

module.exports = {
  transform: function(input, options) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[11260:11573]", functionData => eval(functionData))},
  transformWithDetails: function(input, options) {
    options = processOptions(options);
    var output = innerTransform(input, options);
    var result = {};
    result.code = output.code;
    if (options.sourceMap) {
      result.sourceMap = output.sourceMap.toJSON();
    }
    if (options.filename) {
      result.sourceMap.sources = [options.filename];
    }
    return result;
  }
};

/**
 * Only copy the values that we need. We'll do some preprocessing to account for
 * converting command line flags to options that jstransform can actually use.
 */
function processOptions(opts) {
  opts = opts || {};
  var options = {};

  options.harmony = opts.harmony;
  options.stripTypes = opts.stripTypes;
  options.sourceMap = opts.sourceMap;
  options.filename = opts.sourceFilename;

  if (opts.es6module) {
    options.sourceType = 'module';
  }
  if (opts.nonStrictEs6module) {
    options.sourceType = 'nonStrictModule';
  }

  // Instead of doing any fancy validation, only look for 'es3'. If we have
  // that, then use it. Otherwise use 'es5'.
  options.es3 = opts.target === 'es3';
  options.es5 = !options.es3;

  return options;
}

function innerTransform(input, options) {
  var visitorSets = ['react'];
  if (options.harmony) {
    visitorSets.push('harmony');
  }

  if (options.es3) {
    visitorSets.push('es3');
  }

  if (options.stripTypes) {
    // Stripping types needs to happen before the other transforms
    // unfortunately, due to bad interactions. For example,
    // es6-rest-param-visitors conflict with stripping rest param type
    // annotation
    input = transform(typesSyntax.visitorList, input, options).code;
  }

  var visitorList = visitors.getVisitorsBySet(visitorSets);
  return transform(visitorList, input, options);
}

},{"./vendor/fbtransform/visitors":40,"./vendor/inline-source-map":41,"jstransform":22,"jstransform/visitors/type-syntax":36}],3:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')
var isArray = _dereq_('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[15710:17629]", functionData => eval(functionData))}

function SlowBuffer (subject, encoding) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[17671:17828]", functionData => eval(functionData))}

Buffer.isBuffer = function isBuffer (b) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[17870:17911]", functionData => eval(functionData))}

Buffer.compare = function compare (a, b) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[17954:18309]", functionData => eval(functionData))}

Buffer.isEncoding = function isEncoding (encoding) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[18362:18662]", functionData => eval(functionData))}

Buffer.concat = function concat (list, totalLength) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[18716:19243]", functionData => eval(functionData))}

Buffer.byteLength = function byteLength (str, encoding) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[19301:19828]", functionData => eval(functionData))}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[20073:21028]", functionData => eval(functionData))}

Buffer.prototype.equals = function equals (b) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[21076:21224]", functionData => eval(functionData))}

Buffer.prototype.inspect = function inspect () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[21273:21496]", functionData => eval(functionData))}

Buffer.prototype.compare = function compare (b) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[21546:21685]", functionData => eval(functionData))}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[21749:23088]", functionData => eval(functionData))}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[23174:23284]", functionData => eval(functionData))}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[23373:23487]", functionData => eval(functionData))}

function hexWrite (buf, string, offset, length) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[23537:24138]", functionData => eval(functionData))}

function utf8Write (buf, string, offset, length) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[24189:24309]", functionData => eval(functionData))}

function asciiWrite (buf, string, offset, length) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[24361:24461]", functionData => eval(functionData))}

function binaryWrite (buf, string, offset, length) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[24514:24566]", functionData => eval(functionData))}

function base64Write (buf, string, offset, length) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[24619:24720]", functionData => eval(functionData))}

function utf16leWrite (buf, string, offset, length) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[24774:24897]", functionData => eval(functionData))}

Buffer.prototype.write = function write (string, offset, length, encoding) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[24974:26401]", functionData => eval(functionData))}

Buffer.prototype.toJSON = function toJSON () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[26448:26545]", functionData => eval(functionData))}

function base64Slice (buf, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[26586:26739]", functionData => eval(functionData))}

function utf8Slice (buf, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[26778:27086]", functionData => eval(functionData))}

function asciiSlice (buf, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[27126:27280]", functionData => eval(functionData))}

function binarySlice (buf, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[27321:27468]", functionData => eval(functionData))}

function hexSlice (buf, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[27506:27712]", functionData => eval(functionData))}

function utf16leSlice (buf, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[27754:27933]", functionData => eval(functionData))}

Buffer.prototype.slice = function slice (start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[27988:28674]", functionData => eval(functionData))}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[28796:28973]", functionData => eval(functionData))}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[29056:29328]", functionData => eval(functionData))}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[29411:29705]", functionData => eval(functionData))}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[29774:29852]", functionData => eval(functionData))}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[29927:30031]", functionData => eval(functionData))}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[30106:30210]", functionData => eval(functionData))}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[30285:30472]", functionData => eval(functionData))}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[30547:30726]", functionData => eval(functionData))}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[30807:31147]", functionData => eval(functionData))}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[31228:31574]", functionData => eval(functionData))}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[31641:31791]", functionData => eval(functionData))}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[31864:32020]", functionData => eval(functionData))}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[32093:32249]", functionData => eval(functionData))}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[32322:32495]", functionData => eval(functionData))}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[32568:32741]", functionData => eval(functionData))}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[32814:32919]", functionData => eval(functionData))}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[32992:33098]", functionData => eval(functionData))}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[33173:33278]", functionData => eval(functionData))}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[33353:33459]", functionData => eval(functionData))}

function checkInt (buf, value, offset, ext, max, min) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[33515:33760]", functionData => eval(functionData))}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[33852:34207]", functionData => eval(functionData))}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[34299:34663]", functionData => eval(functionData))}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[34741:34948]", functionData => eval(functionData))}

function objectWriteUInt16 (buf, value, offset, littleEndian) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[35012:35249]", functionData => eval(functionData))}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[35333:35620]", functionData => eval(functionData))}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[35704:35992]", functionData => eval(functionData))}

function objectWriteUInt32 (buf, value, offset, littleEndian) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[36056:36253]", functionData => eval(functionData))}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[36337:36704]", functionData => eval(functionData))}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[36788:37156]", functionData => eval(functionData))}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[37246:37679]", functionData => eval(functionData))}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[37769:38211]", functionData => eval(functionData))}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[38287:38540]", functionData => eval(functionData))}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[38622:38915]", functionData => eval(functionData))}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[38997:39291]", functionData => eval(functionData))}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[39373:39750]", functionData => eval(functionData))}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[39832:40258]", functionData => eval(functionData))}

function checkIEEE754 (buf, value, offset, ext, max, min) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[40318:40539]", functionData => eval(functionData))}

function writeFloat (buf, value, offset, littleEndian, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[40606:40798]", functionData => eval(functionData))}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[40880:40940]", functionData => eval(functionData))}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[41022:41083]", functionData => eval(functionData))}

function writeDouble (buf, value, offset, littleEndian, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[41151:41345]", functionData => eval(functionData))}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[41429:41490]", functionData => eval(functionData))}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[41574:41636]", functionData => eval(functionData))}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, target_start, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[41788:42815]", functionData => eval(functionData))}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[42918:43594]", functionData => eval(functionData))}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[43819:44214]", functionData => eval(functionData))}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[44417:46264]", functionData => eval(functionData))}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[46336:46726]", functionData => eval(functionData))}

function stringtrim (str) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[46754:46830]", functionData => eval(functionData))}

function isArrayish (subject) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[46862:47011]", functionData => eval(functionData))}

function toHex (n) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[47032:47101]", functionData => eval(functionData))}

function utf8ToBytes (string, units) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[47140:49251]", functionData => eval(functionData))}

function asciiToBytes (str) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[49281:49473]", functionData => eval(functionData))}

function utf16leToBytes (str, units) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[49512:49755]", functionData => eval(functionData))}

function base64ToBytes (str) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[49786:49835]", functionData => eval(functionData))}

function blitBuffer (src, dst, offset, length) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[49884:50031]", functionData => eval(functionData))}

function decodeUtf8Char (str) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[50063:50192]", functionData => eval(functionData))}

},{"base64-js":4,"ieee754":5,"is-array":6}],4:[function(_dereq_,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[50737:51126]", functionData => eval(functionData))}

	function b64ToByteArray (b64) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[51159:52590]", functionData => eval(functionData))}

	function uint8ToBase64 (uint8) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[52624:53702]", functionData => eval(functionData))}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],5:[function(_dereq_,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[53953:54694]", functionData => eval(functionData))};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[54765:55984]", functionData => eval(functionData))};

},{}],6:[function(_dereq_,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[56441:56498]", functionData => eval(functionData))};

},{}],7:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[56542:62786]", functionData => eval(functionData))},{"_process":8}],8:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[62838:64087]", functionData => eval(functionData))},{}],9:[function(_dereq_,module,exports){
/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        SyntaxTreeDelegate,
        XHTMLEntities,
        ClassPropertyType,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        delegate,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10,
        JSXIdentifier: 11,
        JSXText: 12
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.JSXIdentifier] = 'JSXIdentifier';
    TokenName[Token.JSXText] = 'JSXText';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AnyTypeAnnotation: 'AnyTypeAnnotation',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrayTypeAnnotation: 'ArrayTypeAnnotation',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AssignmentExpression: 'AssignmentExpression',
        BinaryExpression: 'BinaryExpression',
        BlockStatement: 'BlockStatement',
        BooleanTypeAnnotation: 'BooleanTypeAnnotation',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ClassImplements: 'ClassImplements',
        ClassProperty: 'ClassProperty',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DeclareClass: 'DeclareClass',
        DeclareFunction: 'DeclareFunction',
        DeclareModule: 'DeclareModule',
        DeclareVariable: 'DeclareVariable',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportDeclaration: 'ExportDeclaration',
        ExportBatchSpecifier: 'ExportBatchSpecifier',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        ForStatement: 'ForStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        FunctionTypeAnnotation: 'FunctionTypeAnnotation',
        FunctionTypeParam: 'FunctionTypeParam',
        GenericTypeAnnotation: 'GenericTypeAnnotation',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        InterfaceDeclaration: 'InterfaceDeclaration',
        InterfaceExtends: 'InterfaceExtends',
        IntersectionTypeAnnotation: 'IntersectionTypeAnnotation',
        LabeledStatement: 'LabeledStatement',
        Literal: 'Literal',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        NullableTypeAnnotation: 'NullableTypeAnnotation',
        NumberTypeAnnotation: 'NumberTypeAnnotation',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        ObjectTypeAnnotation: 'ObjectTypeAnnotation',
        ObjectTypeCallProperty: 'ObjectTypeCallProperty',
        ObjectTypeIndexer: 'ObjectTypeIndexer',
        ObjectTypeProperty: 'ObjectTypeProperty',
        Program: 'Program',
        Property: 'Property',
        QualifiedTypeIdentifier: 'QualifiedTypeIdentifier',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        SpreadProperty: 'SpreadProperty',
        StringLiteralTypeAnnotation: 'StringLiteralTypeAnnotation',
        StringTypeAnnotation: 'StringTypeAnnotation',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TupleTypeAnnotation: 'TupleTypeAnnotation',
        TryStatement: 'TryStatement',
        TypeAlias: 'TypeAlias',
        TypeAnnotation: 'TypeAnnotation',
        TypeCastExpression: 'TypeCastExpression',
        TypeofTypeAnnotation: 'TypeofTypeAnnotation',
        TypeParameterDeclaration: 'TypeParameterDeclaration',
        TypeParameterInstantiation: 'TypeParameterInstantiation',
        UnaryExpression: 'UnaryExpression',
        UnionTypeAnnotation: 'UnionTypeAnnotation',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        VoidTypeAnnotation: 'VoidTypeAnnotation',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        JSXIdentifier: 'JSXIdentifier',
        JSXNamespacedName: 'JSXNamespacedName',
        JSXMemberExpression: 'JSXMemberExpression',
        JSXEmptyExpression: 'JSXEmptyExpression',
        JSXExpressionContainer: 'JSXExpressionContainer',
        JSXElement: 'JSXElement',
        JSXClosingElement: 'JSXClosingElement',
        JSXOpeningElement: 'JSXOpeningElement',
        JSXAttribute: 'JSXAttribute',
        JSXSpreadAttribute: 'JSXSpreadAttribute',
        JSXText: 'JSXText',
        YieldExpression: 'YieldExpression',
        AwaitExpression: 'AwaitExpression'
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    ClassPropertyType = {
        'static': 'static',
        prototype: 'prototype'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInFormalsList: 'Invalid left-hand side in formals list',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',
        IllegalClassConstructorProperty: 'Illegal constructor property in class definition',
        IllegalReturn: 'Illegal return statement',
        IllegalSpread: 'Illegal spread element',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',
        DefaultRestParameter: 'Rest parameter can not have a default value',
        ElementAfterSpreadElement: 'Spread must be the final element of an element list',
        PropertyAfterSpreadProperty: 'A rest property must be the final property of an object literal',
        ObjectPatternAsRestParameter: 'Invalid rest parameter',
        ObjectPatternAsSpread: 'Invalid spread argument',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        MissingFromClause: 'Missing from clause',
        NoAsAfterImportNamespace: 'Missing as after import *',
        InvalidModuleSpecifier: 'Invalid module specifier',
        IllegalImportDeclaration: 'Illegal import declaration',
        IllegalExportDeclaration: 'Illegal export declaration',
        NoUninitializedConst: 'Const must be initialized',
        ComprehensionRequiresBlock: 'Comprehension must have at least one block',
        ComprehensionError: 'Comprehension Error',
        EachNotAllowed: 'Each is not supported',
        InvalidJSXAttributeValue: 'JSX value should be either an expression or a quoted JSX text',
        ExpectedJSXClosingTag: 'Expected corresponding JSX closing tag for %0',
        AdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag',
        ConfusedAboutFunctionType: 'Unexpected token =>. It looks like ' +
            'you are trying to write a function type, but you ended up ' +
            'writing a grouped type followed by an =>, which is a syntax ' +
            'error. Remember, function type parameters are named so function ' +
            'types look like (name1: type1, name2: type2) => returnType. You ' +
            'probably wrote (type1) => returnType'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        LeadingZeros: new RegExp('^0+(?!$)')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function StringMap() {
        this.$data = {};
    }

    StringMap.prototype.get = function (key) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[88156:88220]", functionData => eval(functionData))};

    StringMap.prototype.set = function (key, value) {
        key = '$' + key;
        this.$data[key] = value;
        return this;
    };

    StringMap.prototype.has = function (key) {
        key = '$' + key;
        return Object.prototype.hasOwnProperty.call(this.$data, key);
    };

    StringMap.prototype["delete"] = function (key) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[88565:88636]", functionData => eval(functionData))};

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[88757:88822]", functionData => eval(functionData))}

    function isOctalDigit(ch) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[88854:88905]", functionData => eval(functionData))}


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 32) ||  // space
            (ch === 9) ||      // tab
            (ch === 0xB) ||
            (ch === 0xC) ||
            (ch === 0xA0) ||
            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[90403:90645]", functionData => eval(functionData))}

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' is only treated as a keyword in strict mode.
        // 'let' is for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;
        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment() {
        var start, loc, ch, comment;

        start = index - 2;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - 2
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + 2, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + 2, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 13 && source.charCodeAt(index + 1) === 10) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else if (ch === 42) {
                // Block comment ends with '*/' (char #42, char #47).
                if (source.charCodeAt(index + 1) === 47) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function skipComment() {
        var ch;

        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else if (ch === 47) { // 47 is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 47) {
                    ++index;
                    ++index;
                    skipSingleLineComment();
                } else if (ch === 42) {  // 42 is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[97375:97789]", functionData => eval(functionData))}

    function scanUnicodeCodePointEscape() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[97833:98676]", functionData => eval(functionData))}

    function getEscapedIdentifier() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[98714:100126]", functionData => eval(functionData))}

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 92) {
                // Blackslash (char #92) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (char #92) starts an escaped character.
        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        if (state.inJSXTag || state.inJSXChild) {
            // Don't need to check for '{' and '}' as it's already handled
            // correctly by default.
            switch (code) {
            case 60:  // <
            case 62:  // >
                ++index;
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        switch (code) {
        // Check for most common single-character punctuators.
        case 40:   // ( open bracket
        case 41:   // ) close bracket
        case 59:   // ; semicolon
        case 44:   // , comma
        case 123:  // { open curly brace
        case 125:  // } close curly brace
        case 91:   // [
        case 93:   // ]
        case 58:   // :
        case 63:   // ?
        case 126:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 40) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 123) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (char #61) marks an assignment or comparison operator.
            if (code2 === 61) {
                switch (code) {
                case 37:  // %
                case 38:  // &
                case 42:  // *:
                case 43:  // +
                case 45:  // -
                case 47:  // /
                case 60:  // <
                case 62:  // >
                case 94:  // ^
                case 124: // |
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };

                case 33: // !
                case 61: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 61) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                default:
                    break;
                }
            }
            break;
        }

        // Peek more characters.

        ch2 = source[index + 1];
        ch3 = source[index + 2];
        ch4 = source[index + 3];

        // 4-character punctuator: >>>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            if (ch4 === '=') {
                index += 4;
                return {
                    type: Token.Punctuator,
                    value: '>>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // 3-character punctuators: === !== >>> <<= >>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>' && !state.inType) {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '<<=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '...',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||

        // Don't match these tokens if we're in a type, since they never can
        // occur and can mess up types like Map<string, Array<string>>
        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0) && !state.inType) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch1 + ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '=' && ch2 === '>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: '=>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '.') {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[108316:108981]", functionData => eval(functionData))}

    function scanBinaryLiteral(start) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[109021:109892]", functionData => eval(functionData))}

    function scanOctalLiteral(prefix, start) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[109939:110916]", functionData => eval(functionData))}

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {
                    return scanOctalLiteral(ch, start);
                }
                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                        }
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            /* istanbul ignore else */
                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanTemplate() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[117420:121790]", functionData => eval(functionData))}

    function scanTemplateElement(option) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[121833:122172]", functionData => eval(functionData))}

    function testRegExp(pattern, flags) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[122214:123712]", functionData => eval(functionData))}

    function scanRegExpBody() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[123744:125128]", functionData => eval(functionData))}

    function scanRegExpFlags() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[125161:126458]", functionData => eval(functionData))}

    function scanRegExp() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[126486:127369]", functionData => eval(functionData))}

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[127636:130138]", functionData => eval(functionData))}

    function advance() {
        var ch;

        if (!state.inJSXChild) {
            skipComment();
        }

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [index, index]
            };
        }

        if (state.inJSXChild) {
            return advanceJSXChild();
        }

        ch = source.charCodeAt(index);

        // Very common: ( and ) and ;
        if (ch === 40 || ch === 41 || ch === 58) {
            return scanPunctuator();
        }

        // String literal starts with single quote (#39) or double quote (#34).
        if (ch === 39 || ch === 34) {
            if (state.inJSXTag) {
                return scanJSXStringLiteral();
            }
            return scanStringLiteral();
        }

        if (state.inJSXTag && isJSXIdentifierStart(ch)) {
            return scanJSXIdentifier();
        }

        if (ch === 96) {
            return scanTemplate();
        }
        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Dot (.) char #46 can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) char #47 can also start a regex.
        if (extra.tokenize && ch === 47) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = advance();

        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    function lookahead2() {
        var adv, pos, line, start, result;

        // If we are collecting the tokens, don't grab the next one yet.
        /* istanbul ignore next */
        adv = (typeof extra.advance === 'function') ? extra.advance : advance;

        pos = index;
        line = lineNumber;
        start = lineStart;

        // Scan for the next immediate token.
        /* istanbul ignore if */
        if (lookahead === null) {
            lookahead = adv();
        }
        index = lookahead.range[1];
        lineNumber = lookahead.lineNumber;
        lineStart = lookahead.lineStart;

        // Grab the token right after.
        result = adv();
        index = pos;
        lineNumber = line;
        lineStart = start;

        return result;
    }

    function rewind(token) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[133249:133391]", functionData => eval(functionData))}

    function markerCreate() {
        if (!extra.loc && !extra.range) {
            return undefined;
        }
        skipComment();
        return {offset: index, line: lineNumber, col: index - lineStart};
    }

    function markerCreatePreserveWhitespace() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[133655:133818]", functionData => eval(functionData))}

    function processComment(node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[133854:135634]", functionData => eval(functionData))}

    function markerApply(marker, node) {
        if (extra.range) {
            node.range = [marker.offset, index];
        }
        if (extra.loc) {
            node.loc = {
                start: {
                    line: marker.line,
                    column: marker.col
                },
                end: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
            node = delegate.postProcess(node);
        }
        if (extra.attachComment) {
            processComment(node);
        }
        return node;
    }

    SyntaxTreeDelegate = {

        name: 'SyntaxTree',

        postProcess: function (node) {
            return node;
        },

        createArrayExpression: function (elements) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[136423:136551]", functionData => eval(functionData))},

        createAssignmentExpression: function (operator, left, right) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[136623:136814]", functionData => eval(functionData))},

        createBinaryExpression: function (operator, left, right) {
            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
                        Syntax.BinaryExpression;
            return {
                type: type,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBlockStatement: function (body) {
            return {
                type: Syntax.BlockStatement,
                body: body
            };
        },

        createBreakStatement: function (label) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[137410:137531]", functionData => eval(functionData))},

        createCallExpression: function (callee, args) {
            return {
                type: Syntax.CallExpression,
                callee: callee,
                'arguments': args
            };
        },

        createCatchClause: function (param, body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[137799:137945]", functionData => eval(functionData))},

        createConditionalExpression: function (test, consequent, alternate) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[138024:138228]", functionData => eval(functionData))},

        createContinueStatement: function (label) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[138281:138405]", functionData => eval(functionData))},

        createDebuggerStatement: function () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[138453:138547]", functionData => eval(functionData))},

        createDoWhileStatement: function (body, test) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[138604:138753]", functionData => eval(functionData))},

        createEmptyStatement: function () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[138798:138889]", functionData => eval(functionData))},

        createExpressionStatement: function (expression) {
            return {
                type: Syntax.ExpressionStatement,
                expression: expression
            };
        },

        createForStatement: function (init, test, update, body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[139152:139357]", functionData => eval(functionData))},

        createForInStatement: function (left, right, body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[139419:139625]", functionData => eval(functionData))},

        createForOfStatement: function (left, right, body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[139687:139864]", functionData => eval(functionData))},

        createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression,
                                             isAsync, returnType, typeParameters) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[140051:140577]", functionData => eval(functionData))},

        createFunctionExpression: function (id, params, defaults, body, rest, generator, expression,
                                            isAsync, returnType, typeParameters) {
            var funExpr = {
                type: Syntax.FunctionExpression,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: rest,
                generator: generator,
                expression: expression,
                returnType: returnType,
                typeParameters: typeParameters
            };

            if (isAsync) {
                funExpr.async = true;
            }

            return funExpr;
        },

        createIdentifier: function (name) {
            return {
                type: Syntax.Identifier,
                name: name,
                // Only here to initialize the shape of the object to ensure
                // that the 'typeAnnotation' key is ordered before others that
                // are added later (like 'loc' and 'range'). This just helps
                // keep the shape of Identifier nodes consistent with everything
                // else.
                typeAnnotation: undefined,
                optional: undefined
            };
        },

        createTypeAnnotation: function (typeAnnotation) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[141925:142064]", functionData => eval(functionData))},

        createTypeCast: function (expression, typeAnnotation) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[142129:142312]", functionData => eval(functionData))},

        createFunctionTypeAnnotation: function (params, returnType, rest, typeParameters) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[142405:142652]", functionData => eval(functionData))},

        createFunctionTypeParam: function (name, typeAnnotation, optional) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[142730:142936]", functionData => eval(functionData))},

        createNullableTypeAnnotation: function (typeAnnotation) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[143003:143150]", functionData => eval(functionData))},

        createArrayTypeAnnotation: function (elementType) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[143211:143349]", functionData => eval(functionData))},

        createGenericTypeAnnotation: function (id, typeParameters) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[143419:143589]", functionData => eval(functionData))},

        createQualifiedTypeIdentifier: function (qualification, id) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[143660:143830]", functionData => eval(functionData))},

        createTypeParameterDeclaration: function (params) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[143891:144024]", functionData => eval(functionData))},

        createTypeParameterInstantiation: function (params) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[144087:144222]", functionData => eval(functionData))},

        createAnyTypeAnnotation: function () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[144270:144364]", functionData => eval(functionData))},

        createBooleanTypeAnnotation: function () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[144416:144514]", functionData => eval(functionData))},

        createNumberTypeAnnotation: function () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[144565:144662]", functionData => eval(functionData))},

        createStringTypeAnnotation: function () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[144713:144810]", functionData => eval(functionData))},

        createStringLiteralTypeAnnotation: function (token) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[144873:145080]", functionData => eval(functionData))},

        createVoidTypeAnnotation: function () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[145129:145224]", functionData => eval(functionData))},

        createTypeofTypeAnnotation: function (argument) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[145283:145416]", functionData => eval(functionData))},

        createTupleTypeAnnotation: function (types) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[145471:145597]", functionData => eval(functionData))},

        createObjectTypeAnnotation: function (properties, indexers, callProperties) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[145684:145905]", functionData => eval(functionData))},

        createObjectTypeIndexer: function (id, key, value, isStatic) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[145977:146187]", functionData => eval(functionData))},

        createObjectTypeCallProperty: function (value, isStatic) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[146255:146420]", functionData => eval(functionData))},

        createObjectTypeProperty: function (key, value, optional, isStatic) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[146499:146722]", functionData => eval(functionData))},

        createUnionTypeAnnotation: function (types) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[146777:146903]", functionData => eval(functionData))},

        createIntersectionTypeAnnotation: function (types) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[146965:147098]", functionData => eval(functionData))},

        createTypeAlias: function (id, typeParameters, right) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[147163:147351]", functionData => eval(functionData))},

        createInterface: function (id, typeParameters, body, extended) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[147425:147659]", functionData => eval(functionData))},

        createInterfaceExtends: function (id, typeParameters) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[147724:147889]", functionData => eval(functionData))},

        createDeclareFunction: function (id) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[147937:148053]", functionData => eval(functionData))},

        createDeclareVariable: function (id) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[148101:148217]", functionData => eval(functionData))},

        createDeclareModule: function (id, body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[148269:148411]", functionData => eval(functionData))},

        createJSXAttribute: function (name, value) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[148465:148620]", functionData => eval(functionData))},

        createJSXSpreadAttribute: function (argument) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[148677:148808]", functionData => eval(functionData))},

        createJSXIdentifier: function (name) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[148856:148974]", functionData => eval(functionData))},

        createJSXNamespacedName: function (namespace, name) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[149037:149197]", functionData => eval(functionData))},

        createJSXMemberExpression: function (object, property) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[149263:149427]", functionData => eval(functionData))},

        createJSXElement: function (openingElement, closingElement, children) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[149508:149727]", functionData => eval(functionData))},

        createJSXEmptyExpression: function () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[149776:149871]", functionData => eval(functionData))},

        createJSXExpressionContainer: function (expression) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[149934:150073]", functionData => eval(functionData))},

        createJSXOpeningElement: function (name, attributes, selfClosing) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[150150:150354]", functionData => eval(functionData))},

        createJSXClosingElement: function (name) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[150406:150528]", functionData => eval(functionData))},

        createIfStatement: function (test, consequent, alternate) {
            return {
                type: Syntax.IfStatement,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createLabeledStatement: function (label, body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[150849:151000]", functionData => eval(functionData))},

        createLiteral: function (token) {
            var object = {
                type: Syntax.Literal,
                value: token.value,
                raw: source.slice(token.range[0], token.range[1])
            };
            if (token.regex) {
                object.regex = token.regex;
            }
            return object;
        },

        createMemberExpression: function (accessor, object, property) {
            return {
                type: Syntax.MemberExpression,
                computed: accessor === '[',
                object: object,
                property: property
            };
        },

        createNewExpression: function (callee, args) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[151686:151843]", functionData => eval(functionData))},

        createObjectExpression: function (properties) {
            return {
                type: Syntax.ObjectExpression,
                properties: properties
            };
        },

        createPostfixExpression: function (operator, argument) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[152099:152295]", functionData => eval(functionData))},

        createProgram: function (body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[152337:152449]", functionData => eval(functionData))},

        createProperty: function (kind, key, value, method, shorthand, computed) {
            return {
                type: Syntax.Property,
                key: key,
                value: value,
                kind: kind,
                method: method,
                shorthand: shorthand,
                computed: computed
            };
        },

        createReturnStatement: function (argument) {
            return {
                type: Syntax.ReturnStatement,
                argument: argument
            };
        },

        createSequenceExpression: function (expressions) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[153050:153187]", functionData => eval(functionData))},

        createSwitchCase: function (test, consequent) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[153244:153399]", functionData => eval(functionData))},

        createSwitchStatement: function (discriminant, cases) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[153464:153630]", functionData => eval(functionData))},

        createThisExpression: function () {
            return {
                type: Syntax.ThisExpression
            };
        },

        createThrowStatement: function (argument) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[153819:153946]", functionData => eval(functionData))},

        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[154032:154275]", functionData => eval(functionData))},

        createUnaryExpression: function (operator, argument) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[154339:154813]", functionData => eval(functionData))},

        createVariableDeclaration: function (declarations, kind) {
            return {
                type: Syntax.VariableDeclaration,
                declarations: declarations,
                kind: kind
            };
        },

        createVariableDeclarator: function (id, init) {
            return {
                type: Syntax.VariableDeclarator,
                id: id,
                init: init
            };
        },

        createWhileStatement: function (test, body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[155308:155455]", functionData => eval(functionData))},

        createWithStatement: function (object, body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[155511:155661]", functionData => eval(functionData))},

        createTemplateElement: function (value, tail) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[155718:155868]", functionData => eval(functionData))},

        createTemplateLiteral: function (quasis, expressions) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[155933:156099]", functionData => eval(functionData))},

        createSpreadElement: function (argument) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[156151:156277]", functionData => eval(functionData))},

        createSpreadProperty: function (argument) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[156330:156457]", functionData => eval(functionData))},

        createTaggedTemplateExpression: function (tag, quasi) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[156522:156679]", functionData => eval(functionData))},

        createArrowFunctionExpression: function (params, defaults, body, rest, expression, isAsync) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[156782:157228]", functionData => eval(functionData))},

        createMethodDefinition: function (propertyType, kind, key, value, computed) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[157315:157600]", functionData => eval(functionData))},

        createClassProperty: function (key, typeAnnotation, computed, isStatic) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[157683:157919]", functionData => eval(functionData))},

        createClassBody: function (body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[157963:158077]", functionData => eval(functionData))},

        createClassImplements: function (id, typeParameters) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[158141:158305]", functionData => eval(functionData))},

        createClassExpression: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[158421:158754]", functionData => eval(functionData))},

        createClassDeclaration: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[158871:159205]", functionData => eval(functionData))},

        createModuleSpecifier: function (token) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[159256:159451]", functionData => eval(functionData))},

        createExportSpecifier: function (id, name) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[159505:159649]", functionData => eval(functionData))},

        createExportBatchSpecifier: function () {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[159700:159797]", functionData => eval(functionData))},

        createImportDefaultSpecifier: function (id) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[159852:159975]", functionData => eval(functionData))},

        createImportNamespaceSpecifier: function (id) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[160032:160157]", functionData => eval(functionData))},

        createExportDeclaration: function (isDefault, declaration, specifiers, src) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[160244:160489]", functionData => eval(functionData))},

        createImportSpecifier: function (id, name) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[160543:160687]", functionData => eval(functionData))},

        createImportDeclaration: function (specifiers, src, isType) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[160758:160953]", functionData => eval(functionData))},

        createYieldExpression: function (argument, dlg) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[161012:161171]", functionData => eval(functionData))},

        createAwaitExpression: function (argument) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[161225:161353]", functionData => eval(functionData))},

        createComprehensionExpression: function (filter, blocks, body) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[161427:161619]", functionData => eval(functionData))}

    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[162089:162988]", functionData => eval(functionData))}

    function throwErrorTolerant() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[163024:163254]", functionData => eval(functionData))}


    // Throw an exception because of the token.

    function throwUnexpected(token) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[163342:164526]", functionData => eval(functionData))}

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword, contextual) {
        var token = lex();
        if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||
                token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified contextual keyword.
    // If not, an exception will be thrown.

    function expectContextualKeyword(keyword) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[165338:165390]", functionData => eval(functionData))}

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword, contextual) {
        var expectedType = contextual ? Token.Identifier : Token.Keyword;
        return lookahead.type === expectedType && lookahead.value === keyword;
    }

    // Return true if the next token matches the specified contextual keyword

    function matchContextualKeyword(keyword) {
        return matchKeyword(keyword, true);
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    // Note that 'yield' is treated as a keyword in strict mode, but a
    // contextual keyword (identifier) in non-strict mode, so we need to
    // use matchKeyword('yield', false) and matchKeyword('yield', true)
    // (i.e. matchContextualKeyword) appropriately.
    function matchYield() {
        return state.yieldAllowed && matchKeyword('yield', !strict);
    }

    function matchAsync() {
        var backtrackToken = lookahead, matches = false;

        if (matchContextualKeyword('async')) {
            lex(); // Make sure peekLineTerminator() starts after 'async'.
            matches = !peekLineTerminator();
            rewind(backtrackToken); // Revert the lex().
        }

        return matches;
    }

    function matchAwait() {
        return state.awaitAllowed && matchContextualKeyword('await');
    }

    function consumeSemicolon() {
        var line, oldIndex = index, oldLineNumber = lineNumber,
            oldLineStart = lineStart, oldLookahead = lookahead;

        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            index = oldIndex;
            lineNumber = oldLineNumber;
            lineStart = oldLineStart;
            lookahead = oldLookahead;
            return;
        }

        if (match(';')) {
            lex();
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    function isAssignableLeftHandSide(expr) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[168465:168584]", functionData => eval(functionData))}

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[168656:171119]", functionData => eval(functionData))}

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(options) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[171199:172345]", functionData => eval(functionData))}


    function parsePropertyMethodFunction(options) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[172398:173006]", functionData => eval(functionData))}


    function parseObjectPropertyKey() {
        var marker = markerCreate(),
            token = lex(),
            propertyKey,
            result;

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return markerApply(marker, delegate.createLiteral(token));
        }

        if (token.type === Token.Punctuator && token.value === '[') {
            // For computed properties we should skip the [ and ], and
            // capture in marker only the assignment expression itself.
            marker = markerCreate();
            propertyKey = parseAssignmentExpression();
            result = markerApply(marker, propertyKey);
            expect(']');
            return result;
        }

        return markerApply(marker, delegate.createIdentifier(token.value));
    }

    function parseObjectProperty() {
        var token, key, id, param, computed,
            marker = markerCreate(), returnType, typeParameters;

        token = lookahead;
        computed = (token.value === '[' && token.type === Token.Punctuator);

        if (token.type === Token.Identifier || computed || matchAsync()) {
            id = parseObjectPropertyKey();

            if (match(':')) {
                lex();

                return markerApply(
                    marker,
                    delegate.createProperty(
                        'init',
                        id,
                        parseAssignmentExpression(),
                        false,
                        false,
                        computed
                    )
                );
            }

            if (match('(') || match('<')) {
                if (match('<')) {
                    typeParameters = parseTypeParameterDeclaration();
                }
                return markerApply(
                    marker,
                    delegate.createProperty(
                        'init',
                        id,
                        parsePropertyMethodFunction({
                            generator: false,
                            async: false,
                            typeParameters: typeParameters
                        }),
                        true,
                        false,
                        computed
                    )
                );
            }

            // Property Assignment: Getter and Setter.

            if (token.value === 'get') {
                computed = (lookahead.value === '[');
                key = parseObjectPropertyKey();

                expect('(');
                expect(')');
                if (match(':')) {
                    returnType = parseTypeAnnotation();
                }

                return markerApply(
                    marker,
                    delegate.createProperty(
                        'get',
                        key,
                        parsePropertyFunction({
                            generator: false,
                            async: false,
                            returnType: returnType
                        }),
                        false,
                        false,
                        computed
                    )
                );
            }

            if (token.value === 'set') {
                computed = (lookahead.value === '[');
                key = parseObjectPropertyKey();

                expect('(');
                token = lookahead;
                param = [ parseTypeAnnotatableIdentifier() ];
                expect(')');
                if (match(':')) {
                    returnType = parseTypeAnnotation();
                }

                return markerApply(
                    marker,
                    delegate.createProperty(
                        'set',
                        key,
                        parsePropertyFunction({
                            params: param,
                            generator: false,
                            async: false,
                            name: token,
                            returnType: returnType
                        }),
                        false,
                        false,
                        computed
                    )
                );
            }

            if (token.value === 'async') {
                computed = (lookahead.value === '[');
                key = parseObjectPropertyKey();

                if (match('<')) {
                    typeParameters = parseTypeParameterDeclaration();
                }

                return markerApply(
                    marker,
                    delegate.createProperty(
                        'init',
                        key,
                        parsePropertyMethodFunction({
                            generator: false,
                            async: true,
                            typeParameters: typeParameters
                        }),
                        true,
                        false,
                        computed
                    )
                );
            }

            if (computed) {
                // Computed properties can only be used with full notation.
                throwUnexpected(lookahead);
            }

            return markerApply(
                marker,
                delegate.createProperty('init', id, id, false, true, false)
            );
        }

        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            if (!match('*')) {
                throwUnexpected(token);
            }
            lex();

            computed = (lookahead.type === Token.Punctuator && lookahead.value === '[');

            id = parseObjectPropertyKey();

            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }

            if (!match('(')) {
                throwUnexpected(lex());
            }

            return markerApply(marker, delegate.createProperty(
                'init',
                id,
                parsePropertyMethodFunction({
                    generator: true,
                    typeParameters: typeParameters
                }),
                true,
                false,
                computed
            ));
        }
        key = parseObjectPropertyKey();
        if (match(':')) {
            lex();
            return markerApply(marker, delegate.createProperty('init', key, parseAssignmentExpression(), false, false, false));
        }
        if (match('(') || match('<')) {
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
            return markerApply(marker, delegate.createProperty(
                'init',
                key,
                parsePropertyMethodFunction({
                    generator: false,
                    typeParameters: typeParameters
                }),
                true,
                false,
                false
            ));
        }
        throwUnexpected(lex());
    }

    function parseObjectSpreadProperty() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[180366:180529]", functionData => eval(functionData))}

    function getFieldName(key) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[180562:180721]", functionData => eval(functionData))}

    function parseObjectInitialiser() {
        var properties = [], property, name, kind, storedKind, map = new StringMap(),
            marker = markerCreate(), toString = String;

        expect('{');

        while (!match('}')) {
            if (match('...')) {
                property = parseObjectSpreadProperty();
            } else {
                property = parseObjectProperty();

                if (property.key.type === Syntax.Identifier) {
                    name = property.key.name;
                } else {
                    name = toString(property.key.value);
                }
                kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

                if (map.has(name)) {
                    storedKind = map.get(name);
                    if (storedKind === PropertyKind.Data) {
                        if (strict && kind === PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                        } else if (kind !== PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.AccessorDataProperty);
                        }
                    } else {
                        if (kind === PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.AccessorDataProperty);
                        } else if (storedKind & kind) {
                            throwErrorTolerant({}, Messages.AccessorGetSet);
                        }
                    }
                    map.set(name, storedKind | kind);
                } else {
                    map.set(name, kind);
                }
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return markerApply(marker, delegate.createObjectExpression(properties));
    }

    function parseTemplateElement(option) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[182719:183053]", functionData => eval(functionData))}

    function parseTemplateLiteral() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[183091:183543]", functionData => eval(functionData))}

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr, marker, typeAnnotation;

        expect('(');

        ++state.parenthesizedCount;

        marker = markerCreate();

        expr = parseExpression();

        if (match(':')) {
            typeAnnotation = parseTypeAnnotation();
            expr = markerApply(marker, delegate.createTypeCast(
                expr,
                typeAnnotation
            ));
        }

        expect(')');

        return expr;
    }

    function matchAsyncFuncExprOrDecl() {
        var token;

        if (matchAsync()) {
            token = lookahead2();
            if (token.type === Token.Keyword && token.value === 'function') {
                return true;
            }
        }

        return false;
    }

    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var marker, type, token, expr;

        type = lookahead.type;

        if (type === Token.Identifier) {
            marker = markerCreate();
            return markerApply(marker, delegate.createIdentifier(lex().value));
        }

        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            marker = markerCreate();
            return markerApply(marker, delegate.createLiteral(lex()));
        }

        if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                marker = markerCreate();
                lex();
                return markerApply(marker, delegate.createThisExpression());
            }

            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }

            if (matchKeyword('class')) {
                return parseClassExpression();
            }

            if (matchKeyword('super')) {
                marker = markerCreate();
                lex();
                return markerApply(marker, delegate.createIdentifier('super'));
            }
        }

        if (type === Token.BooleanLiteral) {
            marker = markerCreate();
            token = lex();
            token.value = (token.value === 'true');
            return markerApply(marker, delegate.createLiteral(token));
        }

        if (type === Token.NullLiteral) {
            marker = markerCreate();
            token = lex();
            token.value = null;
            return markerApply(marker, delegate.createLiteral(token));
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('/') || match('/=')) {
            marker = markerCreate();
            expr = delegate.createLiteral(scanRegExp());
            peek();
            return markerApply(marker, expr);
        }

        if (type === Token.Template) {
            return parseTemplateLiteral();
        }

        if (match('<')) {
            return parseJSXElement();
        }

        throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [], arg;

        expect('(');

        if (!match(')')) {
            while (index < length) {
                arg = parseSpreadOrAssignmentExpression();
                args.push(arg);

                if (match(')')) {
                    break;
                } else if (arg.type === Syntax.SpreadElement) {
                    throwError({}, Messages.ElementAfterSpreadElement);
                }

                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseSpreadOrAssignmentExpression() {
        if (match('...')) {
            var marker = markerCreate();
            lex();
            return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));
        }
        return parseAssignmentExpression();
    }

    function parseNonComputedProperty() {
        var marker = markerCreate(),
            token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return markerApply(marker, delegate.createIdentifier(token.value));
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[188096:188222]", functionData => eval(functionData))}

    function parseNewExpression() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[188258:188527]", functionData => eval(functionData))}

    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, marker = markerCreate();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(') || lookahead.type === Token.Template) {
            if (match('(')) {
                args = parseArguments();
                expr = markerApply(marker, delegate.createCallExpression(expr, args));
            } else if (match('[')) {
                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));
            } else if (match('.')) {
                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));
            } else {
                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
            }
        }

        return expr;
    }

    function parseLeftHandSideExpression() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[189503:190195]", functionData => eval(functionData))}

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var marker = markerCreate(),
            expr = parseLeftHandSideExpressionAllowCall(),
            token;

        if (lookahead.type !== Token.Punctuator) {
            return expr;
        }

        if ((match('++') || match('--')) && !peekLineTerminator()) {
            // 11.3.1, 11.3.2
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPostfix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            token = lex();
            expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var marker, token, expr;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            return parsePostfixExpression();
        }

        if (match('++') || match('--')) {
            marker = markerCreate();
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
        }

        if (match('+') || match('-') || match('~') || match('!')) {
            marker = markerCreate();
            token = lex();
            expr = parseUnaryExpression();
            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
        }

        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            marker = markerCreate();
            token = lex();
            expr = parseUnaryExpression();
            expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
            return expr;
        }

        return parsePostfixExpression();
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var expr, token, prec, previousAllowIn, stack, right, operator, left, i,
            marker, markers;

        previousAllowIn = state.allowIn;
        state.allowIn = true;

        marker = markerCreate();
        left = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token, previousAllowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        markers = [marker, markerCreate()];
        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                markers.pop();
                marker = markers.pop();
                markerApply(marker, expr);
                stack.push(expr);
                markers.push(marker);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(markerCreate());
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        state.allowIn = previousAllowIn;

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
            marker = markers.pop();
            markerApply(marker, expr);
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, marker = markerCreate();
        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));
        }

        return expr;
    }

    // 11.13 Assignment Operators

    // 12.14.5 AssignmentPattern

    function reinterpretAsAssignmentBindingPattern(expr) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[196796:198737]", functionData => eval(functionData))}

    // 13.2.3 BindingPattern

    function reinterpretAsDestructuredParameter(options, expr) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[198832:200554]", functionData => eval(functionData))}

    function reinterpretAsCoverFormalsList(expressions) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[200612:202687]", functionData => eval(functionData))}

    function parseArrowFunctionExpression(options, marker) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[202748:203757]", functionData => eval(functionData))}

    function parseAssignmentExpression() {
        var marker, expr, token, params, oldParenthesizedCount,
            startsWithParen = false, backtrackToken = lookahead,
            possiblyAsync = false;

        if (matchYield()) {
            return parseYieldExpression();
        }

        if (matchAwait()) {
            return parseAwaitExpression();
        }

        oldParenthesizedCount = state.parenthesizedCount;

        marker = markerCreate();

        if (matchAsyncFuncExprOrDecl()) {
            return parseFunctionExpression();
        }

        if (matchAsync()) {
            // We can't be completely sure that this 'async' token is
            // actually a contextual keyword modifying a function
            // expression, so we might have to un-lex() it later by
            // calling rewind(backtrackToken).
            possiblyAsync = true;
            lex();
        }

        if (match('(')) {
            token = lookahead2();
            if ((token.type === Token.Punctuator && token.value === ')') || token.value === '...') {
                params = parseParams();
                if (!match('=>')) {
                    throwUnexpected(lex());
                }
                params.async = possiblyAsync;
                return parseArrowFunctionExpression(params, marker);
            }
            startsWithParen = true;
        }

        token = lookahead;

        // If the 'async' keyword is not followed by a '(' character or an
        // identifier, then it can't be an arrow function modifier, and we
        // should interpret it as a normal identifer.
        if (possiblyAsync && !match('(') && token.type !== Token.Identifier) {
            possiblyAsync = false;
            rewind(backtrackToken);
        }

        expr = parseConditionalExpression();

        if (match('=>') &&
                (state.parenthesizedCount === oldParenthesizedCount ||
                state.parenthesizedCount === (oldParenthesizedCount + 1))) {
            if (expr.type === Syntax.Identifier) {
                params = reinterpretAsCoverFormalsList([ expr ]);
            } else if (expr.type === Syntax.AssignmentExpression ||
                    expr.type === Syntax.ArrayExpression ||
                    expr.type === Syntax.ObjectExpression) {
                if (!startsWithParen) {
                    throwUnexpected(lex());
                }
                params = reinterpretAsCoverFormalsList([ expr ]);
            } else if (expr.type === Syntax.SequenceExpression) {
                params = reinterpretAsCoverFormalsList(expr.expressions);
            }
            if (params) {
                params.async = possiblyAsync;
                return parseArrowFunctionExpression(params, marker);
            }
        }

        // If we haven't returned by now, then the 'async' keyword was not
        // a function modifier, and we should rewind and interpret it as a
        // normal identifier.
        if (possiblyAsync) {
            possiblyAsync = false;
            rewind(backtrackToken);
            expr = parseConditionalExpression();
        }

        if (matchAssign()) {
            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            // ES.next draf 11.13 Runtime Semantics step 1
            if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {
                reinterpretAsAssignmentBindingPattern(expr);
            } else if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var marker, expr, expressions, sequence, spreadFound;

        marker = markerCreate();
        expr = parseAssignmentExpression();
        expressions = [ expr ];

        if (match(',')) {
            while (index < length) {
                if (!match(',')) {
                    break;
                }

                lex();
                expr = parseSpreadOrAssignmentExpression();
                expressions.push(expr);

                if (expr.type === Syntax.SpreadElement) {
                    spreadFound = true;
                    if (!match(')')) {
                        throwError({}, Messages.ElementAfterSpreadElement);
                    }
                    break;
                }
            }

            sequence = markerApply(marker, delegate.createSequenceExpression(expressions));
        }

        if (spreadFound && lookahead2().value !== '=>') {
            throwError({}, Messages.IllegalSpread);
        }

        return sequence || expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block, marker = markerCreate();

        expect('{');

        block = parseStatementList();

        expect('}');

        return markerApply(marker, delegate.createBlockStatement(block));
    }

    // 12.2 Variable Statement

    function parseTypeParameterDeclaration() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[209432:209825]", functionData => eval(functionData))}

    function parseTypeParameterInstantiation() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[209874:210339]", functionData => eval(functionData))}

    function parseObjectTypeIndexer(marker, isStatic) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[210395:210765]", functionData => eval(functionData))}

    function parseObjectTypeMethodish(marker) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[210813:211557]", functionData => eval(functionData))}

    function parseObjectTypeMethod(marker, isStatic, key) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[211617:211873]", functionData => eval(functionData))}

    function parseObjectTypeCallProperty(marker, isStatic) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[211934:212141]", functionData => eval(functionData))}

    function parseObjectType(allowStatic) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[212185:214372]", functionData => eval(functionData))}

    function parseGenericType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[214406:215040]", functionData => eval(functionData))}

    function parseVoidType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[215071:215219]", functionData => eval(functionData))}

    function parseTypeofType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[215252:215483]", functionData => eval(functionData))}

    function parseTupleType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[215515:215937]", functionData => eval(functionData))}

    function parseFunctionTypeParam() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[215977:216394]", functionData => eval(functionData))}

    function parseFunctionTypeParams() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[216435:216808]", functionData => eval(functionData))}

    // The parsing of types roughly parallels the parsing of expressions, and
    // primary types are kind of like primary expressions...they're the
    // primitives with which other types are constructed.
    function parsePrimaryType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[217050:220794]", functionData => eval(functionData))}

    function parsePostfixType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[220828:221079]", functionData => eval(functionData))}

    function parsePrefixType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[221112:221374]", functionData => eval(functionData))}


    function parseIntersectionType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[221414:221815]", functionData => eval(functionData))}

    function parseUnionType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[221847:222252]", functionData => eval(functionData))}

    function parseType() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[222279:222449]", functionData => eval(functionData))}

    function parseTypeAnnotation() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[222486:222660]", functionData => eval(functionData))}

    function parseVariableIdentifier() {
        var marker = markerCreate(),
            token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return markerApply(marker, delegate.createIdentifier(token.value));
    }

    function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {
        var marker = markerCreate(),
            ident = parseVariableIdentifier(),
            isOptionalParam = false;

        if (canBeOptionalParam && match('?')) {
            expect('?');
            isOptionalParam = true;
        }

        if (requireTypeAnnotation || match(':')) {
            ident.typeAnnotation = parseTypeAnnotation();
            ident = markerApply(marker, ident);
        }

        if (isOptionalParam) {
            ident.optional = true;
            ident = markerApply(marker, ident);
        }

        return ident;
    }

    function parseVariableDeclaration(kind) {
        var id,
            marker = markerCreate(),
            init = null,
            typeAnnotationMarker = markerCreate();
        if (match('{')) {
            id = parseObjectInitialiser();
            reinterpretAsAssignmentBindingPattern(id);
            if (match(':')) {
                id.typeAnnotation = parseTypeAnnotation();
                markerApply(typeAnnotationMarker, id);
            }
        } else if (match('[')) {
            id = parseArrayInitialiser();
            reinterpretAsAssignmentBindingPattern(id);
            if (match(':')) {
                id.typeAnnotation = parseTypeAnnotation();
                markerApply(typeAnnotationMarker, id);
            }
        } else {
            /* istanbul ignore next */
            id = state.allowKeyword ? parseNonComputedProperty() : parseTypeAnnotatableIdentifier();
            // 12.2.1
            if (strict && isRestrictedWord(id.name)) {
                throwErrorTolerant({}, Messages.StrictVarName);
            }
        }

        if (kind === 'const') {
            if (!match('=')) {
                throwError({}, Messages.NoUninitializedConst);
            }
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return markerApply(marker, delegate.createVariableDeclarator(id, init));
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement() {
        var declarations, marker = markerCreate();

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return markerApply(marker, delegate.createVariableDeclaration(declarations, 'var'));
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[225947:226217]", functionData => eval(functionData))}

    // people.mozilla.org/~jorendorff/es6-draft.html

    function parseModuleSpecifier() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[226309:226627]", functionData => eval(functionData))}

    function parseExportBatchSpecifier() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[226670:226810]", functionData => eval(functionData))}

    function parseExportSpecifier() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[226848:227369]", functionData => eval(functionData))}

    function parseExportDeclaration() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[227409:231543]", functionData => eval(functionData))}


    function parseImportSpecifier() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[231582:231921]", functionData => eval(functionData))}

    function parseNamedImports() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[231956:232244]", functionData => eval(functionData))}

    function parseImportDefaultSpecifier() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[232289:232488]", functionData => eval(functionData))}

    function parseImportNamespaceSpecifier() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[232535:232895]", functionData => eval(functionData))}

    function parseImportDeclaration() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[232935:234775]", functionData => eval(functionData))}

    // 12.3 Empty Statement

    function parseEmptyStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[234841:234975]", functionData => eval(functionData))}

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var marker = markerCreate(), expr = parseExpression();
        consumeSemicolon();
        return markerApply(marker, delegate.createExpressionStatement(expr));
    }

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate, marker = markerCreate();

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[235831:236341]", functionData => eval(functionData))}

    function parseWhileStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[236378:236800]", functionData => eval(functionData))}

    function parseForVariableDeclaration() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[236845:237075]", functionData => eval(functionData))}

    function parseForStatement(opts) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[237114:240090]", functionData => eval(functionData))}

    // 12.7 The continue statement

    function parseContinueStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[240166:241288]", functionData => eval(functionData))}

    // 12.8 The break statement

    function parseBreakStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[241358:242545]", functionData => eval(functionData))}

    // 12.9 The return statement

    function parseReturnStatement() {
        var argument = null, marker = markerCreate();

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 32) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return markerApply(marker, delegate.createReturnStatement(argument));
            }
        }

        if (peekLineTerminator()) {
            return markerApply(marker, delegate.createReturnStatement(null));
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return markerApply(marker, delegate.createReturnStatement(argument));
    }

    // 12.10 The with statement

    function parseWithStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[243664:244044]", functionData => eval(functionData))}

    // 12.10 The swith statement

    function parseSwitchCase() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[244111:244865]", functionData => eval(functionData))}

    function parseSwitchStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[244903:245966]", functionData => eval(functionData))}

    // 12.13 The throw statement

    function parseThrowStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[246037:246373]", functionData => eval(functionData))}

    // 12.14 The try statement

    function parseCatchClause() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[246439:246976]", functionData => eval(functionData))}

    function parseTryStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[247011:247574]", functionData => eval(functionData))}

    // 12.15 The debugger statement

    function parseDebuggerStatement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[247651:247832]", functionData => eval(functionData))}

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            marker,
            expr,
            labeledBody;

        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement();
            case '{':
                return parseBlock();
            case '(':
                return parseExpressionStatement();
            default:
                break;
            }
        }

        if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement();
            case 'continue':
                return parseContinueStatement();
            case 'debugger':
                return parseDebuggerStatement();
            case 'do':
                return parseDoWhileStatement();
            case 'for':
                return parseForStatement();
            case 'function':
                return parseFunctionDeclaration();
            case 'class':
                return parseClassDeclaration();
            case 'if':
                return parseIfStatement();
            case 'return':
                return parseReturnStatement();
            case 'switch':
                return parseSwitchStatement();
            case 'throw':
                return parseThrowStatement();
            case 'try':
                return parseTryStatement();
            case 'var':
                return parseVariableStatement();
            case 'while':
                return parseWhileStatement();
            case 'with':
                return parseWithStatement();
            default:
                break;
            }
        }

        if (matchAsyncFuncExprOrDecl()) {
            return parseFunctionDeclaration();
        }

        marker = markerCreate();
        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            if (state.labelSet.has(expr.name)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet.set(expr.name, true);
            labeledBody = parseStatement();
            state.labelSet["delete"](expr.name);
            return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));
        }

        consumeSemicolon();

        return markerApply(marker, delegate.createExpressionStatement(expr));
    }

    // 13 Function Definition

    function parseConciseBody() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[250507:250644]", functionData => eval(functionData))}

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount,
            marker = markerCreate();

        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesizedCount = state.parenthesizedCount;

        state.labelSet = new StringMap();
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesizedCount;

        return markerApply(marker, delegate.createBlockStatement(sourceElements));
    }

    function validateParam(options, param, name) {
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (options.paramSet.has(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (options.paramSet.has(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet.set(name, true);
    }

    function parseParam(options) {
        var marker, token, rest, param, def;

        token = lookahead;
        if (token.value === '...') {
            token = lex();
            rest = true;
        }

        if (match('[')) {
            marker = markerCreate();
            param = parseArrayInitialiser();
            reinterpretAsDestructuredParameter(options, param);
            if (match(':')) {
                param.typeAnnotation = parseTypeAnnotation();
                markerApply(marker, param);
            }
        } else if (match('{')) {
            marker = markerCreate();
            if (rest) {
                throwError({}, Messages.ObjectPatternAsRestParameter);
            }
            param = parseObjectInitialiser();
            reinterpretAsDestructuredParameter(options, param);
            if (match(':')) {
                param.typeAnnotation = parseTypeAnnotation();
                markerApply(marker, param);
            }
        } else {
            param =
                rest
                ? parseTypeAnnotatableIdentifier(
                    false, /* requireTypeAnnotation */
                    false /* canBeOptionalParam */
                )
                : parseTypeAnnotatableIdentifier(
                    false, /* requireTypeAnnotation */
                    true /* canBeOptionalParam */
                );

            validateParam(options, token, token.value);
        }

        if (match('=')) {
            if (rest) {
                throwErrorTolerant(lookahead, Messages.DefaultRestParameter);
            }
            lex();
            def = parseAssignmentExpression();
            ++options.defaultCount;
        }

        if (rest) {
            if (!match(')')) {
                throwError({}, Messages.ParameterAfterRestParameter);
            }
            options.rest = param;
            return false;
        }

        options.params.push(param);
        options.defaults.push(def);
        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options, marker = markerCreate();

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            rest: null,
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = new StringMap();
            while (index < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        if (match(':')) {
            options.returnType = parseTypeAnnotation();
        }

        return markerApply(marker, options);
    }

    function parseFunctionDeclaration() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[256702:258997]", functionData => eval(functionData))}

    function parseFunctionExpression() {
        var token, id = null, firstRestricted, message, tmp, body, generator, isAsync,
            previousStrict, previousYieldAllowed, previousAwaitAllowed,
            marker = markerCreate(), typeParameters;

        isAsync = false;
        if (matchAsync()) {
            lex();
            isAsync = true;
        }

        expectKeyword('function');

        generator = false;

        if (match('*')) {
            lex();
            generator = true;
        }

        if (!match('(')) {
            if (!match('<')) {
                token = lookahead;
                id = parseVariableIdentifier();

                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        throwErrorTolerant(token, Messages.StrictFunctionName);
                    }
                } else {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictFunctionName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    }
                }
            }

            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
        }

        tmp = parseParams(firstRestricted);
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = generator;
        previousAwaitAllowed = state.awaitAllowed;
        state.awaitAllowed = isAsync;

        body = parseFunctionSourceElements();

        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && tmp.stricted) {
            throwErrorTolerant(tmp.stricted, message);
        }
        strict = previousStrict;
        state.yieldAllowed = previousYieldAllowed;
        state.awaitAllowed = previousAwaitAllowed;

        return markerApply(
            marker,
            delegate.createFunctionExpression(
                id,
                tmp.params,
                tmp.defaults,
                body,
                tmp.rest,
                generator,
                false,
                isAsync,
                tmp.returnType,
                typeParameters
            )
        );
    }

    function parseYieldExpression() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[261591:261950]", functionData => eval(functionData))}

    function parseAwaitExpression() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[261988:262198]", functionData => eval(functionData))}

    // 14 Functions and classes

    // 14.1 Functions is defined above (13 in ES5)
    // 14.2 Arrow Functions Definitions is defined in (7.3 assignments)

    // 14.3 Method Definitions
    // 14.3.7
    function specialMethod(methodDefinition) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[262447:262603]", functionData => eval(functionData))}

    function parseMethodDefinition(key, isStatic, generator, computed) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[262676:264945]", functionData => eval(functionData))}

    function parseClassProperty(key, computed, isStatic) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[265004:265254]", functionData => eval(functionData))}

    function parseClassElement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[265289:266401]", functionData => eval(functionData))}

    function parseClassBody() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[266433:268141]", functionData => eval(functionData))}

    function parseClassImplements() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[268179:268951]", functionData => eval(functionData))}

    function parseClassExpression() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[268989:270388]", functionData => eval(functionData))}

    function parseClassDeclaration() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[270427:271558]", functionData => eval(functionData))}

    // 15 Program

    function parseSourceElement() {
        var token;
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            case 'export':
                throwErrorTolerant({}, Messages.IllegalExportDeclaration);
                return parseExportDeclaration();
            case 'import':
                throwErrorTolerant({}, Messages.IllegalImportDeclaration);
                return parseImportDeclaration();
            case 'interface':
                if (lookahead2().type === Token.Identifier) {
                    return parseInterface();
                }
                return parseStatement();
            default:
                return parseStatement();
            }
        }

        if (matchContextualKeyword('type')
                && lookahead2().type === Token.Identifier) {
            return parseTypeAlias();
        }

        if (matchContextualKeyword('interface')
                && lookahead2().type === Token.Identifier) {
            return parseInterface();
        }

        if (matchContextualKeyword('declare')) {
            token = lookahead2();
            if (token.type === Token.Keyword) {
                switch (token.value) {
                case 'class':
                    return parseDeclareClass();
                case 'function':
                    return parseDeclareFunction();
                case 'var':
                    return parseDeclareVariable();
                }
            } else if (token.type === Token.Identifier
                    && token.value === 'module') {
                return parseDeclareModule();
            }
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseProgramElement() {
        var isModule = extra.sourceType === 'module' || extra.sourceType === 'nonStrictModule';

        if (isModule && lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                return parseExportDeclaration();
            case 'import':
                return parseImportDeclaration();
            }
        }

        return parseSourceElement();
    }

    function parseProgramElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseProgramElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseProgramElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var body, marker = markerCreate();
        strict = extra.sourceType === 'module';
        peek();
        body = parseProgramElements();
        return markerApply(marker, delegate.createProgram(body));
    }

    // 16 JSX

    XHTMLEntities = {
        quot: '\u0022',
        amp: '&',
        apos: '\u0027',
        lt: '<',
        gt: '>',
        nbsp: '\u00A0',
        iexcl: '\u00A1',
        cent: '\u00A2',
        pound: '\u00A3',
        curren: '\u00A4',
        yen: '\u00A5',
        brvbar: '\u00A6',
        sect: '\u00A7',
        uml: '\u00A8',
        copy: '\u00A9',
        ordf: '\u00AA',
        laquo: '\u00AB',
        not: '\u00AC',
        shy: '\u00AD',
        reg: '\u00AE',
        macr: '\u00AF',
        deg: '\u00B0',
        plusmn: '\u00B1',
        sup2: '\u00B2',
        sup3: '\u00B3',
        acute: '\u00B4',
        micro: '\u00B5',
        para: '\u00B6',
        middot: '\u00B7',
        cedil: '\u00B8',
        sup1: '\u00B9',
        ordm: '\u00BA',
        raquo: '\u00BB',
        frac14: '\u00BC',
        frac12: '\u00BD',
        frac34: '\u00BE',
        iquest: '\u00BF',
        Agrave: '\u00C0',
        Aacute: '\u00C1',
        Acirc: '\u00C2',
        Atilde: '\u00C3',
        Auml: '\u00C4',
        Aring: '\u00C5',
        AElig: '\u00C6',
        Ccedil: '\u00C7',
        Egrave: '\u00C8',
        Eacute: '\u00C9',
        Ecirc: '\u00CA',
        Euml: '\u00CB',
        Igrave: '\u00CC',
        Iacute: '\u00CD',
        Icirc: '\u00CE',
        Iuml: '\u00CF',
        ETH: '\u00D0',
        Ntilde: '\u00D1',
        Ograve: '\u00D2',
        Oacute: '\u00D3',
        Ocirc: '\u00D4',
        Otilde: '\u00D5',
        Ouml: '\u00D6',
        times: '\u00D7',
        Oslash: '\u00D8',
        Ugrave: '\u00D9',
        Uacute: '\u00DA',
        Ucirc: '\u00DB',
        Uuml: '\u00DC',
        Yacute: '\u00DD',
        THORN: '\u00DE',
        szlig: '\u00DF',
        agrave: '\u00E0',
        aacute: '\u00E1',
        acirc: '\u00E2',
        atilde: '\u00E3',
        auml: '\u00E4',
        aring: '\u00E5',
        aelig: '\u00E6',
        ccedil: '\u00E7',
        egrave: '\u00E8',
        eacute: '\u00E9',
        ecirc: '\u00EA',
        euml: '\u00EB',
        igrave: '\u00EC',
        iacute: '\u00ED',
        icirc: '\u00EE',
        iuml: '\u00EF',
        eth: '\u00F0',
        ntilde: '\u00F1',
        ograve: '\u00F2',
        oacute: '\u00F3',
        ocirc: '\u00F4',
        otilde: '\u00F5',
        ouml: '\u00F6',
        divide: '\u00F7',
        oslash: '\u00F8',
        ugrave: '\u00F9',
        uacute: '\u00FA',
        ucirc: '\u00FB',
        uuml: '\u00FC',
        yacute: '\u00FD',
        thorn: '\u00FE',
        yuml: '\u00FF',
        OElig: '\u0152',
        oelig: '\u0153',
        Scaron: '\u0160',
        scaron: '\u0161',
        Yuml: '\u0178',
        fnof: '\u0192',
        circ: '\u02C6',
        tilde: '\u02DC',
        Alpha: '\u0391',
        Beta: '\u0392',
        Gamma: '\u0393',
        Delta: '\u0394',
        Epsilon: '\u0395',
        Zeta: '\u0396',
        Eta: '\u0397',
        Theta: '\u0398',
        Iota: '\u0399',
        Kappa: '\u039A',
        Lambda: '\u039B',
        Mu: '\u039C',
        Nu: '\u039D',
        Xi: '\u039E',
        Omicron: '\u039F',
        Pi: '\u03A0',
        Rho: '\u03A1',
        Sigma: '\u03A3',
        Tau: '\u03A4',
        Upsilon: '\u03A5',
        Phi: '\u03A6',
        Chi: '\u03A7',
        Psi: '\u03A8',
        Omega: '\u03A9',
        alpha: '\u03B1',
        beta: '\u03B2',
        gamma: '\u03B3',
        delta: '\u03B4',
        epsilon: '\u03B5',
        zeta: '\u03B6',
        eta: '\u03B7',
        theta: '\u03B8',
        iota: '\u03B9',
        kappa: '\u03BA',
        lambda: '\u03BB',
        mu: '\u03BC',
        nu: '\u03BD',
        xi: '\u03BE',
        omicron: '\u03BF',
        pi: '\u03C0',
        rho: '\u03C1',
        sigmaf: '\u03C2',
        sigma: '\u03C3',
        tau: '\u03C4',
        upsilon: '\u03C5',
        phi: '\u03C6',
        chi: '\u03C7',
        psi: '\u03C8',
        omega: '\u03C9',
        thetasym: '\u03D1',
        upsih: '\u03D2',
        piv: '\u03D6',
        ensp: '\u2002',
        emsp: '\u2003',
        thinsp: '\u2009',
        zwnj: '\u200C',
        zwj: '\u200D',
        lrm: '\u200E',
        rlm: '\u200F',
        ndash: '\u2013',
        mdash: '\u2014',
        lsquo: '\u2018',
        rsquo: '\u2019',
        sbquo: '\u201A',
        ldquo: '\u201C',
        rdquo: '\u201D',
        bdquo: '\u201E',
        dagger: '\u2020',
        Dagger: '\u2021',
        bull: '\u2022',
        hellip: '\u2026',
        permil: '\u2030',
        prime: '\u2032',
        Prime: '\u2033',
        lsaquo: '\u2039',
        rsaquo: '\u203A',
        oline: '\u203E',
        frasl: '\u2044',
        euro: '\u20AC',
        image: '\u2111',
        weierp: '\u2118',
        real: '\u211C',
        trade: '\u2122',
        alefsym: '\u2135',
        larr: '\u2190',
        uarr: '\u2191',
        rarr: '\u2192',
        darr: '\u2193',
        harr: '\u2194',
        crarr: '\u21B5',
        lArr: '\u21D0',
        uArr: '\u21D1',
        rArr: '\u21D2',
        dArr: '\u21D3',
        hArr: '\u21D4',
        forall: '\u2200',
        part: '\u2202',
        exist: '\u2203',
        empty: '\u2205',
        nabla: '\u2207',
        isin: '\u2208',
        notin: '\u2209',
        ni: '\u220B',
        prod: '\u220F',
        sum: '\u2211',
        minus: '\u2212',
        lowast: '\u2217',
        radic: '\u221A',
        prop: '\u221D',
        infin: '\u221E',
        ang: '\u2220',
        and: '\u2227',
        or: '\u2228',
        cap: '\u2229',
        cup: '\u222A',
        'int': '\u222B',
        there4: '\u2234',
        sim: '\u223C',
        cong: '\u2245',
        asymp: '\u2248',
        ne: '\u2260',
        equiv: '\u2261',
        le: '\u2264',
        ge: '\u2265',
        sub: '\u2282',
        sup: '\u2283',
        nsub: '\u2284',
        sube: '\u2286',
        supe: '\u2287',
        oplus: '\u2295',
        otimes: '\u2297',
        perp: '\u22A5',
        sdot: '\u22C5',
        lceil: '\u2308',
        rceil: '\u2309',
        lfloor: '\u230A',
        rfloor: '\u230B',
        lang: '\u2329',
        rang: '\u232A',
        loz: '\u25CA',
        spades: '\u2660',
        clubs: '\u2663',
        hearts: '\u2665',
        diams: '\u2666'
    };

    function getQualifiedJSXName(object) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[281775:282328]", functionData => eval(functionData))}

    function isJSXIdentifierStart(ch) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[282368:282461]", functionData => eval(functionData))}

    function isJSXIdentifierPart(ch) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[282500:282626]", functionData => eval(functionData))}

    function scanJSXIdentifier() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[282661:283130]", functionData => eval(functionData))}

    function scanJSXEntity() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[283161:284332]", functionData => eval(functionData))}

    function scanJSXText(stopChars) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[284370:285267]", functionData => eval(functionData))}

    function scanJSXStringLiteral() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[285305:285778]", functionData => eval(functionData))}

    /**
     * Between JSX opening and closing tags (e.g. <foo>HERE</foo>), anything that
     * is not another JSX tag and is not an expression wrapped by {} is text.
     */
    function advanceJSXChild() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[285987:286246]", functionData => eval(functionData))}

    function parseJSXIdentifier() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[286282:286541]", functionData => eval(functionData))}

    function parseJSXNamespacedName() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[286581:286831]", functionData => eval(functionData))}

    function parseJSXMemberExpression() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[286873:287143]", functionData => eval(functionData))}

    function parseJSXElementName() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[287180:287421]", functionData => eval(functionData))}

    function parseJSXAttributeName() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[287460:287602]", functionData => eval(functionData))}

    function parseJSXAttributeValue() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[287642:288371]", functionData => eval(functionData))}

    function parseJSXEmptyExpression() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[288412:288625]", functionData => eval(functionData))}

    function parseJSXExpressionContainer() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[288670:289270]", functionData => eval(functionData))}

    function parseJSXSpreadAttribute() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[289311:289831]", functionData => eval(functionData))}

    function parseJSXAttribute() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[289866:290318]", functionData => eval(functionData))}

    function parseJSXChild() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[290349:290803]", functionData => eval(functionData))}

    function parseJSXClosingElement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[290843:291537]", functionData => eval(functionData))}

    function parseJSXOpeningElement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[291577:292703]", functionData => eval(functionData))}

    function parseJSXElement() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[292736:294556]", functionData => eval(functionData))}

    function parseTypeAlias() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[294588:295012]", functionData => eval(functionData))}

    function parseInterfaceExtends() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[295051:295387]", functionData => eval(functionData))}

    function parseInterfaceish(marker, allowStatic) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[295441:296241]", functionData => eval(functionData))}

    function parseInterface() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[296273:296524]", functionData => eval(functionData))}

    function parseDeclareClass() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[296559:296809]", functionData => eval(functionData))}

    function parseDeclareFunction() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[296847:297944]", functionData => eval(functionData))}

    function parseDeclareVariable() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[297982:298275]", functionData => eval(functionData))}

    function parseDeclareModule() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[298311:299608]", functionData => eval(functionData))}

    function collectToken() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[299638:300658]", functionData => eval(functionData))}

    function collectRegex() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[300688:301802]", functionData => eval(functionData))}

    function filterTokenLocation() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[301839:302519]", functionData => eval(functionData))}

    function patch() {
        if (typeof extra.tokens !== 'undefined') {
            extra.advance = advance;
            extra.scanRegExp = scanRegExp;

            advance = collectToken;
            scanRegExp = collectRegex;
        }
    }

    function unpatch() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[302791:302942]", functionData => eval(functionData))}

    // This is used to modify the delegate.

    function extend(object, properties) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[303029:303486]", functionData => eval(functionData))}

    function tokenize(code, options) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[303525:306126]", functionData => eval(functionData))}

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowKeyword: false,
            allowIn: true,
            labelSet: new StringMap(),
            parenthesizedCount: 0,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            inJSXChild: false,
            inJSXTag: false,
            inType: false,
            lastCommentStart: -1,
            yieldAllowed: false,
            awaitAllowed: false
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                delegate = extend(delegate, {
                    'postProcess': function (node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[307509:307637]", functionData => eval(functionData))}
                });
            }

            extra.sourceType = options.sourceType;
            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }

        patch();
        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '13001.1001.0-dev-harmony-fb';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
   /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],10:[function(_dereq_,module,exports){
var Base62 = (function (my) {
  my.chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

  my.encode = function(i){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[310094:310243]", functionData => eval(functionData))};
  my.decode = function(a,b,c,d){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[310276:310458]", functionData => eval(functionData))};

  return my;
}({}));

module.exports = Base62
},{}],11:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[310549:310979]", functionData => eval(functionData))},{"./source-map/source-map-consumer":16,"./source-map/source-map-generator":17,"./source-map/source-node":18}],12:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[311126:313848]", functionData => eval(functionData))},{"./util":19,"amdefine":20}],13:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[313914:318810]", functionData => eval(functionData))},{"./base64":14,"amdefine":20}],14:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[318878:320019]", functionData => eval(functionData))},{"amdefine":20}],15:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[320073:323287]", functionData => eval(functionData))},{"amdefine":20}],16:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[323341:341081]", functionData => eval(functionData))},{"./array-set":12,"./base64-vlq":13,"./binary-search":15,"./util":19,"amdefine":20}],17:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[341203:354465]", functionData => eval(functionData))},{"./array-set":12,"./base64-vlq":13,"./util":19,"amdefine":20}],18:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[354566:367505]", functionData => eval(functionData))},{"./source-map-generator":17,"./util":19,"amdefine":20}],19:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[367599:372932]", functionData => eval(functionData))},{"amdefine":20}],20:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[372986:382991]", functionData => eval(functionData))},{"_process":8,"path":7}],21:[function(_dereq_,module,exports){lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[383053:385253]", functionData => eval(functionData))},{}],22:[function(_dereq_,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*jslint node: true*/
"use strict";

var esprima = _dereq_('esprima-fb');
var utils = _dereq_('./utils');

var getBoundaryNode = utils.getBoundaryNode;
var declareIdentInScope = utils.declareIdentInLocalScope;
var initScopeMetadata = utils.initScopeMetadata;
var Syntax = esprima.Syntax;

/**
 * @param {object} node
 * @param {object} parentNode
 * @return {boolean}
 */
function _nodeIsClosureScopeBoundary(node, parentNode) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[386320:386803]", functionData => eval(functionData))}

function _nodeIsBlockScopeBoundary(node, parentNode) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[386858:387019]", functionData => eval(functionData))}

/**
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function traverse(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[387138:391062]", functionData => eval(functionData))}

function collectClosureIdentsAndTraverse(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[391124:391261]", functionData => eval(functionData))}

function collectBlockIdentsAndTraverse(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[391321:391454]", functionData => eval(functionData))}

function visitLocalClosureIdentifiers(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[391513:392354]", functionData => eval(functionData))}

function visitLocalBlockIdentifiers(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[392411:392544]", functionData => eval(functionData))}

function walker(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[392581:392777]", functionData => eval(functionData))}

var _astCache = {};

function getAstForSource(source, options) {
  if (_astCache[source] && !options.disableAstCache) {
    return _astCache[source];
  }
  var ast = esprima.parse(source, {
    comment: true,
    loc: true,
    range: true,
    sourceType: options.sourceType
  });
  if (!options.disableAstCache) {
    _astCache[source] = ast;
  }
  return ast;
}

/**
 * Applies all available transformations to the source
 * @param {array} visitors
 * @param {string} source
 * @param {?object} options
 * @return {object}
 */
function transform(visitors, source, options) {
  options = options || {};
  var ast;
  try {
    ast = getAstForSource(source, options);
    } catch (e) {
    e.message = 'Parse Error: ' + e.message;
    throw e;
  }
  var state = utils.createState(source, ast, options);
  state.g.visitors = visitors;

  if (options.sourceMap) {
    var SourceMapGenerator = _dereq_('source-map').SourceMapGenerator;
    state.g.sourceMap = new SourceMapGenerator({file: options.filename || 'transformed.js'});
  }

  traverse(ast, [], state);
  utils.catchup(source.length, state);

  var ret = {code: state.g.buffer, extra: state.g.extra};
  if (options.sourceMap) {
    ret.sourceMap = state.g.sourceMap;
    ret.sourceMapFilename =  options.filename || 'source.js';
  }
  return ret;
}

exports.transform = transform;
exports.Syntax = Syntax;

},{"./utils":23,"esprima-fb":9,"source-map":11}],23:[function(_dereq_,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*jslint node: true*/
var Syntax = _dereq_('esprima-fb').Syntax;
var leadingIndentRegexp = /(^|\n)( {2}|\t)/g;
var nonWhiteRegexp = /(\S)/g;

/**
 * A `state` object represents the state of the parser. It has "local" and
 * "global" parts. Global contains parser position, source, etc. Local contains
 * scope based properties like current class name. State should contain all the
 * info required for transformation. It's the only mandatory object that is
 * being passed to every function in transform chain.
 *
 * @param  {string} source
 * @param  {object} transformOptions
 * @return {object}
 */
function createState(source, rootNode, transformOptions) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[395486:398916]", functionData => eval(functionData))}

/**
 * Updates a copy of a given state with "update" and returns an updated state.
 *
 * @param  {object} state
 * @param  {object} update
 * @return {object}
 */
function updateState(state, update) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[399117:399269]", functionData => eval(functionData))}

/**
 * Given a state fill the resulting buffer from the original source up to
 * the end
 *
 * @param {number} end
 * @param {object} state
 * @param {?function} contentTransformer Optional callback to transform newly
 *                                       added content.
 */
function catchup(end, state, contentTransformer) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[399598:401280]", functionData => eval(functionData))}

/**
 * Returns original source for an AST node.
 * @param {object} node
 * @param {object} state
 * @return {string}
 */
function getNodeSourceText(node, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[401443:401511]", functionData => eval(functionData))}

function _replaceNonWhite(value) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[401546:401594]", functionData => eval(functionData))}

/**
 * Removes all non-whitespace characters
 */
function _stripNonWhite(value) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[401676:401723]", functionData => eval(functionData))}

/**
 * Finds the position of the next instance of the specified syntactic char in
 * the pending source.
 *
 * NOTE: This will skip instances of the specified char if they sit inside a
 *       comment body.
 *
 * NOTE: This function also assumes that the buffer's current position is not
 *       already within a comment or a string. This is rarely the case since all
 *       of the buffer-advancement utility methods tend to be used on syntactic
 *       nodes' range values -- but it's a small gotcha that's worth mentioning.
 */
function getNextSyntacticCharOffset(char, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[402309:403677]", functionData => eval(functionData))}

/**
 * Catches up as `catchup` but replaces non-whitespace chars with spaces.
 */
function catchupWhiteOut(end, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[403798:403842]", functionData => eval(functionData))}

/**
 * Catches up as `catchup` but removes all non-whitespace characters.
 */
function catchupWhiteSpace(end, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[403961:404003]", functionData => eval(functionData))}

/**
 * Removes all non-newline characters
 */
var reNonNewline = /[^\n]/g;
function stripNonNewline(value) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[404112:404186]", functionData => eval(functionData))}

/**
 * Catches up as `catchup` but removes all non-newline characters.
 *
 * Equivalent to appending as many newlines as there are in the original source
 * between the current position and `end`.
 */
function catchupNewlines(end, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[404426:404469]", functionData => eval(functionData))}


/**
 * Same as catchup but does not touch the buffer
 *
 * @param  {number} end
 * @param  {object} state
 */
function move(end, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[404608:405134]", functionData => eval(functionData))}

/**
 * Appends a string of text to the buffer
 *
 * @param {string} str
 * @param {object} state
 */
function append(str, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[405265:405833]", functionData => eval(functionData))}

/**
 * Update indent using state.indentBy property. Indent is measured in
 * double spaces. Updates a single line only.
 *
 * @param {string} str
 * @param {object} state
 * @return {string}
 */
function updateIndent(str, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[406064:406373]", functionData => eval(functionData))}

/**
 * Calculates indent from the beginning of the line until "start" or the first
 * character before start.
 * @example
 *   "  foo.bar()"
 *         ^
 *       start
 *   indent will be "  "
 *
 * @param  {number} start
 * @param  {object} state
 * @return {string}
 */
function indentBefore(start, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[406684:406925]", functionData => eval(functionData))}

function getDocblock(state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[406955:407145]", functionData => eval(functionData))}

function identWithinLexicalScope(identName, state, stopBeforeNode) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[407214:407507]", functionData => eval(functionData))}

function identInLocalScope(identName, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[407554:407621]", functionData => eval(functionData))}

/**
 * @param {object} boundaryNode
 * @param {?array} path
 * @return {?object} node
 */
function initScopeMetadata(boundaryNode, path, node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[407766:407862]", functionData => eval(functionData))}

function declareIdentInLocalScope(identName, metaData, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[407926:408117]", functionData => eval(functionData))}

function getLexicalBindingMetadata(identName, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[408172:408388]", functionData => eval(functionData))}

function getLocalBindingMetadata(identName, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[408441:408494]", functionData => eval(functionData))}

/**
 * Apply the given analyzer function to the current node. If the analyzer
 * doesn't return false, traverse each child of the current node using the given
 * traverser function.
 *
 * @param {function} analyzer
 * @param {function} traverser
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function analyzeAndTraverse(analyzer, traverser, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[408886:409130]", functionData => eval(functionData))}

/**
 * It is crucial that we traverse in order, or else catchup() on a later
 * node that is processed out of order can move the buffer past a node
 * that we haven't handled yet, preventing us from modifying that node.
 *
 * This can happen when a node has multiple properties containing children.
 * For example, XJSElement nodes have `openingElement`, `closingElement` and
 * `children`. If we traverse `openingElement`, then `closingElement`, then
 * when we get to `children`, the buffer has already caught up to the end of
 * the closing element, after the children.
 *
 * This is basically a Schwartzian transform. Collects an array of children,
 * each one represented as [child, startIndex]; sorts the array by start
 * index; then traverses the children in that order.
 */
function getOrderedChildren(node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[409949:410203]", functionData => eval(functionData))}

/**
 * Helper function for analyzeAndTraverse which queues up all of the children
 * of the given node.
 *
 * Children can also be found in arrays, so we basically want to merge all of
 * those arrays together so we can sort them and then traverse the children
 * in order.
 *
 * One example is the Program node. It contains `body` and `comments`, both
 * arrays. Lexographically, comments are interspersed throughout the body
 * nodes, but esprima's AST groups them together.
 */
function enqueueNodeWithStartIndex(queue, node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[410734:411006]", functionData => eval(functionData))}

/**
 * Checks whether a node or any of its sub-nodes contains
 * a syntactic construct of the passed type.
 * @param {object} node - AST node to test.
 * @param {string} type - node type to lookup.
 */
function containsChildOfType(node, type) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[411251:411345]", functionData => eval(functionData))}

function containsChildMatching(node, matcher) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[411393:411839]", functionData => eval(functionData))}

var scopeTypes = {};
scopeTypes[Syntax.ArrowFunctionExpression] = true;
scopeTypes[Syntax.FunctionExpression] = true;
scopeTypes[Syntax.FunctionDeclaration] = true;
scopeTypes[Syntax.Program] = true;

function getBoundaryNode(path) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[412073:412334]", functionData => eval(functionData))}

function getTempVar(tempVarIndex) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[412370:412404]", functionData => eval(functionData))}

function injectTempVar(state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[412436:412559]", functionData => eval(functionData))}

function injectTempVarDeclarations(state, index) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[412610:412850]", functionData => eval(functionData))}

exports.analyzeAndTraverse = analyzeAndTraverse;
exports.append = append;
exports.catchup = catchup;
exports.catchupNewlines = catchupNewlines;
exports.catchupWhiteOut = catchupWhiteOut;
exports.catchupWhiteSpace = catchupWhiteSpace;
exports.containsChildMatching = containsChildMatching;
exports.containsChildOfType = containsChildOfType;
exports.createState = createState;
exports.declareIdentInLocalScope = declareIdentInLocalScope;
exports.getBoundaryNode = getBoundaryNode;
exports.getDocblock = getDocblock;
exports.getLexicalBindingMetadata = getLexicalBindingMetadata;
exports.getLocalBindingMetadata = getLocalBindingMetadata;
exports.getNextSyntacticCharOffset = getNextSyntacticCharOffset;
exports.getNodeSourceText = getNodeSourceText;
exports.getOrderedChildren = getOrderedChildren;
exports.getTempVar = getTempVar;
exports.identInLocalScope = identInLocalScope;
exports.identWithinLexicalScope = identWithinLexicalScope;
exports.indentBefore = indentBefore;
exports.initScopeMetadata = initScopeMetadata;
exports.injectTempVar = injectTempVar;
exports.injectTempVarDeclarations = injectTempVarDeclarations;
exports.move = move;
exports.scopeTypes = scopeTypes;
exports.updateIndent = updateIndent;
exports.updateState = updateState;

},{"./docblock":21,"esprima-fb":9}],24:[function(_dereq_,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global exports:true*/

/**
 * Desugars ES6 Arrow functions to ES3 function expressions.
 * If the function contains `this` expression -- automatically
 * binds the function to current value of `this`.
 *
 * Single parameter, simple expression:
 *
 * [1, 2, 3].map(x => x * x);
 *
 * [1, 2, 3].map(function(x) { return x * x; });
 *
 * Several parameters, complex block:
 *
 * this.users.forEach((user, idx) => {
 *   return this.isActive(idx) && this.send(user);
 * });
 *
 * this.users.forEach(function(user, idx) {
 *   return this.isActive(idx) && this.send(user);
 * }.bind(this));
 *
 */
var restParamVisitors = _dereq_('./es6-rest-param-visitors');
var destructuringVisitors = _dereq_('./es6-destructuring-visitors');

var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');

/**
 * @public
 */
function visitArrowFunction(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[415655:416816]", functionData => eval(functionData))}

function renderParams(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[416869:417246]", functionData => eval(functionData))}

function isParensFreeSingleParam(node, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[417294:417380]", functionData => eval(functionData))}

function renderExpressionBody(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[417441:418154]", functionData => eval(functionData))}

function renderStatementBody(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[418214:418297]", functionData => eval(functionData))}

visitArrowFunction.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[418353:418411]", functionData => eval(functionData))};

exports.visitorList = [
  visitArrowFunction
];


},{"../src/utils":23,"./es6-destructuring-visitors":27,"./es6-rest-param-visitors":30,"esprima-fb":9}],25:[function(_dereq_,module,exports){
/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 */
/*global exports:true*/

/**
 * Implements ES6 call spread.
 *
 * instance.method(a, b, c, ...d)
 *
 * instance.method.apply(instance, [a, b, c].concat(d))
 *
 */

var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');

function process(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[418961:419070]", functionData => eval(functionData))}

function visitCallSpread(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[419126:421518]", functionData => eval(functionData))}

visitCallSpread.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[421571:421800]", functionData => eval(functionData))};

exports.visitorList = [
  visitCallSpread
];

},{"../src/utils":23,"esprima-fb":9}],26:[function(_dereq_,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * @typechecks
 */
'use strict';

var base62 = _dereq_('base62');
var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');
var reservedWordsHelper = _dereq_('./reserved-words-helper');

var declareIdentInLocalScope = utils.declareIdentInLocalScope;
var initScopeMetadata = utils.initScopeMetadata;

var SUPER_PROTO_IDENT_PREFIX = '____SuperProtoOf';

var _anonClassUUIDCounter = 0;
var _mungedSymbolMaps = {};

function resetSymbols() {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[423005:423063]", functionData => eval(functionData))}

/**
 * Used to generate a unique class for use with code-gens for anonymous class
 * expressions.
 *
 * @param {object} state
 * @return {string}
 */
function _generateAnonymousClassName(state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[423259:423393]", functionData => eval(functionData))}

/**
 * Given an identifier name, munge it using the current state's mungeNamespace.
 *
 * @param {string} identName
 * @param {object} state
 * @return {string}
 */
function _getMungedName(identName, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[423602:424167]", functionData => eval(functionData))}

/**
 * Extracts super class information from a class node.
 *
 * Information includes name of the super class and/or the expression string
 * (if extending from an expression)
 *
 * @param {object} node
 * @param {object} state
 * @return {object}
 */
function _getSuperClassInfo(node, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[424462:424892]", functionData => eval(functionData))}

/**
 * Used with .filter() to find the constructor method in a list of
 * MethodDefinition nodes.
 *
 * @param {object} classElement
 * @return {boolean}
 */
function _isConstructorMethod(classElement) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[425096:425263]", functionData => eval(functionData))}

/**
 * @param {object} node
 * @param {object} state
 * @return {boolean}
 */
function _shouldMungeIdentifier(node, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[425388:425531]", functionData => eval(functionData))}

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitClassMethod(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[425698:426177]", functionData => eval(functionData))}
visitClassMethod.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[426230:426281]", functionData => eval(functionData))};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitClassFunctionExpression(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[426461:429872]", functionData => eval(functionData))}
visitClassFunctionExpression.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[429937:430043]", functionData => eval(functionData))};

function visitClassMethodParam(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[430106:430307]", functionData => eval(functionData))}
visitClassMethodParam.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[430365:430650]", functionData => eval(functionData))};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function _renderClassBody(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[430818:433622]", functionData => eval(functionData))}

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitClassDeclaration(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[433794:434076]", functionData => eval(functionData))}
visitClassDeclaration.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[434134:434185]", functionData => eval(functionData))};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitClassExpression(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[434357:434784]", functionData => eval(functionData))}
visitClassExpression.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[434841:434891]", functionData => eval(functionData))};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitPrivateIdentifier(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[435065:435161]", functionData => eval(functionData))}
visitPrivateIdentifier.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[435220:436361]", functionData => eval(functionData))};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitSuperCallExpression(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[436537:437968]", functionData => eval(functionData))}
visitSuperCallExpression.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[438029:438339]", functionData => eval(functionData))};

/**
 * @param {function} traverse
 * @param {object} node
 * @param {array} path
 * @param {object} state
 */
function visitSuperMemberExpression(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[438517:438676]", functionData => eval(functionData))}
visitSuperMemberExpression.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[438739:438911]", functionData => eval(functionData))};

exports.resetSymbols = resetSymbols;

exports.visitorList = [
  visitClassDeclaration,
  visitClassExpression,
  visitClassFunctionExpression,
  visitClassMethod,
  visitClassMethodParam,
  visitPrivateIdentifier,
  visitSuperCallExpression,
  visitSuperMemberExpression
];

},{"../src/utils":23,"./reserved-words-helper":34,"base62":10,"esprima-fb":9}],27:[function(_dereq_,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*global exports:true*/

/**
 * Implements ES6 destructuring assignment and pattern matchng.
 *
 * function init({port, ip, coords: [x, y]}) {
 *   return (x && y) ? {id, port} : {ip};
 * };
 *
 * function init($__0) {
 *   var
 *    port = $__0.port,
 *    ip = $__0.ip,
 *    $__1 = $__0.coords,
 *    x = $__1[0],
 *    y = $__1[1];
 *   return (x && y) ? {id, port} : {ip};
 * }
 *
 * var x, {ip, port} = init({ip, port});
 *
 * var x, $__0 = init({ip, port}), ip = $__0.ip, port = $__0.port;
 *
 */
var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');

var reservedWordsHelper = _dereq_('./reserved-words-helper');
var restParamVisitors = _dereq_('./es6-rest-param-visitors');
var restPropertyHelpers = _dereq_('./es7-rest-property-helpers');

// -------------------------------------------------------
// 1. Structured variable declarations.
//
// var [a, b] = [b, a];
// var {x, y} = {y, x};
// -------------------------------------------------------

function visitStructuredVariable(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[440949:441417]", functionData => eval(functionData))}

visitStructuredVariable.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[441478:441567]", functionData => eval(functionData))};

function isStructuredPattern(node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[441605:441694]", functionData => eval(functionData))}

// Main function which does actual recursive destructuring
// of nested complex structures.
function getDestructuredComponents(node, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[441836:443385]", functionData => eval(functionData))}

function getPatternItems(node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[443418:443464]", functionData => eval(functionData))}

function getPatternItemAccessor(node, patternItem, tmpIndex, idx) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[443532:444092]", functionData => eval(functionData))}

function getPatternItemValue(node, patternItem) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[444142:444232]", functionData => eval(functionData))}

// -------------------------------------------------------
// 2. Assignment expression.
//
// [a, b] = [b, a];
// ({x, y} = {y, x});
// -------------------------------------------------------

function visitStructuredAssignment(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[444491:444963]", functionData => eval(functionData))}

visitStructuredAssignment.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[445026:445379]", functionData => eval(functionData))};

// -------------------------------------------------------
// 3. Structured parameter.
//
// function foo({x, y}) { ... }
// -------------------------------------------------------

function visitStructuredParameter(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[445627:445762]", functionData => eval(functionData))}

function getParamIndex(paramNode, path) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[445804:446077]", functionData => eval(functionData))}

visitStructuredParameter.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[446139:446205]", functionData => eval(functionData))};

function isFunctionNode(node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[446238:446434]", functionData => eval(functionData))}

// -------------------------------------------------------
// 4. Function body for structured parameters.
//
// function foo({x, y}) { x; y; }
// -------------------------------------------------------

function visitFunctionBodyForStructuredParameter(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[446717:446992]", functionData => eval(functionData))}

function renderDestructuredComponents(funcNode, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[447049:447474]", functionData => eval(functionData))}

visitFunctionBodyForStructuredParameter.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[447551:447627]", functionData => eval(functionData))};

exports.visitorList = [
  visitStructuredVariable,
  visitStructuredAssignment,
  visitStructuredParameter,
  visitFunctionBodyForStructuredParameter
];

exports.renderDestructuredComponents = renderDestructuredComponents;


},{"../src/utils":23,"./es6-rest-param-visitors":30,"./es7-rest-property-helpers":32,"./reserved-words-helper":34,"esprima-fb":9}],28:[function(_dereq_,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * Desugars concise methods of objects to function expressions.
 *
 * var foo = {
 *   method(x, y) { ... }
 * };
 *
 * var foo = {
 *   method: function(x, y) { ... }
 * };
 *
 */

var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');
var reservedWordsHelper = _dereq_('./reserved-words-helper');

function visitObjectConciseMethod(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[449034:449682]", functionData => eval(functionData))}

visitObjectConciseMethod.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[449744:449868]", functionData => eval(functionData))};

exports.visitorList = [
  visitObjectConciseMethod
];

},{"../src/utils":23,"./reserved-words-helper":34,"esprima-fb":9}],29:[function(_dereq_,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node: true*/

/**
 * Desugars ES6 Object Literal short notations into ES3 full notation.
 *
 * // Easier return values.
 * function foo(x, y) {
 *   return {x, y}; // {x: x, y: y}
 * };
 *
 * // Destructuring.
 * function init({port, ip, coords: {x, y}}) { ... }
 *
 */
var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');

/**
 * @public
 */
function visitObjectLiteralShortNotation(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[451076:451182]", functionData => eval(functionData))}

visitObjectLiteralShortNotation.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[451251:451398]", functionData => eval(functionData))};

exports.visitorList = [
  visitObjectLiteralShortNotation
];


},{"../src/utils":23,"esprima-fb":9}],30:[function(_dereq_,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * Desugars ES6 rest parameters into an ES3 arguments array.
 *
 * function printf(template, ...args) {
 *   args.forEach(...);
 * }
 *
 * We could use `Array.prototype.slice.call`, but that usage of arguments causes
 * functions to be deoptimized in V8, so instead we use a for-loop.
 *
 * function printf(template) {
 *   for (var args = [], $__0 = 1, $__1 = arguments.length; $__0 < $__1; $__0++)
 *     args.push(arguments[$__0]);
 *   args.forEach(...);
 * }
 *
 */
var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');



function _nodeIsFunctionWithRestParam(node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[452760:452949]", functionData => eval(functionData))}

function visitFunctionParamsWithRestParam(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[453022:453580]", functionData => eval(functionData))}

visitFunctionParamsWithRestParam.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[453650:453698]", functionData => eval(functionData))};

function renderRestParamSetup(functionNode, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[453752:454206]", functionData => eval(functionData))}

function visitFunctionBodyWithRestParam(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[454277:454430]", functionData => eval(functionData))}

visitFunctionBodyWithRestParam.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[454498:454597]", functionData => eval(functionData))};

exports.renderRestParamSetup = renderRestParamSetup;
exports.visitorList = [
  visitFunctionParamsWithRestParam,
  visitFunctionBodyWithRestParam
];

},{"../src/utils":23,"esprima-fb":9}],31:[function(_dereq_,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * @typechecks
 */
'use strict';

var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');

/**
 * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-12.1.9
 */
function visitTemplateLiteral(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[455697:457401]", functionData => eval(functionData))}

visitTemplateLiteral.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[457459:457509]", functionData => eval(functionData))};

/**
 * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-12.2.6
 */
function visitTaggedTemplateExpression(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[457655:459232]", functionData => eval(functionData))}

visitTaggedTemplateExpression.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[459299:459358]", functionData => eval(functionData))};

function getCookedValue(templateElement) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[459402:459460]", functionData => eval(functionData))}

function getRawValue(templateElement) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[459500:459555]", functionData => eval(functionData))}

exports.visitorList = [
  visitTemplateLiteral,
  visitTaggedTemplateExpression
];

},{"../src/utils":23,"esprima-fb":9}],32:[function(_dereq_,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*jslint node:true*/

/**
 * Desugars ES7 rest properties into ES5 object iteration.
 */

var Syntax = _dereq_('esprima-fb').Syntax;

// TODO: This is a pretty massive helper, it should only be defined once, in the
// transform's runtime environment. We don't currently have a runtime though.
var restFunction =
  '(function(source, exclusion) {' +
    'var rest = {};' +
    'var hasOwn = Object.prototype.hasOwnProperty;' +
    'if (source == null) {' +
      'throw new TypeError();' +
    '}' +
    'for (var key in source) {' +
      'if (hasOwn.call(source, key) && !hasOwn.call(exclusion, key)) {' +
        'rest[key] = source[key];' +
      '}' +
    '}' +
    'return rest;' +
  '})';

function getPropertyNames(properties) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[461047:461379]", functionData => eval(functionData))}

function getRestFunctionCall(source, exclusion) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[461429:461494]", functionData => eval(functionData))}

function getSimpleShallowCopy(accessorExpression) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[461546:461795]", functionData => eval(functionData))}

function renderRestExpression(accessorExpression, excludedProperties) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[461867:462121]", functionData => eval(functionData))}

exports.renderRestExpression = renderRestExpression;

},{"esprima-fb":9}],33:[function(_dereq_,module,exports){
/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 */
/*global exports:true*/

/**
 * Implements ES7 object spread property.
 * https://gist.github.com/sebmarkbage/aa849c7973cb4452c547
 *
 * { ...a, x: 1 }
 *
 * Object.assign({}, a, {x: 1 })
 *
 */

var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');

function visitObjectLiteralSpread(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[462640:464253]", functionData => eval(functionData))}

visitObjectLiteralSpread.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[464315:464755]", functionData => eval(functionData))};

exports.visitorList = [
  visitObjectLiteralSpread
];

},{"../src/utils":23,"esprima-fb":9}],34:[function(_dereq_,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var KEYWORDS = [
  'break', 'do', 'in', 'typeof', 'case', 'else', 'instanceof', 'var', 'catch',
  'export', 'new', 'void', 'class', 'extends', 'return', 'while', 'const',
  'finally', 'super', 'with', 'continue', 'for', 'switch', 'yield', 'debugger',
  'function', 'this', 'default', 'if', 'throw', 'delete', 'import', 'try'
];

var FUTURE_RESERVED_WORDS = [
  'enum', 'await', 'implements', 'package', 'protected', 'static', 'interface',
  'private', 'public'
];

var LITERALS = [
  'null',
  'true',
  'false'
];

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-reserved-words
var RESERVED_WORDS = [].concat(
  KEYWORDS,
  FUTURE_RESERVED_WORDS,
  LITERALS
);

var reservedWordsMap = Object.create(null);
RESERVED_WORDS.forEach(function(k) {
    reservedWordsMap[k] = true;
});

/**
 * This list should not grow as new reserved words are introdued. This list is
 * of words that need to be quoted because ES3-ish browsers do not allow their
 * use as identifier names.
 */
var ES3_FUTURE_RESERVED_WORDS = [
  'enum', 'implements', 'package', 'protected', 'static', 'interface',
  'private', 'public'
];

var ES3_RESERVED_WORDS = [].concat(
  KEYWORDS,
  ES3_FUTURE_RESERVED_WORDS,
  LITERALS
);

var es3ReservedWordsMap = Object.create(null);
ES3_RESERVED_WORDS.forEach(function(k) {
    es3ReservedWordsMap[k] = true;
});

exports.isReservedWord = function(word) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[466864:466902]", functionData => eval(functionData))};

exports.isES3ReservedWord = function(word) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[466948:466989]", functionData => eval(functionData))};

},{}],35:[function(_dereq_,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/*global exports:true*/

var Syntax = _dereq_('esprima-fb').Syntax;
var utils = _dereq_('../src/utils');
var reserverdWordsHelper = _dereq_('./reserved-words-helper');

/**
 * Code adapted from https://github.com/spicyj/es3ify
 * The MIT License (MIT)
 * Copyright (c) 2014 Ben Alpert
 */

function visitProperty(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[467976:468219]", functionData => eval(functionData))}

visitProperty.test = function(node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[468257:468469]", functionData => eval(functionData))};

function visitMemberExpression(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[468532:468832]", functionData => eval(functionData))}

visitMemberExpression.test = function(node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[468878:469043]", functionData => eval(functionData))};

exports.visitorList = [
  visitProperty,
  visitMemberExpression
];

},{"../src/utils":23,"./reserved-words-helper":34,"esprima-fb":9}],36:[function(_dereq_,module,exports){
var esprima = _dereq_('esprima-fb');
var utils = _dereq_('../src/utils');

var Syntax = esprima.Syntax;

function _isFunctionNode(node) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[469356:469519]", functionData => eval(functionData))}

function visitClassProperty(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[469578:469683]", functionData => eval(functionData))}
visitClassProperty.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[469738:469786]", functionData => eval(functionData))};

function visitTypeAlias(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[469842:469908]", functionData => eval(functionData))}
visitTypeAlias.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[469959:470003]", functionData => eval(functionData))};

function visitTypeCast(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[470058:470274]", functionData => eval(functionData))}
visitTypeCast.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[470324:470377]", functionData => eval(functionData))};

function visitInterfaceDeclaration(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[470444:470510]", functionData => eval(functionData))}
visitInterfaceDeclaration.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[470572:470627]", functionData => eval(functionData))};

function visitDeclare(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[470681:470747]", functionData => eval(functionData))}
visitDeclare.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[470796:470988]", functionData => eval(functionData))};

function visitFunctionParametricAnnotation(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[471063:471168]", functionData => eval(functionData))}
visitFunctionParametricAnnotation.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[471238:471398]", functionData => eval(functionData))};

function visitFunctionReturnAnnotation(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[471469:471574]", functionData => eval(functionData))}
visitFunctionReturnAnnotation.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[471640:471720]", functionData => eval(functionData))};

function visitOptionalFunctionParameterAnnotation(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[471802:471926]", functionData => eval(functionData))}
visitOptionalFunctionParameterAnnotation.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[472003:472131]", functionData => eval(functionData))};

function visitTypeAnnotatedIdentifier(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[472201:472336]", functionData => eval(functionData))}
visitTypeAnnotatedIdentifier.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[472401:472469]", functionData => eval(functionData))};

function visitTypeAnnotatedObjectOrArrayPattern(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[472549:472684]", functionData => eval(functionData))}
visitTypeAnnotatedObjectOrArrayPattern.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[472759:472912]", functionData => eval(functionData))};

/**
 * Methods cause trouble, since esprima parses them as a key/value pair, where
 * the location of the value starts at the method body. For example
 * { bar(x:number,...y:Array<number>):number {} }
 * is parsed as
 * { bar: function(x: number, ...y:Array<number>): number {} }
 * except that the location of the FunctionExpression value is 40-something,
 * which is the location of the function body. This means that by the time we
 * visit the params, rest param, and return type organically, we've already
 * catchup()'d passed them.
 */
function visitMethod(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[473508:473867]", functionData => eval(functionData))}

visitMethod.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[473916:474063]", functionData => eval(functionData))};

function visitImportType(traverse, node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[474120:474186]", functionData => eval(functionData))}
visitImportType.test = function(node, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[474238:474309]", functionData => eval(functionData))};

exports.visitorList = [
  visitClassProperty,
  visitDeclare,
  visitImportType,
  visitInterfaceDeclaration,
  visitFunctionParametricAnnotation,
  visitFunctionReturnAnnotation,
  visitMethod,
  visitOptionalFunctionParameterAnnotation,
  visitTypeAlias,
  visitTypeCast,
  visitTypeAnnotatedIdentifier,
  visitTypeAnnotatedObjectOrArrayPattern
];

},{"../src/utils":23,"esprima-fb":9}],37:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
/*global exports:true*/
'use strict';
var Syntax = _dereq_('jstransform').Syntax;
var utils = _dereq_('jstransform/src/utils');

function renderJSXLiteral(object, isLast, state, start, end) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[475231:476681]", functionData => eval(functionData))}

function renderJSXExpressionContainer(traverse, object, isLast, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[476760:477313]", functionData => eval(functionData))}

function quoteAttrName(attr) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[477344:477474]", functionData => eval(functionData))}

function trimLeft(value) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[477501:477541]", functionData => eval(functionData))}

exports.renderJSXExpressionContainer = renderJSXExpressionContainer;
exports.renderJSXLiteral = renderJSXLiteral;
exports.quoteAttrName = quoteAttrName;
exports.trimLeft = trimLeft;

},{"jstransform":22,"jstransform/src/utils":23}],38:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
/*global exports:true*/
'use strict';

var Syntax = _dereq_('jstransform').Syntax;
var utils = _dereq_('jstransform/src/utils');

var renderJSXExpressionContainer =
  _dereq_('./jsx').renderJSXExpressionContainer;
var renderJSXLiteral = _dereq_('./jsx').renderJSXLiteral;
var quoteAttrName = _dereq_('./jsx').quoteAttrName;

var trimLeft = _dereq_('./jsx').trimLeft;

/**
 * Customized desugar processor for React JSX. Currently:
 *
 * <X> </X> => React.createElement(X, null)
 * <X prop="1" /> => React.createElement(X, {prop: '1'}, null)
 * <X prop="2"><Y /></X> => React.createElement(X, {prop:'2'},
 *   React.createElement(Y, null)
 * )
 * <div /> => React.createElement("div", null)
 */

/**
 * Removes all non-whitespace/parenthesis characters
 */
var reNonWhiteParen = /([^\s\(\)])/g;
function stripNonWhiteParen(value) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[478943:478991]", functionData => eval(functionData))}

var tagConvention = /^[a-z]|\-/;
function isTagName(name) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[479051:479089]", functionData => eval(functionData))}

function visitReactTag(traverse, object, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[479145:484785]", functionData => eval(functionData))}

visitReactTag.test = function(object, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[484838:484885]", functionData => eval(functionData))};

exports.visitorList = [
  visitReactTag
];

},{"./jsx":37,"jstransform":22,"jstransform/src/utils":23}],39:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
/*global exports:true*/
'use strict';

var Syntax = _dereq_('jstransform').Syntax;
var utils = _dereq_('jstransform/src/utils');

function addDisplayName(displayName, object, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[485514:486440]", functionData => eval(functionData))}

/**
 * Transforms the following:
 *
 * var MyComponent = React.createClass({
 *    render: ...
 * });
 *
 * into:
 *
 * var MyComponent = React.createClass({
 *    displayName: 'MyComponent',
 *    render: ...
 * });
 *
 * Also catches:
 *
 * MyComponent = React.createClass(...);
 * exports.MyComponent = React.createClass(...);
 * module.exports = {MyComponent: React.createClass(...)};
 */
function visitReactDisplayName(traverse, object, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[486897:487413]", functionData => eval(functionData))}

visitReactDisplayName.test = function(object, path, state) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[487474:487629]", functionData => eval(functionData))};

exports.visitorList = [
  visitReactDisplayName
];

},{"jstransform":22,"jstransform/src/utils":23}],40:[function(_dereq_,module,exports){
/*global exports:true*/

'use strict';

var es6ArrowFunctions =
  _dereq_('jstransform/visitors/es6-arrow-function-visitors');
var es6Classes = _dereq_('jstransform/visitors/es6-class-visitors');
var es6Destructuring =
  _dereq_('jstransform/visitors/es6-destructuring-visitors');
var es6ObjectConciseMethod =
  _dereq_('jstransform/visitors/es6-object-concise-method-visitors');
var es6ObjectShortNotation =
  _dereq_('jstransform/visitors/es6-object-short-notation-visitors');
var es6RestParameters = _dereq_('jstransform/visitors/es6-rest-param-visitors');
var es6Templates = _dereq_('jstransform/visitors/es6-template-visitors');
var es6CallSpread =
  _dereq_('jstransform/visitors/es6-call-spread-visitors');
var es7SpreadProperty =
  _dereq_('jstransform/visitors/es7-spread-property-visitors');
var react = _dereq_('./transforms/react');
var reactDisplayName = _dereq_('./transforms/reactDisplayName');
var reservedWords = _dereq_('jstransform/visitors/reserved-words-visitors');

/**
 * Map from transformName => orderedListOfVisitors.
 */
var transformVisitors = {
  'es6-arrow-functions': es6ArrowFunctions.visitorList,
  'es6-classes': es6Classes.visitorList,
  'es6-destructuring': es6Destructuring.visitorList,
  'es6-object-concise-method': es6ObjectConciseMethod.visitorList,
  'es6-object-short-notation': es6ObjectShortNotation.visitorList,
  'es6-rest-params': es6RestParameters.visitorList,
  'es6-templates': es6Templates.visitorList,
  'es6-call-spread': es6CallSpread.visitorList,
  'es7-spread-property': es7SpreadProperty.visitorList,
  'react': react.visitorList.concat(reactDisplayName.visitorList),
  'reserved-words': reservedWords.visitorList
};

var transformSets = {
  'harmony': [
    'es6-arrow-functions',
    'es6-object-concise-method',
    'es6-object-short-notation',
    'es6-classes',
    'es6-rest-params',
    'es6-templates',
    'es6-destructuring',
    'es6-call-spread',
    'es7-spread-property'
  ],
  'es3': [
    'reserved-words'
  ],
  'react': [
    'react'
  ]
};

/**
 * Specifies the order in which each transform should run.
 */
var transformRunOrder = [
  'reserved-words',
  'es6-arrow-functions',
  'es6-object-concise-method',
  'es6-object-short-notation',
  'es6-classes',
  'es6-rest-params',
  'es6-templates',
  'es6-destructuring',
  'es6-call-spread',
  'es7-spread-property',
  'react'
];

/**
 * Given a list of transform names, return the ordered list of visitors to be
 * passed to the transform() function.
 *
 * @param {array?} excludes
 * @return {array}
 */
function getAllVisitors(excludes) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[490338:490580]", functionData => eval(functionData))}

/**
 * Given a list of visitor set names, return the ordered list of visitors to be
 * passed to jstransform.
 *
 * @param {array}
 * @return {array}
 */
function getVisitorsBySet(sets) {
  var visitorsToInclude = sets.reduce(function(visitors, set) {
    if (!transformSets.hasOwnProperty(set)) {
      throw new Error('Unknown visitor set: ' + set);
    }
    transformSets[set].forEach(function(visitor) {
      visitors[visitor] = true;
    });
    return visitors;
  }, {});

  var visitorList = [];
  for (var i = 0; i < transformRunOrder.length; i++) {
    if (visitorsToInclude.hasOwnProperty(transformRunOrder[i])) {
      visitorList = visitorList.concat(transformVisitors[transformRunOrder[i]]);
    }
  }

  return visitorList;
}

exports.getVisitorsBySet = getVisitorsBySet;
exports.getAllVisitors = getAllVisitors;
exports.transformVisitors = transformVisitors;

},{"./transforms/react":38,"./transforms/reactDisplayName":39,"jstransform/visitors/es6-arrow-function-visitors":24,"jstransform/visitors/es6-call-spread-visitors":25,"jstransform/visitors/es6-class-visitors":26,"jstransform/visitors/es6-destructuring-visitors":27,"jstransform/visitors/es6-object-concise-method-visitors":28,"jstransform/visitors/es6-object-short-notation-visitors":29,"jstransform/visitors/es6-rest-param-visitors":30,"jstransform/visitors/es6-template-visitors":31,"jstransform/visitors/es7-spread-property-visitors":33,"jstransform/visitors/reserved-words-visitors":35}],41:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';
/*eslint-disable no-undef*/
var Buffer = _dereq_('buffer').Buffer;

function inlineSourceMap(sourceMap, sourceCode, sourceFilename) {lacuna_lazy_load("node_modules/react/dist/JSXTransformer.js[492538:492956]", functionData => eval(functionData))}

module.exports = inlineSourceMap;

},{"buffer":3}]},{},[1])(1)
});