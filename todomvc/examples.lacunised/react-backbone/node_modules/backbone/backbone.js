// LACUNA LAZY LOAD FALLBACK
function lacuna_lazy_load(id, callback){
    fetch("http://127.0.0.1:8125/lazyload/", {
        method: "POST",
        headers: { "Accept": "application/json", "Content-Type": "application/json" },
        body: JSON.stringify({id})
    }).then(response => {
        return response.text();
    }).then(callback);
}
//     Backbone.js 1.2.1

//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(factory) {

  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
  // We use `self` instead of `window` for `WebWorker` support.
  var root = (typeof self == 'object' && self.self == self && self) ||
            (typeof global == 'object' && global.global == global && global);

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {lacuna_lazy_load("node_modules/backbone/backbone.js[778:969]", functionData => eval(functionData))});

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore'), $;
    try { $ = require('jquery'); } catch(e) {}
    factory(root, exports, _, $);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to a common array method we'll want to use later.
  var slice = [].slice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.2.1';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {lacuna_lazy_load("node_modules/backbone/backbone.js[2120:2180]", functionData => eval(functionData))};

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... this will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Proxy Underscore methods to a Backbone class' prototype using a
  // particular attribute as the data argument
  var addMethod = function(length, method, attribute) {
    switch (length) {
      case 1: return function() {lacuna_lazy_load("node_modules/backbone/backbone.js[2944:2996]", functionData => eval(functionData))};
      case 2: return function(value) {lacuna_lazy_load("node_modules/backbone/backbone.js[3035:3094]", functionData => eval(functionData))};
      case 3: return function(iteratee, context) {lacuna_lazy_load("node_modules/backbone/backbone.js[3145:3216]", functionData => eval(functionData))};
      case 4: return function(iteratee, defaultVal, context) {lacuna_lazy_load("node_modules/backbone/backbone.js[3279:3362]", functionData => eval(functionData))};
      default: return function() {lacuna_lazy_load("node_modules/backbone/backbone.js[3397:3528]", functionData => eval(functionData))};
    }
  };
  var addUnderscoreMethods = function(Class, methods, attribute) {
    _.each(methods, function(length, method) {
      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
    });
  };

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {};

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Iterates over the standard `event, callback` (as well as the fancy multiple
  // space-separated events `"change blur", callback` and jQuery-style event
  // maps `{event: callback}`), reducing them by manipulating `memo`.
  // Passes a normalized single event name and callback, as well as any
  // optional `opts`.
  var eventsApi = function(iteratee, memo, name, callback, opts) {lacuna_lazy_load("node_modules/backbone/backbone.js[4727:5379]", functionData => eval(functionData))};

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  Events.on = function(name, callback, context) {lacuna_lazy_load("node_modules/backbone/backbone.js[5540:5599]", functionData => eval(functionData))};

  // An internal use `on` function, used to guard the `listening` argument from
  // the public API.
  var internalOn = function(obj, name, callback, context, listening) {lacuna_lazy_load("node_modules/backbone/backbone.js[5772:6081]", functionData => eval(functionData))};

  // Inversion-of-control versions of `on`. Tell *this* object to listen to
  // an event in another object... keeping track of what it's listening to.
  Events.listenTo =  function(obj, name, callback) {lacuna_lazy_load("node_modules/backbone/backbone.js[6287:6980]", functionData => eval(functionData))};

  // The reducing API that adds a callback to the `events` object.
  var onApi = function(events, name, callback, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[7106:7448]", functionData => eval(functionData))};

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  Events.off =  function(name, callback, context) {lacuna_lazy_load("node_modules/backbone/backbone.js[7738:7934]", functionData => eval(functionData))};

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  Events.stopListening =  function(obj, name, callback) {lacuna_lazy_load("node_modules/backbone/backbone.js[8116:8616]", functionData => eval(functionData))};

  // The reducing API that removes a callback from the `events` object.
  var offApi = function(events, name, callback, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[8748:10345]", functionData => eval(functionData))};

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, it will be removed. When multiple events are
  // passed in using the space-separated syntax, the event will fire once for every
  // event you passed in, not once for a combination of all events
  Events.once =  function(name, callback, context) {lacuna_lazy_load("node_modules/backbone/backbone.js[10701:10884]", functionData => eval(functionData))};

  // Inversion-of-control versions of `once`.
  Events.listenToOnce =  function(obj, name, callback) {lacuna_lazy_load("node_modules/backbone/backbone.js[10988:11180]", functionData => eval(functionData))};

  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
  // `offer` unbinds the `onceWrapper` after it has been called.
  var onceMap = function(map, name, callback, offer) {lacuna_lazy_load("node_modules/backbone/backbone.js[11372:11579]", functionData => eval(functionData))};

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.trigger =  function(name) {lacuna_lazy_load("node_modules/backbone/backbone.js[11906:12174]", functionData => eval(functionData))};

  // Handles triggering the appropriate event callbacks.
  var triggerApi = function(objEvents, name, cb, args) {lacuna_lazy_load("node_modules/backbone/backbone.js[12289:12593]", functionData => eval(functionData))};

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {lacuna_lazy_load("node_modules/backbone/backbone.js[12831:13372]", functionData => eval(functionData))};

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[14151:14581]", functionData => eval(functionData))};

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // The prefix is used to create the client id which is used to identify models locally.
    // You may want to override this if you're experiencing name clashes with model ids.
    cidPrefix: 'c',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){lacuna_lazy_load("node_modules/backbone/backbone.js[15348:15350]", functionData => eval(functionData))},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[15440:15486]", functionData => eval(functionData))},

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[15644:15702]", functionData => eval(functionData))},

    // Get the value of an attribute.
    get: function(attr) {lacuna_lazy_load("node_modules/backbone/backbone.js[15767:15810]", functionData => eval(functionData))},

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {lacuna_lazy_load("node_modules/backbone/backbone.js[15891:15937]", functionData => eval(functionData))},

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {lacuna_lazy_load("node_modules/backbone/backbone.js[16058:16102]", functionData => eval(functionData))},

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {lacuna_lazy_load("node_modules/backbone/backbone.js[16197:16261]", functionData => eval(functionData))},

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[16544:18600]", functionData => eval(functionData))},

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[18757:18839]", functionData => eval(functionData))},

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[18932:19089]", functionData => eval(functionData))},

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {lacuna_lazy_load("node_modules/backbone/backbone.js[19280:19384]", functionData => eval(functionData))},

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {lacuna_lazy_load("node_modules/backbone/backbone.js[19851:20229]", functionData => eval(functionData))},

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {lacuna_lazy_load("node_modules/backbone/backbone.js[20373:20491]", functionData => eval(functionData))},

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[20628:20683]", functionData => eval(functionData))},

    // Fetch the model from the server, merging the response with the model's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[20872:21383]", functionData => eval(functionData))},

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[21605:23526]", functionData => eval(functionData))},

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[23787:24541]", functionData => eval(functionData))},

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[24747:25021]", functionData => eval(functionData))},

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[25220:25246]", functionData => eval(functionData))},

    // Create a new model with identical attributes to this one.
    clone: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[25336:25395]", functionData => eval(functionData))},

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[25501:25550]", functionData => eval(functionData))},

    // Check if the model is currently in a valid state.
    isValid: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[25641:25720]", functionData => eval(functionData))},

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[25914:26253]", functionData => eval(functionData))}

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
      omit: 0, chain: 1, isEmpty: 1 };

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  addUnderscoreMethods(Model, modelMethods, 'attributes');

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[28300:28381]", functionData => eval(functionData))},

    // Proxy `Backbone.sync` by default.
    sync: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[28446:28504]", functionData => eval(functionData))},

    // Add a model, or list of models to the set.
    add: function(models, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[28592:28677]", functionData => eval(functionData))},

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[28775:29096]", functionData => eval(functionData))},

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[29445:33298]", functionData => eval(functionData))},

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[33621:34013]", functionData => eval(functionData))},

    // Add a model to the end of the collection.
    push: function(model, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[34100:34175]", functionData => eval(functionData))},

    // Remove a model from the end of the collection.
    pop: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[34259:34352]", functionData => eval(functionData))},

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[34448:34513]", functionData => eval(functionData))},

    // Remove a model from the beginning of the collection.
    shift: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[34605:34684]", functionData => eval(functionData))},

    // Slice out a sub-array of models from the collection.
    slice: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[34769:34826]", functionData => eval(functionData))},

    // Get a model from the set by id.
    get: function(obj) {lacuna_lazy_load("node_modules/backbone/backbone.js[34891:35079]", functionData => eval(functionData))},

    // Get the model at the given index.
    at: function(index) {lacuna_lazy_load("node_modules/backbone/backbone.js[35147:35230]", functionData => eval(functionData))},

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {lacuna_lazy_load("node_modules/backbone/backbone.js[35358:35518]", functionData => eval(functionData))},

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {lacuna_lazy_load("node_modules/backbone/backbone.js[35650:35695]", functionData => eval(functionData))},

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[35902:36374]", functionData => eval(functionData))},

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {lacuna_lazy_load("node_modules/backbone/backbone.js[36464:36520]", functionData => eval(functionData))},

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[36775:37266]", functionData => eval(functionData))},

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[37503:38044]", functionData => eval(functionData))},

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[38234:38260]", functionData => eval(functionData))},

    // Create a new collection with an identical list of models as this one.
    clone: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[38362:38491]", functionData => eval(functionData))},

    // Define how to uniquely identify models in the collection.
    modelId: function (attrs) {lacuna_lazy_load("node_modules/backbone/backbone.js[38589:38658]", functionData => eval(functionData))},

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[39017:39413]", functionData => eval(functionData))},

    // Internal method called by both remove and set.
    // Returns removed models, or false if nothing is removed.
    _removeModels: function(models, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[39578:40095]", functionData => eval(functionData))},

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
    _isModel: function (model) {lacuna_lazy_load("node_modules/backbone/backbone.js[40256:40300]", functionData => eval(functionData))},

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[40412:40598]", functionData => eval(functionData))},

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[40712:40959]", functionData => eval(functionData))},

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[41294:41784]", functionData => eval(functionData))}

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 4,
      foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3,
      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 2,
      contains: 2, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
      isEmpty: 1, chain: 1, sample: 3, partition: 3 };

  // Mix in each Underscore method as a proxy to `Collection#models`.
  addUnderscoreMethods(Collection, collectionMethods, 'models');

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    if (!_[method]) return;
    Collection.prototype[method] = function(value, context) {lacuna_lazy_load("node_modules/backbone/backbone.js[42926:43100]", functionData => eval(functionData))};
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[43860:44021]", functionData => eval(functionData))};

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {lacuna_lazy_load("node_modules/backbone/backbone.js[44654:44699]", functionData => eval(functionData))},

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){lacuna_lazy_load("node_modules/backbone/backbone.js[44834:44836]", functionData => eval(functionData))},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[45078:45104]", functionData => eval(functionData))},

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[45254:45337]", functionData => eval(functionData))},

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[45543:45575]", functionData => eval(functionData))},

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function(element) {lacuna_lazy_load("node_modules/backbone/backbone.js[45727:45846]", functionData => eval(functionData))},

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
    _setElement: function(el) {lacuna_lazy_load("node_modules/backbone/backbone.js[46205:46306]", functionData => eval(functionData))},

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function(events) {lacuna_lazy_load("node_modules/backbone/backbone.js[46807:47231]", functionData => eval(functionData))},

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function(eventName, selector, listener) {lacuna_lazy_load("node_modules/backbone/backbone.js[47523:47630]", functionData => eval(functionData))},

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[47880:47970]", functionData => eval(functionData))},

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function(eventName, selector, listener) {lacuna_lazy_load("node_modules/backbone/backbone.js[48162:48270]", functionData => eval(functionData))},

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function(tagName) {lacuna_lazy_load("node_modules/backbone/backbone.js[48443:48496]", functionData => eval(functionData))},

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[48803:49203]", functionData => eval(functionData))},

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function(attributes) {lacuna_lazy_load("node_modules/backbone/backbone.js[49379:49419]", functionData => eval(functionData))}

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[50439:52620]", functionData => eval(functionData))};

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {lacuna_lazy_load("node_modules/backbone/backbone.js[53004:53066]", functionData => eval(functionData))};

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[53314:53472]", functionData => eval(functionData))};

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){lacuna_lazy_load("node_modules/backbone/backbone.js[53981:53983]", functionData => eval(functionData))},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {lacuna_lazy_load("node_modules/backbone/backbone.js[54223:54854]", functionData => eval(functionData))},

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args, name) {lacuna_lazy_load("node_modules/backbone/backbone.js[55042:55097]", functionData => eval(functionData))},

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[55221:55299]", functionData => eval(functionData))},

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[55543:55777]", functionData => eval(functionData))},

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {lacuna_lazy_load("node_modules/backbone/backbone.js[55937:56313]", functionData => eval(functionData))},

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {lacuna_lazy_load("node_modules/backbone/backbone.js[56581:56855]", functionData => eval(functionData))}

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[58188:58315]", functionData => eval(functionData))},

    // Does the pathname match the root?
    matchRoot: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[58385:58547]", functionData => eval(functionData))},

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function(fragment) {lacuna_lazy_load("node_modules/backbone/backbone.js[58781:58847]", functionData => eval(functionData))},

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[58978:59092]", functionData => eval(functionData))},

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {lacuna_lazy_load("node_modules/backbone/backbone.js[59265:59374]", functionData => eval(functionData))},

    // Get the pathname and search params, without the root.
    getPath: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[59462:59654]", functionData => eval(functionData))},

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function(fragment) {lacuna_lazy_load("node_modules/backbone/backbone.js[59769:60025]", functionData => eval(functionData))},

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {lacuna_lazy_load("node_modules/backbone/backbone.js[60189:63564]", functionData => eval(functionData))},

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {lacuna_lazy_load("node_modules/backbone/backbone.js[63721:64557]", functionData => eval(functionData))},

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {lacuna_lazy_load("node_modules/backbone/backbone.js[64712:64784]", functionData => eval(functionData))},

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {lacuna_lazy_load("node_modules/backbone/backbone.js[64946:65366]", functionData => eval(functionData))},

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {lacuna_lazy_load("node_modules/backbone/backbone.js[65574:65928]", functionData => eval(functionData))},

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[66410:68262]", functionData => eval(functionData))},

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {lacuna_lazy_load("node_modules/backbone/backbone.js[68440:68715]", functionData => eval(functionData))}

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent` constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {lacuna_lazy_load("node_modules/backbone/backbone.js[70436:70512]", functionData => eval(functionData))};

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {lacuna_lazy_load("node_modules/backbone/backbone.js[70624:70824]", functionData => eval(functionData))};

  return Backbone;

}));
