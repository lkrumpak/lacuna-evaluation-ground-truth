{
    "node_modules/todomvc-common/base.js[197:548]": "\n\t\t\tif (!object) {\n\t\t\t\treturn object;\n\t\t\t}\n\t\t\tfor (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {\n\t\t\t\tvar iterable = arguments[argsIndex];\n\t\t\t\tif (iterable) {\n\t\t\t\t\tfor (var key in iterable) {\n\t\t\t\t\t\tif (object[key] == null) {\n\t\t\t\t\t\t\tobject[key] = iterable[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t",
    "node_modules/todomvc-common/base.js[1588:3332]": "\n\t\t\tvar render;\n\t\t\tsettings = _.defaults({}, settings, _.templateSettings);\n\n\t\t\t// Combine delimiters into one regular expression via alternation.\n\t\t\tvar matcher = new RegExp([\n\t\t\t\t(settings.escape || noMatch).source,\n\t\t\t\t(settings.interpolate || noMatch).source,\n\t\t\t\t(settings.evaluate || noMatch).source\n\t\t\t].join('|') + '|$', 'g');\n\n\t\t\t// Compile the template source, escaping string literals appropriately.\n\t\t\tvar index = 0;\n\t\t\tvar source = \"__p+='\";\n\t\t\ttext.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n\t\t\t\tsource += text.slice(index, offset)\n\t\t\t\t\t.replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n\t\t\t\tif (escape) {\n\t\t\t\t\tsource += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n\t\t\t\t}\n\t\t\t\tif (interpolate) {\n\t\t\t\t\tsource += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n\t\t\t\t}\n\t\t\t\tif (evaluate) {\n\t\t\t\t\tsource += \"';\\n\" + evaluate + \"\\n__p+='\";\n\t\t\t\t}\n\t\t\t\tindex = offset + match.length;\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tsource += \"';\\n\";\n\n\t\t\t// If a variable is not specified, place data values in local scope.\n\t\t\tif (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n\t\t\tsource = \"var __t,__p='',__j=Array.prototype.join,\" +\n\t\t\t\t\"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n\t\t\t\tsource + \"return __p;\\n\";\n\n\t\t\ttry {\n\t\t\t\trender = new Function(settings.variable || 'obj', '_', source);\n\t\t\t} catch (e) {\n\t\t\t\te.source = source;\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tif (data) return render(data, _);\n\t\t\tvar template = function(data) {\n\t\t\t\treturn render.call(this, data, _);\n\t\t\t};\n\n\t\t\t// Provide the compiled function source as a convenience for precompilation.\n\t\t\ttemplate.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n\t\t\treturn template;\n\t\t",
    "node_modules/todomvc-common/base.js[3484:3613]": "var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)",
    "node_modules/todomvc-common/base.js[4361:5286]": "\n\t\tif (!(this instanceof Learn)) {\n\t\t\treturn new Learn(learnJSON, config);\n\t\t}\n\n\t\tvar template, framework;\n\n\t\tif (typeof learnJSON !== 'object') {\n\t\t\ttry {\n\t\t\t\tlearnJSON = JSON.parse(learnJSON);\n\t\t\t} catch (e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (config) {\n\t\t\ttemplate = config.template;\n\t\t\tframework = config.framework;\n\t\t}\n\n\t\tif (!template && learnJSON.templates) {\n\t\t\ttemplate = learnJSON.templates.todomvc;\n\t\t}\n\n\t\tif (!framework && document.querySelector('[data-framework]')) {\n\t\t\tframework = document.querySelector('[data-framework]').dataset.framework;\n\t\t}\n\n\t\tthis.template = template;\n\n\t\tif (learnJSON.backend) {\n\t\t\tthis.frameworkJSON = learnJSON.backend;\n\t\t\tthis.frameworkJSON.issueLabel = framework;\n\t\t\tthis.append({\n\t\t\t\tbackend: true\n\t\t\t});\n\t\t} else if (learnJSON[framework]) {\n\t\t\tthis.frameworkJSON = learnJSON[framework];\n\t\t\tthis.frameworkJSON.issueLabel = framework;\n\t\t\tthis.append();\n\t\t}\n\n\t\tthis.fetchIssueCount();\n\t",
    "node_modules/todomvc-common/base.js[5330:6369]": "\n\t\tvar aside = document.createElement('aside');\n\t\taside.innerHTML = _.template(this.template, this.frameworkJSON);\n\t\taside.className = 'learn';\n\n\t\tif (opts && opts.backend) {\n\t\t\t// Remove demo link\n\t\t\tvar sourceLinks = aside.querySelector('.source-links');\n\t\t\tvar heading = sourceLinks.firstElementChild;\n\t\t\tvar sourceLink = sourceLinks.lastElementChild;\n\t\t\t// Correct link path\n\t\t\tvar href = sourceLink.getAttribute('href');\n\t\t\tsourceLink.setAttribute('href', href.substr(href.lastIndexOf('http')));\n\t\t\tsourceLinks.innerHTML = heading.outerHTML + sourceLink.outerHTML;\n\t\t} else {\n\t\t\t// Localize demo links\n\t\t\tvar demoLinks = aside.querySelectorAll('.demo-link');\n\t\t\tArray.prototype.forEach.call(demoLinks, function (demoLink) {\n\t\t\t\tif (demoLink.getAttribute('href').substr(0, 4) !== 'http') {\n\t\t\t\t\tdemoLink.setAttribute('href', findRoot() + demoLink.getAttribute('href'));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tdocument.body.className = (document.body.className + ' learn-bar').trim();\n\t\tdocument.body.insertAdjacentHTML('afterBegin', aside.outerHTML);\n\t",
    "node_modules/todomvc-common/base.js[6419:7038]": "\n\t\tvar issueLink = document.getElementById('issue-count-link');\n\t\tif (issueLink) {\n\t\t\tvar url = issueLink.href.replace('https://github.com', 'https://api.github.com/repos');\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\txhr.open('GET', url, true);\n\t\t\txhr.onload = function (e) {\n\t\t\t\tvar parsedResponse = JSON.parse(e.target.responseText);\n\t\t\t\tif (parsedResponse instanceof Array) {\n\t\t\t\t\tvar count = parsedResponse.length\n\t\t\t\t\tif (count !== 0) {\n\t\t\t\t\t\tissueLink.innerHTML = 'This app has ' + count + ' open issues';\n\t\t\t\t\t\tdocument.getElementById('issue-count').style.display = 'inline';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\txhr.send();\n\t\t}\n\t",
    "node_modules/requirejs/require.js[4852:4878]": "\n        throw err;\n    ",
    "node_modules/requirejs/require.js[5555:5797]": "\n        var e = new Error(msg + '\\nhttp://requirejs.org/docs/errors.html#' + id);\n        e.requireType = id;\n        e.requireModules = requireModules;\n        if (err) {\n            e.originalError = err;\n        }\n        return e;\n    ",
    "node_modules/requirejs/require.js[13238:13682]": "\n            if (isBrowser) {\n                each(scripts(), function (scriptNode) {\n                    if (scriptNode.getAttribute('data-requiremodule') === name &&\n                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {\n                        scriptNode.parentNode.removeChild(scriptNode);\n                        return true;\n                    }\n                });\n            }\n        ",
    "node_modules/requirejs/require.js[13721:14321]": "\n            var pathConfig = getOwn(config.paths, id);\n            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {\n                //Pop off the first array value, since it failed, and\n                //retry\n                pathConfig.shift();\n                context.require.undef(id);\n\n                //Custom require that does not do map translation, since\n                //ID is \"absolute\", already mapped/resolved.\n                context.makeRequire(null, {\n                    skipMap: true\n                })([id]);\n\n                return true;\n            }\n        ",
    "node_modules/requirejs/require.js[16714:16815]": "\n                            return normalize(name, parentName, applyMap);\n                        ",
    "node_modules/requirejs/require.js[19918:20642]": "\n            var ids = err.requireModules,\n                notified = false;\n\n            if (errback) {\n                errback(err);\n            } else {\n                each(ids, function (id) {\n                    var mod = getOwn(registry, id);\n                    if (mod) {\n                        //Set error on module, so it skips timeout checks.\n                        mod.error = err;\n                        if (mod.events.error) {\n                            notified = true;\n                            mod.emit('error', err);\n                        }\n                    }\n                });\n\n                if (!notified) {\n                    req.onError(err);\n                }\n            }\n        ",
    "node_modules/requirejs/require.js[21576:21921]": "\n                mod.usingExports = true;\n                if (mod.map.isDefine) {\n                    if (mod.exports) {\n                        return (defined[mod.map.id] = mod.exports);\n                    } else {\n                        return (mod.exports = defined[mod.map.id] = {});\n                    }\n                }\n            ",
    "node_modules/requirejs/require.js[21960:22457]": "\n                if (mod.module) {\n                    return mod.module;\n                } else {\n                    return (mod.module = {\n                        id: mod.map.id,\n                        uri: mod.map.url,\n                        config: function () {\n                            return  getOwn(config.config, mod.map.id) || {};\n                        },\n                        exports: mod.exports || (mod.exports = {})\n                    });\n                }\n            ",
    "node_modules/requirejs/require.js[28614:28686]": "\n                        this.emit('error', err);\n                    ",
    "node_modules/requirejs/require.js[37021:37126]": "\n                                return normalize(name, parentName, true);\n                            ",
    "node_modules/requirejs/require.js[38282:38378]": "\n                                    this.emit('error', err);\n                                ",
    "node_modules/requirejs/require.js[39187:39797]": "\n                        this.inited = true;\n                        this.error = err;\n                        err.requireModules = [id];\n\n                        //Remove temp unnormalized modules for this module,\n                        //since they will never be resolved otherwise now.\n                        eachProp(registry, function (mod) {\n                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {\n                                cleanRegistry(mod.map.id);\n                            }\n                        });\n\n                        onError(err);\n                    ",
    "node_modules/requirejs/require.js[44838:44926]": "\n                                this.emit('error', err);\n                            ",
    "node_modules/requirejs/require.js[50683:50915]": "\n                        each(value, function (v) {\n                            if (v !== prop) {\n                                bundlesMap[v] = prop;\n                            }\n                        });\n                    ",
    "node_modules/requirejs/require.js[51746:52718]": "\n                        var location, name;\n\n                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;\n\n                        name = pkgObj.name;\n                        location = pkgObj.location;\n                        if (location) {\n                            config.paths[name] = pkgObj.location;\n                        }\n\n                        //Save pointer to main module ID for pkg name.\n                        //Remove leading dot in main, so main paths are normalized,\n                        //and remove any trailing .js, since different package\n                        //envs have different conventions: some use a module name,\n                        //some use a file name.\n                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')\n                                     .replace(currDirRegExp, '')\n                                     .replace(jsSuffixRegExp, '');\n                    ",
    "node_modules/requirejs/require.js[58341:58456]": "\n                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);\n                    ",
    "node_modules/requirejs/require.js[58504:58677]": "\n                        id = makeModuleMap(id, relMap, false, true).id;\n                        return hasProp(defined, id) || hasProp(registry, id);\n                    ",
    "node_modules/requirejs/require.js[58847:60189]": "\n                        //Bind any waiting define() calls to this context,\n                        //fix for #408\n                        takeGlobalQueue();\n\n                        var map = makeModuleMap(id, relMap, true),\n                            mod = getOwn(registry, id);\n\n                        removeScript(id);\n\n                        delete defined[id];\n                        delete urlFetched[map.url];\n                        delete undefEvents[id];\n\n                        //Clean queued defines too. Go backwards\n                        //in array so that the splices do not\n                        //mess up the iteration.\n                        eachReverse(defQueue, function(args, i) {\n                            if(args[0] === id) {\n                                defQueue.splice(i, 1);\n                            }\n                        });\n\n                        if (mod) {\n                            //Hold on to listeners in case the\n                            //module will be attempted to be reloaded\n                            //using a different config.\n                            if (mod.events.defined) {\n                                undefEvents[id] = mod.events;\n                            }\n\n                            cleanRegistry(id);\n                        }\n                    ",
    "node_modules/requirejs/require.js[68213:68452]": "\n                var data = getScriptData(evt);\n                if (!hasPathFallback(data.id)) {\n                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));\n                }\n            ",
    "node_modules/requirejs/require.js[70761:70770]": " fn(); ",
    "node_modules/requirejs/require.js[71600:71719]": "\n            var ctx = contexts[defContextName];\n            return ctx.require[prop].apply(ctx, arguments);\n        ",
    "node_modules/requirejs/require.js[78005:78363]": "\n        if (interactiveScript && interactiveScript.readyState === 'interactive') {\n            return interactiveScript;\n        }\n\n        eachReverse(scripts(), function (script) {\n            if (script.readyState === 'interactive') {\n                return (interactiveScript = script);\n            }\n        });\n        return interactiveScript;\n    ",
    "js/libs/lavaca.js[6051:6377]": "\n      if (!this.succeeded && !this.failed) {\n        this.failed = true;\n        this.rejectArgs = [].slice.call(arguments, 0);\n        var i = -1,\n            callback;\n        while (!!(callback = this.rejectedQueue[++i])) {\n          callback.apply(this.thisp, this.rejectArgs);\n        }\n      }\n      return this;\n    ",
    "js/libs/lavaca.js[7258:7323]": "\n              self.reject.apply(self, arguments);\n            ",
    "js/libs/lavaca.js[7938:7991]": "\n        self.reject.apply(self, arguments);\n      ",
    "js/libs/lavaca.js[9742:9769]": "\n    return !!Cordova;\n  ",
    "js/libs/lavaca.js[10688:10903]": "\n    var promise = new Promise(window);\n    if (Cordova) {\n      Cordova.exec(promise.resolver(), promise.rejector(), className, methodName, args);\n    } else {\n      promise.reject();\n    }\n    return promise;\n  ",
    "js/libs/lavaca.js[18773:19847]": "\n      var calls = this.callbacks,\n          list,\n          handler,\n          i = -1,\n          newList,\n          isCallback,\n          isThisp;\n      if (!type) {\n        delete this.callbacks;\n      } else if (calls) {\n        if (!callback) {\n          delete calls[type];\n        } else {\n          list = calls[type];\n          if (list) {\n            newList = calls[type] = [];\n            while (!!(handler = list[++i])) {\n              isCallback = handler.fn === callback ||\n                           handler.fn.fn === callback ||\n                           (handler.fn.guid && handler.fn.guid === callback.guid) || // Check if is jQuery proxy of callback\n                           (handler.fn._zid && handler.fn._zid === callback._zid); // Check if is Zepto proxy of callback\n              isThisp = thisp && (handler.thisp === thisp || handler.fn.thisp === thisp);\n              if (!isCallback || (thisp && !isThisp)) {\n                newList[newList.length] = handler;\n              }\n            }\n          }\n        }\n      }\n      return this;\n    ",
    "js/libs/lavaca.js[22348:22642]": "\n      if (Device.isCordova()) {\n        return Device\n          .exec('ChildBrowser', 'showWebPage', [loc])\n          .error(function() {\n            window.location.href = loc;\n          });\n      } else {\n        window.open(loc);\n        return new Promise(window).resolve();\n      }\n    ",
    "js/libs/lavaca.js[22804:22866]": "\n      return Device.exec('ChildBrowser', 'close', []);\n    ",
    "js/libs/lavaca.js[23017:25809]": "\n  var $ = require('$');\n  var Detection = {};\n  Detection.agent = navigator.userAgent.toLowerCase();\n  Detection.scrWidth = screen.width;\n  Detection.scrHeight = screen.height;\n  Detection.viewportWidth = window.innerWidth;\n  Detection.viewportHeight = window.innerHeight;\n  Detection.elemWidth = document.documentElement.clientWidth;\n  Detection.elemHeight = document.documentElement.clientHeight;\n  Detection.otherBrowser = (Detection.agent.search(/series60/i) > -1) || (Detection.agent.search(/symbian/i) > -1) || (Detection.agent.search(/windows\\sce/i) > -1) || (Detection.agent.search(/blackberry/i) > -1);\n  Detection.mobileOS = typeof orientation !== 'undefined';\n  Detection.touchOS = 'ontouchstart' in document.documentElement;\n  Detection.blackberry = Detection.agent.search(/blackberry/i) > -1;\n  Detection.ipad = Detection.agent.search(/ipad/i) > -1;\n  Detection.ipod = Detection.agent.search(/ipod/i) > -1;\n  Detection.iphone = Detection.agent.search(/iphone/i) > -1;\n  Detection.palm = Detection.agent.search(/palm/i) > -1;\n  Detection.symbian = Detection.agent.search(/symbian/i) > -1;\n  Detection.iOS = Detection.iphone || Detection.ipod || Detection.ipad;\n  Detection.iOS5 = Detection.iOS && Detection.agent.search(/os 5_/i) > 0;\n  Detection.iOSChrome = Detection.iOS && Detection.agent.search(/CriOS/i) > 0;\n  Detection.android = (Detection.agent.search(/android/i) > -1) || (!Detection.iOS && !Detection.otherBrowser && Detection.touchOS && Detection.mobileOS);\n  Detection.android2 = Detection.android && (Detection.agent.search(/android\\s2/i) > -1);\n  Detection.isMobile = Detection.android || Detection.iOS || Detection.mobileOS || Detection.touchOS;\n  Detection.android23AndBelow = (function() {\n    var matches = Detection.agent.match(/android\\s(\\d)\\.(\\d)/i);\n    var vi, vd;\n    if (Array.isArray(matches) && matches.length === 3) {\n      vi = parseInt(matches[1], 10);\n      vd = parseInt(matches[2], 10);\n      return (vi === 2 && vd < 3) || vi < 2;\n    }\n    return false;\n  }());\n  Detection.iOS4AndBelow = (function() {\n    var matches = Detection.agent.match(/os\\s(\\d)_/i);\n    var v;\n    if (Array.isArray(matches) && matches.length === 2) {\n      v = parseInt(matches[1], 10);\n      return v <= 4;\n    }\n    return false;\n  }());\n  Detection.addCustomDetection = function(condition, feature, selector) {\n    var el;\n    if (Detection.hasOwnProperty(feature)) {\n      throw Error('Namespace \"' + feature + '\" is already taken by Detection module');\n    }\n    Detection[feature] = condition;\n    if (selector !== null) {\n      el = selector ? $(selector) : $(document.documentElement);\n      el.toggleClass(feature, typeof condition === 'function' ? condition() : condition);\n    }\n  };\n  Detection.animationEnabled = !Detection.android;\n  return Detection;\n",
    "js/libs/lavaca.js[25905:28304]": "\n\n  var $ = require('$'),\n      Cordova = require('cordova'),\n      Promise = require('lavaca/util/Promise');\n\n  /**\n   * Static utility type for working with Cordova (aka PhoneGap) and other non-standard native functionality\n   * @class lavaca.env.Device\n   */\n\n  var _initHasRun = false,\n      _onInit = [];\n\n  var Device = {};\n\n  /**\n   * Indicates whether or not the app is being run through Cordova\n   * @method isCordova\n   * @static\n   *\n   * @return {Boolean}  True if app is being run through Cordova\n   */\n  Device.isCordova = function() {\n    return !!Cordova;\n  };\n  /**\n   * Registers a plugin to be initialized when the device is ready\n   * @method register\n   * @static\n   *\n   * @param {String} name\n   * @param {Function} TPlugin  The plugin to register. The plugin should be a constructor function\n   */\n  Device.register = function(name, TPlugin) {\n    function install() {\n      if (!window.plugins) {\n        window.plugins = {};\n      }\n      window.plugins[name] = new TPlugin();\n    }\n    if (_initHasRun) {\n      install();\n    } else {\n      _onInit.push(install);\n    }\n  };\n\n  /**\n   * Executes a Cordova command, if Cordova is available\n   * @method exec\n   * @static\n   *\n   * @param {String} className  The name of the native class\n   * @param {String} methodName  The name of the class method to call\n   * @param {Array} args  Arguments to pass the method\n   * @return {Lavaca.util.Promise}  A promise\n   */\n  Device.exec = function(className, methodName, args) {\n    var promise = new Promise(window);\n    if (Cordova) {\n      Cordova.exec(promise.resolver(), promise.rejector(), className, methodName, args);\n    } else {\n      promise.reject();\n    }\n    return promise;\n  };\n\n  /**\n   * Executes a callback when the device is ready to be used\n   * @method init\n   * @static\n   *\n   * @param {Function} callback  The handler to execute when the device is ready\n   */\n  Device.init = function(callback) {\n    if (!Cordova) {\n      $(document).ready(callback);\n    }\n    else if (document.addEventListener) {\n      // Android fix\n      document.addEventListener('deviceready', callback, false);\n    } else {\n      $(document).on('deviceready', callback);\n    }\n  };\n\n  $(document).ready(function() {\n    var i = -1,\n        installPlugin;\n    while (!!(installPlugin = _onInit[++i])) {\n      installPlugin();\n    }\n    _initHasRun = true;\n  });\n\n  return Device;\n\n",
    "js/libs/lavaca.js[28426:33579]": "\n\n  var Disposable = require('lavaca/util/Disposable'),\n      deepMixIn = require('mout/object/deepMixIn');\n\n  /**\n   * Basic event dispatcher type\n   * @class lavaca.events.EventDispatcher\n   * @extends lavaca.util.Disposable\n   * @constructor\n   *\n   */\n  var EventDispatcher = Disposable.extend({\n    /**\n     * When true, do not fire events\n     * @property suppressEvents\n     * @type Boolean\n     * @default false\n     *\n     */\n    suppressEvents: false,\n    /**\n     * Bind an event handler to this object\n     * @method on\n     *\n     * @param {String} type  The name of the event\n     * @param {Function} callback  The function to execute when the event occurs\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    /**\n     * Bind an event handler to this object\n     * @method on\n     *\n     * @param {String} type  The name of the event\n     * @param {Function} callback  The function to execute when the event occurs\n     * @param {Object} thisp  The context of the handler\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    on: function(type, callback, thisp) {\n      var calls = this.callbacks || (this.callbacks = {}),\n          list = calls[type] || (calls[type] = []);\n      list[list.length] = {fn: callback, thisp: thisp};\n      return this;\n    },\n    /**\n     * Unbinds all event handler from this object\n     * @method off\n     *\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    /**\n     * Unbinds all event handlers for an event\n     * @method off\n     *\n     * @param {String} type  The name of the event\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    /**\n     * Unbinds a specific event handler\n     * @method off\n     *\n     * @param {String} type  The name of the event\n     * @param {Function} callback  The function handling the event\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    /**\n     * Unbinds a specific event handler\n     * @method off\n     *\n     * @param {String} type  The name of the event\n     * @param {Function} callback  The function handling the event\n     * @param {Object} thisp  The context of the handler\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    off: function(type, callback, thisp) {\n      var calls = this.callbacks,\n          list,\n          handler,\n          i = -1,\n          newList,\n          isCallback,\n          isThisp;\n      if (!type) {\n        delete this.callbacks;\n      } else if (calls) {\n        if (!callback) {\n          delete calls[type];\n        } else {\n          list = calls[type];\n          if (list) {\n            newList = calls[type] = [];\n            while (!!(handler = list[++i])) {\n              isCallback = handler.fn === callback ||\n                           handler.fn.fn === callback ||\n                           (handler.fn.guid && handler.fn.guid === callback.guid) || // Check if is jQuery proxy of callback\n                           (handler.fn._zid && handler.fn._zid === callback._zid); // Check if is Zepto proxy of callback\n              isThisp = thisp && (handler.thisp === thisp || handler.fn.thisp === thisp);\n              if (!isCallback || (thisp && !isThisp)) {\n                newList[newList.length] = handler;\n              }\n            }\n          }\n        }\n      }\n      return this;\n    },\n    /**\n     * Dispatches an event\n     * @method trigger\n     *\n     * @param {String} type  The type of event to dispatch\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    /**\n     * Dispactches an event with additional parameters\n     * @method trigger\n     *\n     * @param {String} type  The type of event to dispatch\n     * @param {Object} params  Additional data points to add to the event\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    trigger: function(type, params) {\n      if (!this.suppressEvents && this.callbacks) {\n        var list = this.callbacks[type],\n            event = this.createEvent(type, params),\n            i = -1,\n            handler;\n        if (list) {\n          while (!!(handler = list[++i])) {\n            handler.fn.apply(handler.thisp || this, [event]);\n          }\n        }\n      }\n      return this;\n    },\n    /**\n     * Creates an event object\n     * @method createEvent\n     *\n     * @param {String} type  The type of event to create\n     * @return {Object}  The event object\n     */\n     /**\n     * Creates an event object with additional params\n     * @method createEvent\n     *\n     * @param {String} type  The type of event to create\n     * @param {Object} params  Additional data points to add to the event\n     * @return {Object}  The event object\n     */\n    createEvent: function(type, params) {\n      return deepMixIn({}, params || {}, {\n        type: type,\n        target: params && params.target ? params.target : this,\n        currentTarget: this\n      });\n    }\n  });\n\n  return EventDispatcher;\n\n",
    "js/libs/lavaca.js[33646:47599]": "\n\n  var $ = require('$');\n\n  var _props = {\n        transform: 'transform',\n        webkitTransform: '-webkit-transform',\n        MozTransform: '-moz-transform',\n        OTransform: '-o-transform',\n        MSTransform: '-ms-transform'\n      },\n      _prop,\n      _cssProp,\n      _3d = false,\n      UNDEFINED;\n\n  var Transform = {};\n\n  (function() {\n    var style = document.createElement('div').style,\n        s;\n    for (s in _props) {\n      if (s in style) {\n        _prop = s;\n        _cssProp = _props[s];\n        style[s] = 'translate3d(0,0,0)';\n        _3d = style[s].indexOf('translate3d') > -1 && navigator.userAgent.indexOf('Android') === -1;\n        break;\n      }\n    }\n  })();\n\n  function _isUndefined(value) {\n    return value === UNDEFINED;\n  }\n\n  function _toOriginUnit(v) {\n    return typeof v === 'number' ? v * 100 + '%' : v;\n  }\n\n  function _scrubRotateValue(v) {\n    return typeof v === 'number' ? v + 'deg' : v;\n  }\n\n  function _scrubTranslateValue(v) {\n    return typeof v === 'number' ? v + 'px' : v;\n  }\n\n  function _scrubScaleValue(v) {\n    return typeof v === 'number' ? v + ',' + v : v;\n  }\n\n  function _scrubTransformValue(prop, value) {\n    var isRotate = prop.indexOf('rotate') === 0,\n        isScale = prop === 'scale',\n        isTranslate = prop.indexOf('translate') === 0,\n        //isAxisSpecific = /(X|Y|Z)$/.test(prop),\n        p,\n        css = [];\n    if (typeof value === 'object') {\n      for (p in value) {\n        css.push(prop\n          + p.toUpperCase()\n          + '('\n          + (isTranslate\n              ? _scrubTranslateValue(value[p])\n              : isRotate\n                ? _scrubRotateValue(value[p])\n                : isScale\n                  ? _scrubScaleValue(value[p])\n                  : value[p])\n          + ')');\n      }\n    } else {\n      if (isScale) {\n        value = _scrubScaleValue(value);\n      } else if (isRotate) {\n        value = _scrubRotateValue(value);\n      } else if (isTranslate) {\n        value = _scrubTranslateValue(value);\n      }\n      css.push(prop + '(' + value + ')');\n    }\n    return css.join(' ');\n  }\n\n  /**\n   * Static utility type for working with CSS transforms\n   * @class lavaca.fx.Transform\n   */\n\n  /**\n   * Whether or not transforms are supported by the browser\n   * @method isSupported\n   * @static\n   *\n   * @return {Boolean}  True when transforms are supported\n   */\n  Transform.isSupported = function() {\n    return !!_prop;\n  };\n\n  /**\n   * Whether or not 3D transforms are supported by the browser\n   * @method is3dSupported\n   * @static\n   *\n   * @return {Boolean}  True when 3D transforms are supported\n   */\n  Transform.is3dSupported = function() {\n    return _3d;\n  };\n\n  /**\n   * Converts a transform hash into a CSS string\n   * @method toCSS\n   * @static\n   *\n   * @param {Object} opts  A hash of CSS transform values, with properties in\n   *      the form {translateX: 1, translateY: 1} or {translate: {x: 1, y: 1}}\n   * @opt {Object} translate  An object or string containing the translation values\n   * @opt {Object} translateX  A string (in any unit) or number (in pixels) representing the X translation value\n   * @opt {Object} translateY  A string (in any unit) or number (in pixels) representing the Y translation value\n   * @opt {Object} translateZ  A string (in any unit) or number (in pixels) representing the Z translation value\n   * @opt {String} translate3d  A string containing the 3D translation values\n   * @opt {Object} rotate  An object, string, or number (in degrees) containing the rotation value(s)\n   * @opt {Object} rotateX  A string (in any unit) or number (in degrees) representing the X rotation value\n   * @opt {Object} rotateY  A string (in any unit) or number (in degrees) representing the Y rotation value\n   * @opt {Object} rotateZ  A string (in any unit) or number (in degrees) representing the Z rotation value\n   * @opt {String} rotate3d  A string containing the 3D rotation values\n   * @opt {Object} scale  An object, string or number (in percentage points) containing the scale value(s)\n   * @opt {Object} scaleX  A string (in any unit) or number (in percentage points) representing the X scale value\n   * @opt {Object} scaleY  A string (in any unit) or number (in percentage points) representing the Y scale value\n   * @opt {Object} scaleZ  A string (in any unit) or number (in percentage points) representing the Z scale value\n   * @opt {String} scale3d  Astring containing the 3D scale values\n   * @opt {Object} skew  An object or string containing the skew values\n   * @opt {Object} skewX  A string (in any unit) or number (in pixels) representing the X skew value\n   * @opt {Object} skewY  A string (in any unit) or number (in pixels) representing the Y skew value\n   * @opt {String} matrix  A string containing the matrix transform values\n   * @opt {String} matrix3d  A string containing the 3D matrix transform values\n   * @opt {String} perspective  A string containing the perspective transform values\n   * @return {String}  The generated CSS string\n   */\n  Transform.toCSS = function(opts) {\n    var css = [],\n        prop;\n    if (typeof opts === 'object') {\n      for (prop in opts) {\n        css.push(_scrubTransformValue(prop, opts[prop]));\n      }\n    } else {\n      css.push(opts);\n    }\n    return css.join(' ');\n  };\n\n  /**\n   * Gets the name of the transform CSS property\n   * @method cssProperty\n   * @static\n   *\n   * @return {String}  The name of the CSS property\n   */\n  Transform.cssProperty = function() {\n    return _cssProp;\n  };\n\n  /**\n   * Transforms an element\n   * @method $.fn.transform\n   *\n   * @param {String} value  The CSS transform string\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  /**\n   * Transforms an element\n   * @method $.fn.transform\n   *\n   * @param {Object} opt  A hash of CSS transform values, with properties in\n   *      the form {translateX: 1, translateY: 1} or {translate: {x: 1, y: 1}}\n   * @opt {Object} translate  An object or string containing the translation values\n   * @opt {Object} translateX  A string (in any unit) or number (in pixels) representing the X translation value\n   * @opt {Object} translateY  A string (in any unit) or number (in pixels) representing the Y translation value\n   * @opt {Object} translateZ  A string (in any unit) or number (in pixels) representing the Z translation value\n   * @opt {String} translate3d  A string containing the 3D translation values\n   * @opt {Object} rotate  An object, string, or number (in degrees) containing the rotation value(s)\n   * @opt {Object} rotateX  A string (in any unit) or number (in degrees) representing the X rotation value\n   * @opt {Object} rotateY  A string (in any unit) or number (in degrees) representing the Y rotation value\n   * @opt {Object} rotateZ  A string (in any unit) or number (in degrees) representing the Z rotation value\n   * @opt {String} rotate3d  A string containing the 3D rotation values\n   * @opt {Object} scale  An object, string or number (in percentage points) containing the scale value(s)\n   * @opt {Object} scaleX  A string (in any unit) or number (in percentage points) representing the X scale value\n   * @opt {Object} scaleY  A string (in any unit) or number (in percentage points) representing the Y scale value\n   * @opt {Object} scaleZ  A string (in any unit) or number (in percentage points) representing the Z scale value\n   * @opt {String} scale3d  Astring containing the 3D scale values\n   * @opt {Object} skew  An object or string containing the skew values\n   * @opt {Object} skewX  A string (in any unit) or number (in pixels) representing the X skew value\n   * @opt {Object} skewY  A string (in any unit) or number (in pixels) representing the Y skew value\n   * @opt {String} matrix  A string containing the matrix transform values\n   * @opt {String} matrix3d  A string containing the 3D matrix transform values\n   * @opt {String} perspective  A string containing the perspective transform values\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  /**\n   * Transforms an element\n   * @method $.fn.transform\n   *\n   * @param {String} value  The CSS transform string\n   * @param {String} origin  The CSS transform origin\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  /**\n   * Transforms an element\n   * @method $.fn.transform\n   *\n   * @param {Object} opt  A hash of CSS transform values, with properties in\n   *      the form {translateX: 1, translateY: 1} or {translate: {x: 1, y: 1}}\n   * @opt {Object} translate  An object or string containing the translation values\n   * @opt {Object} translateX  A string (in any unit) or number (in pixels) representing the X translation value\n   * @opt {Object} translateY  A string (in any unit) or number (in pixels) representing the Y translation value\n   * @opt {Object} translateZ  A string (in any unit) or number (in pixels) representing the Z translation value\n   * @opt {String} translate3d  A string containing the 3D translation values\n   * @opt {Object} rotate  An object, string, or number (in degrees) containing the rotation value(s)\n   * @opt {Object} rotateX  A string (in any unit) or number (in degrees) representing the X rotation value\n   * @opt {Object} rotateY  A string (in any unit) or number (in degrees) representing the Y rotation value\n   * @opt {Object} rotateZ  A string (in any unit) or number (in degrees) representing the Z rotation value\n   * @opt {String} rotate3d  A string containing the 3D rotation values\n   * @opt {Object} scale  An object, string or number (in percentage points) containing the scale value(s)\n   * @opt {Object} scaleX  A string (in any unit) or number (in percentage points) representing the X scale value\n   * @opt {Object} scaleY  A string (in any unit) or number (in percentage points) representing the Y scale value\n   * @opt {Object} scaleZ  A string (in any unit) or number (in percentage points) representing the Z scale value\n   * @opt {String} scale3d  Astring containing the 3D scale values\n   * @opt {Object} skew  An object or string containing the skew values\n   * @opt {Object} skewX  A string (in any unit) or number (in pixels) representing the X skew value\n   * @opt {Object} skewY  A string (in any unit) or number (in pixels) representing the Y skew value\n   * @opt {String} matrix  A string containing the matrix transform values\n   * @opt {String} matrix3d  A string containing the 3D matrix transform values\n   * @opt {String} perspective  A string containing the perspective transform values\n   * @param {String} origin  The CSS transform origin\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  /**\n   * Transforms an element\n   * @method $.fn.transform\n   *\n   * @param {String} value  The CSS transform string\n   * @param {Object} origin  The CSS transform origin, in the form {x: N, y: N},\n   *      where N is a decimal percentage between -1 and 1 or N is a pixel value > 1 or < -1.\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  /**\n   * Transforms an element\n   * @method $.fn.transform\n   *\n   * @param {Object} opt  A hash of CSS transform values, with properties in\n   *      the form {translateX: 1, translateY: 1} or {translate: {x: 1, y: 1}}\n   * @opt {Object} translate  An object or string containing the translation values\n   * @opt {Object} translateX  A string (in any unit) or number (in pixels) representing the X translation value\n   * @opt {Object} translateY  A string (in any unit) or number (in pixels) representing the Y translation value\n   * @opt {Object} translateZ  A string (in any unit) or number (in pixels) representing the Z translation value\n   * @opt {String} translate3d  A string containing the 3D translation values\n   * @opt {Object} rotate  An object, string, or number (in degrees) containing the rotation value(s)\n   * @opt {Object} rotateX  A string (in any unit) or number (in degrees) representing the X rotation value\n   * @opt {Object} rotateY  A string (in any unit) or number (in degrees) representing the Y rotation value\n   * @opt {Object} rotateZ  A string (in any unit) or number (in degrees) representing the Z rotation value\n   * @opt {String} rotate3d  A string containing the 3D rotation values\n   * @opt {Object} scale  An object, string or number (in percentage points) containing the scale value(s)\n   * @opt {Object} scaleX  A string (in any unit) or number (in percentage points) representing the X scale value\n   * @opt {Object} scaleY  A string (in any unit) or number (in percentage points) representing the Y scale value\n   * @opt {Object} scaleZ  A string (in any unit) or number (in percentage points) representing the Z scale value\n   * @opt {String} scale3d  Astring containing the 3D scale values\n   * @opt {Object} skew  An object or string containing the skew values\n   * @opt {Object} skewX  A string (in any unit) or number (in pixels) representing the X skew value\n   * @opt {Object} skewY  A string (in any unit) or number (in pixels) representing the Y skew value\n   * @opt {String} matrix  A string containing the matrix transform values\n   * @opt {String} matrix3d  A string containing the 3D matrix transform values\n   * @opt {String} perspective  A string containing the perspective transform values\n   * @param {Object} origin  The CSS transform origin, in the form {x: N, y: N},\n   *      where N is a decimal percentage between -1 and 1 or N is a pixel value > 1 or < -1.\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  $.fn.transform = function(value, origin) {\n    if (Transform.isSupported()) {\n      value = Transform.toCSS(value);\n      if (origin) {\n        if (typeof origin === 'object') {\n          origin = _toOriginUnit(origin.x) + (_isUndefined(origin.y) ? '' : ' ' + _toOriginUnit(origin.y));\n        }\n      }\n      this.each(function() {\n        this.style[_prop] = value;\n        if (origin) {\n          this.style[_prop + 'Origin'] = origin;\n        }\n      });\n    }\n    return this;\n  };\n\n  return Transform;\n\n",
    "js/libs/lavaca.js[47680:56807]": "\n\n  var $ = require('$'),\n      Transform = require('./Transform');\n\n  var Animation = {};\n\n  var _props = {\n        animation: ['animation', 'animationend', 'keyframes'],\n        webkitAnimation: ['-webkit-animation', 'webkitAnimationEnd', '-webkit-keyframes'],\n        MozAnimation: ['-moz-animation', 'animationend', '-moz-keyframes'],\n        OAnimation: ['-o-animation', 'oAnimationEnd', '-o-keyframes'],\n        MSAnimation: ['-ms-animation', 'MSAnimationEnd', '-ms-keyframes']\n      },\n      _prop,\n      _cssProp,\n      _declaration,\n      _event;\n\n  (function() {\n    var style = document.createElement('div').style,\n        s,\n        opts;\n    for (s in _props) {\n      if (s in style) {\n        opts = _props[s];\n        _prop = s;\n        _cssProp = opts[0];\n        _event = opts[1];\n        _declaration = opts[2];\n        break;\n      }\n    }\n  })();\n\n  /**\n   * Static utility type for working with CSS keyframe animations\n   * @class lavaca.fx.Animation\n   */\n\n  /**\n   * Whether or not animations are supported by the browser\n   * @method isSupported\n   * @static\n   *\n   * @return {Boolean}  True if CSS keyframe animations are supported\n   */\n  Animation.isSupported = function() {\n    return !!_prop;\n  };\n\n  /**\n   * Converts a list of keyframes to a CSS animation\n   * @method keyframesToCSS\n   * @static\n   *\n   * @param {String} name  The name of the keyframe animation\n   * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}\n   * @return {String}  The CSS keyframe animation declaration\n   */\n  Animation.keyframesToCSS = function(name, keyframes) {\n    var css = ['@', _declaration, ' ', name, '{'],\n    time,\n    keyframe,\n    prop,\n    value;\n    for (time in keyframes) {\n      css.push(time, '{');\n      keyframe = keyframes[time];\n      if (typeof keyframe === 'string') {\n        css.push(keyframe);\n      } else {\n        for (prop in keyframe) {\n          value = keyframe[prop];\n          if (prop === 'transform' && Transform) {\n            prop = Transform.cssProperty();\n            value = Transform.toCSS(value);\n          }\n          css.push(prop, ':', value, ';');\n        }\n      }\n      css.push('}');\n    }\n    css.push('}');\n    return css.join('');\n  };\n\n  /**\n   * Generates a keyframe animation\n   * @method generateKeyframes\n   * @static\n   *\n   * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}\n   * @return {String}  The name fo the animation\n   */\n  /**\n   * Generates a keyframe animation\n   * @method generateKeyframes\n   * @static\n   * @param {String} name  The name of the animation\n   * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}\n   * @return {String}  The name fo the animation\n   */\n  Animation.generateKeyframes = function(name, keyframes) {\n    if (typeof name === 'object') {\n      keyframes = name;\n      name = 'a' + new Date().getTime();\n    }\n    var css = Animation.keyframesToCSS(name, keyframes);\n    $('<style>' + css + '</style>').appendTo('head');\n    return name;\n  };\n\n  /**\n   * Gets the name of the animation CSS property\n   * @method cssProperty\n   * @static\n   *\n   * @return {String}  The name of the CSS property\n   */\n  Animation.cssProperty = function() {\n    return _cssProp;\n  };\n\n  /**\n   * Applies a keyframe animation to an element\n   * @method $.fn.keyframe\n   *\n   * @param {String} name  The name of the animation\n   * @param {Object} options  Options for the animation\n   * @opt {Number} duration  The number of milliseconds that the animation lasts\n   * @opt {String} easing  The name of a CSS easing function\n   * @default 'linear'\n   * @opt {Number} delay  The number of milliseconds before the animation should start\n   * @default 0\n   * @opt {Object} iterations  Either the number of iterations to play the animation or 'infinite'\n   * @default 1\n   * @opt {String} direction  The name of a CSS animation direction\n   * @default 'normal'\n   * @opt {Function} complete  A function to execute when the animation has completed\n   * @default null\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  /**\n   * Applies a keyframe animation to an element\n   * @method $.fn.keyframe\n   *\n   * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}\n   * @param {Object} options  Options for the animation\n   * @opt {Number} duration  The number of milliseconds that the animation lasts\n   * @opt {String} easing  The name of a CSS easing function\n   * @default 'linear'\n   * @opt {Number} delay  The number of milliseconds before the animation should start\n   * @default 0\n   * @opt {Object} iterations  Either the number of iterations to play the animation or 'infinite'\n   * @default 1\n   * @opt {String} direction  The name of a CSS animation direction\n   * @default 'normal'\n   * @opt {Function} complete  A function to execute when the animation has completed\n   * @default null\n   * @return {jQuery}  The jQuery object, for chaining\n   *\n   */\n  /**\n   * Applies a keyframe animation to an element\n   * @method $.fn.keyframe\n   *\n   * @param {String} name  The name of the animation\n   * @param {Number} duration  The number of milliseconds that the animation lasts\n   * @param {String} easing  The name of a CSS easing function\n   * @param {Number} delay  The number of milliseconds before the animation should start\n   * @param {Object} iterations  Either the number of iterations to play the animation or 'infinite'\n   * @param {String} direction  The name of a CSS animation direction\n   * @param {Function} callback  A function to execute when the animation has completed\n   * @return {jQuery}  The jQuery object, for chaining\n   *\n  */\n  /**\n   * Applies a keyframe animation to an element\n   * @method $.fn.keyframe\n   *\n   * @param {Object} keyframes  A list of timestamped keyframes in the form {'0%': {color: 'red'}, '100%': 'color: blue'}\n   * @param {Number} duration  The number of milliseconds that the animation lasts\n   * @param {String} easing  The name of a CSS easing function\n   * @param {Number} delay  The number of milliseconds before the animation should start\n   * @param {Object} iterations  Either the number of iterations to play the animation or 'infinite'\n   * @param {String} direction  The name of a CSS animation direction\n   * @param {Function} callback  A function to execute when the animation has completed\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  $.fn.keyframe = function(name, duration, easing, delay, iterations, direction, callback) {\n    if (Animation.isSupported()) {\n      if (typeof name === 'object') {\n        name = Animation.generateKeyframes(name);\n      }\n      if (typeof duration === 'object') {\n        callback = duration.complete;\n        direction = duration.direction;\n        iterations = duration.iterations;\n        delay = duration.delay;\n        easing = duration.easing;\n        duration = duration.duration;\n      }\n      direction = direction || 'normal';\n      iterations = iterations || 1;\n      delay = delay || 0;\n      easing = easing || 'linear';\n      duration = duration || 1;\n      if (typeof duration === 'number') {\n        duration += 'ms';\n      }\n      if (typeof delay === 'number') {\n        delay += 'ms';\n      }\n      if (callback) {\n        this.nextAnimationEnd(callback);\n      }\n      this.css(Animation.cssProperty(), [name, duration, easing, delay, iterations, direction].join(' '));\n    }\n    return this;\n  };\n\n  /**\n   * Binds an animation end handler to an element.\n   * @method $.fn.animationEnd\n   *\n   * @param {Function} callback  Callback for when the animation ends\n   * @return {jQuery}  This jQuery object, for chaining\n   *\n  /**\n   * Binds an animation end handler to an element.\n   * @method $.fn.animationEnd\n   *\n   * @param {String} delegate  Selector for the descendant elements to which the handler will be bound\n   * @param {Function} callback  Callback for when the animation ends\n   * @return {jQuery}  This jQuery object, for chaining\n   */\n  $.fn.animationEnd = function(delegate, callback) {\n    if (_event) {\n      return this.on(_event, delegate, callback);\n    } else {\n      return this;\n    }\n  };\n\n  /**\n   * Binds an animation end handler to an element's next animation end event\n   * @method $.fn.nextAnimationEnd\n   *\n   * @param {Function} callback  Callback for when the animation ends\n   * @return {jQuery}  This jQuery object, for chaining\n   */\n  /**\n   * Binds an animation end handler to an element's next animation end event\n   * @method $.fn.nextAnimationEnd\n   *\n   * @param {String} delegate  Selector for the descendant elements to which the handler will be bound\n   * @param {Function} callback  Callback for when the animation ends\n   * @return {jQuery}  This jQuery object, for chaining\n   */\n  $.fn.nextAnimationEnd = function(delegate, callback) {\n    if (_event) {\n      return this.one(_event, delegate, callback);\n    } else {\n      return this;\n    }\n  };\n\n  return Animation;\n\n",
    "js/libs/lavaca.js[56875:63597]": "\n\n  var $ = require('$');\n\n  var Transition = {};\n\n  var _props = {\n        transition: ['transition', 'transitionend'],\n        webkitTransition: ['-webkit-transition', 'webkitTransitionEnd'],\n        MozTransition: ['-moz-transition', 'MozTransitionEnd'],\n        OTransition: ['-o-transition', 'OTransitionEnd'],\n        MSTransition: ['-ms-transition', 'MSTransitionEnd']\n      },\n      _prop,\n      _cssProp,\n      _event;\n\n  (function() {\n    var style = document.createElement('div').style,\n        s;\n    for (s in _props) {\n      if (s in style) {\n        _prop = s;\n        _cssProp = _props[s][0];\n        _event = _props[s][1];\n        break;\n      }\n    }\n  })();\n\n  /**\n   * Static utility type for working with CSS transitions\n   * @class lavaca.fx.Transition\n   */\n\n  /**\n   * Whether or not transitions are supported by the browser\n   * @method isSupported\n   * @static\n   *\n   * @return {Boolean}  True when CSS transitions are supported\n   */\n  Transition.isSupported = function() {\n    return !!_prop;\n  };\n\n  /**\n   * Generates a CSS transition property string from several values\n   * @method toCSS\n   * @static\n   *\n   * @param {Object} props  A hash in which the keys are the names of the CSS properties\n   * @param {Number} duration  The amount of time in milliseconds that the transition lasts\n   * @return {String}  The generated CSS string\n   */\n /**\n   * Generates a CSS transition property string from several values\n   * @method toCSS\n   * @static\n   *\n   * @param {Array} props  An array of CSS property names\n   * @param {Number} duration  The amount of time in milliseconds that the transition lasts\n   * @return {String}  The generated CSS string\n   */\n  /**\n   * Generates a CSS transition property string from several values\n   * @method toCSS\n   * @static\n   *\n   * @param {Object} props  A hash in which the keys are the names of the CSS properties\n   * @param {Number} duration  The amount of time in milliseconds that the transition lasts\n   * @param {String} easing  The interpolation for the transition\n   * @return {String}  The generated CSS string\n   */\n  /**\n   * Generates a CSS transition property string from several values\n   * @method toCSS\n   * @static\n   *\n   * @param {Array} props  An array of CSS property names\n   * @param {Number} duration  The amount of time in milliseconds that the transition lasts\n   * @param {String} easing  The interpolation for the transition\n   * @return {String}  The generated CSS string\n   */\n  Transition.toCSS = function(props, duration, easing) {\n    easing = easing || 'linear';\n    var css = [],\n        isArray = props instanceof Array,\n        prop;\n    for (prop in props) {\n      if (isArray) {\n        prop = props[prop];\n      }\n      css.push(prop + ' ' + duration + 'ms ' + easing);\n    }\n    return css.join(',');\n  };\n\n  /**\n   * Gets the name of the transition CSS property\n   * @method cssProperty\n   * @static\n   *\n   * @return {String}  The name of the CSS property\n   */\n  Transition.cssProperty = function() {\n    return _cssProp;\n  };\n\n  /**\n   * Causes an element to undergo a transition\n   * @method $.fn.transition\n   *\n   * @param {Object} props  The CSS property values at the end of the transition\n   * @param {Number} duration  The amount of time in milliseconds that the transition lasts\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n   /**\n   * Causes an element to undergo a transition\n   * @method $.fn.transition\n   *\n   * @param {Object} props  The CSS property values at the end of the transition\n   * @param {Number} duration  The amount of time in milliseconds that the transition lasts\n   * @param {String} easing  The interpolation for the transition\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n/**\n   * Causes an element to undergo a transition\n   * @method $.fn.transition\n   *\n   * @param {Object} props  The CSS property values at the end of the transition\n   * @param {Number} duration  The amount of time in milliseconds that the transition lasts\n   * @param {Function} callback  A function to execute when the transition completes\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n   /**\n   * Causes an element to undergo a transition\n   * @method $.fn.transition\n   *\n   * @param {Object} props  The CSS property values at the end of the transition\n   * @param {Number} duration  The amount of time in milliseconds that the transition lasts\n   * @param {String} easing  The interpolation for the transition\n   * @param {Function} callback  A function to execute when the transition completes\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  $.fn.transition = function(props, duration, easing, callback) {\n    if (easing instanceof Function) {\n        callback = easing;\n        easing = null;\n    }\n    if (Transition.isSupported()) {\n      var css = Transition.toCSS(props, duration, easing);\n      if (callback) {\n        this.nextTransitionEnd(callback);\n      }\n      this.each(function() {\n        this.style[_prop] = css;\n      });\n      this.css(props);\n    } else {\n      this.css(props);\n      if (callback) {\n        callback.call(this[0], {});\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Binds a transition end handler to an element.\n   * @method $.fn.transitionEnd\n   *\n   * @param {Function} callback  Callback for when the transition ends\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  /**\n   * Binds a transition end handler to an element.\n   * @method $.fn.transitionEnd\n   *\n   * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound\n   * @param {Function} callback  Callback for when the transition ends\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  $.fn.transitionEnd = function(delegate, callback) {\n    if (_event) {\n      return this.on(_event, delegate, callback);\n    } else {\n      return this;\n    }\n  };\n\n  /**\n   * Binds a transition end handler to an element's next transition end event.\n   * @method $.fn.nextTransitionEnd\n   *\n   * @param {Function} callback  Callback for when the transition ends\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  /**\n   * Binds a transition end handler to an element's next transition end event.\n   * @method $.fn.nextTransitionEnd\n   *\n   * @param {String} delegate  Selector for the descendant elements to which the handlers will be bound\n   * @param {Function} callback  Callback for when the transition ends\n   * @return {jQuery}  The jQuery object, for chaining\n   */\n  $.fn.nextTransitionEnd = function(delegate, callback) {\n    if (_event) {\n      return this.one(_event, delegate, callback);\n    } else {\n      return this;\n    }\n  };\n\n  return Transition;\n\n",
    "js/libs/lavaca.js[65847:66232]": "\n        if (e.state) {\n          _pushCount--;\n          var previousId = _currentId;\n          _currentId = e.state.id;\n          self.trigger('popstate', {\n            state: e.state.state,\n            title: e.state.title,\n            url: e.state.url,\n            id: e.state.id,\n            direction: _currentId > previousId ? 'forward' : 'back'\n          });\n        }\n      ",
    "js/libs/lavaca.js[67808:67866]": "\n      return this.sequence[this.position] || null;\n    ",
    "js/libs/lavaca.js[68063:68099]": "\n      return _pushCount > 0;\n    ",
    "js/libs/lavaca.js[69693:70100]": "\n      if (this.onPopState) {\n        if (_standardsMode) {\n          window.removeEventListener('popstate', this.onPopState, false);\n        } else if (window.detachEvent) {\n          window.detachEvent('onhashchange', this.onPopState);\n        } else {\n          window.removeEventListener('hashchange', this.onPopState, false);\n        }\n      }\n      EventDispatcher.prototype.dispose.call(this);\n    ",
    "js/libs/lavaca.js[71378:71435]": "\n    History.init().replace.apply(_hist, arguments);\n  ",
    "js/libs/lavaca.js[71548:71573]": "\n    history.back();\n  ",
    "js/libs/lavaca.js[71688:71716]": "\n    history.forward();\n  ",
    "js/libs/lavaca.js[71862:71933]": "\n    if (_hist) {\n      _hist.dispose();\n      _hist = null;\n    }\n  ",
    "js/libs/lavaca.js[72653:72713]": "\n    return History.init().off.apply(_hist, arguments);\n  ",
    "js/libs/lavaca.js[75219:75477]": "\n        var i = 0,\n            n = arguments.length,\n            obj;\n        while(++i < n){\n            obj = arguments[i];\n            if (obj != null) {\n                forOwn(obj, copyProp, target);\n            }\n        }\n        return target;\n    ",
    "js/libs/lavaca.js[75510:75542]": "\n        this[key] = val;\n    ",
    "js/libs/lavaca.js[76151:76287]": "\n        if (isPlainObject(source)) {\n            return mixIn({}, source);\n        } else {\n            return source;\n        }\n    ",
    "js/libs/lavaca.js[76317:76513]": "\n        var flags = '';\n        flags += r.multiline ? 'm' : '';\n        flags += r.global ? 'g' : '';\n        flags += r.ignorecase ? 'i' : '';\n        return new RegExp(r.source, flags);\n    ",
    "js/libs/lavaca.js[76544:76583]": "\n        return new Date(+date);\n    ",
    "js/libs/lavaca.js[76614:76649]": "\n        return arr.slice();\n    ",
    "js/libs/lavaca.js[77637:77842]": "\n        var out = [],\n            i = -1,\n            n = arr.length,\n            val;\n        while (++i < n) {\n            out[i] = deepClone(arr[i], instanceClone);\n        }\n        return out;\n    ",
    "js/libs/lavaca.js[78028:78072]": "\n        return kindOf(val) === kind;\n    ",
    "js/libs/lavaca.js[78202:78247]": "\n        return isKind(val, 'Object');\n    ",
    "js/libs/lavaca.js[79838:79886]": "\n    return new RegExp('[\\\\{\\\\}\\\\*]', 'g');\n  ",
    "js/libs/lavaca.js[79914:79977]": "\n    return new RegExp('^\\\\d{4}-[0-1]\\\\d-[0-3]\\\\d$', 'g');\n  ",
    "js/libs/lavaca.js[80621:81042]": "\n    value = decodeURIComponent(value);\n    if (!isNaN(value)) {\n      value = Number(value);\n    } else if (value.toLowerCase() === 'true') {\n      value = true;\n    } else if (value.toLowerCase() === 'false') {\n      value = false;\n    } else if (_datePattern().test(value)) {\n      value = value.split('-');\n      value = new Date(Number(value[0]), Number(value[1]) - 1, Number(value[2]));\n    }\n    return value;\n  ",
    "js/libs/lavaca.js[87373:87590]": "\n        if (this.hasNavigated) {\n          History.isRoutingBack = e.direction === 'back';\n          this.exec(e.url, e).always(function() {\n            History.isRoutingBack = false;\n          });\n        }\n      ",
    "js/libs/lavaca.js[91638:91823]": "\n      if (this.onpopstate) {\n        History.off('popstate', this.onpopstate);\n        this.onpopstate = null;\n      }\n      Disposable.prototype.dispose.apply(this, arguments);\n    ",
    "js/libs/lavaca.js[92927:93331]": "\n    if (!name) {\n      return null;\n    }\n    name = name.split('.');\n    var last = root || window,\n        o = root || window,\n        i = -1,\n        segment;\n    while (!!(segment = name[++i])) {\n      o = o[segment];\n      if (!o) {\n        if (createIfNotExists) {\n          o = last[segment] = {};\n        } else {\n          return null;\n        }\n      }\n      last = o;\n    }\n    return o;\n  ",
    "js/libs/lavaca.js[93906:94080]": "\n    if (arg === _offlineErrorCode) {\n      var i = -1,\n          callback;\n      while (!!(callback = _offlineAjaxHandlers[++i])) {\n        callback(arg);\n      }\n    }\n  ",
    "js/libs/lavaca.js[94403:94653]": "\n    var connectionType = resolve('navigator.connection.type');\n    if (connectionType !== null) {\n      return connectionType === resolve('Connection.NONE');\n    } else {\n      return _navigatorOnlineSupported ? !navigator.onLine : false;\n    }\n  ",
    "js/libs/lavaca.js[94992:95590]": "\n    var promise = new Promise(),\n        origSuccess = opts.success,\n        origError = opts.error;\n    opts.success = function() {\n      if (origSuccess) {\n        origSuccess.apply(this, arguments);\n      }\n      promise.resolve.apply(promise, arguments);\n    };\n    opts.error = function() {\n      if (origError) {\n        origError.apply(this, arguments);\n      }\n      promise.reject.apply(promise, arguments);\n    };\n    if (Connectivity.isOffline()) {\n      promise.reject(_offlineErrorCode);\n    } else {\n      $.ajax(opts);\n    }\n    promise.error(_onAjaxError);\n    return promise;\n  ",
    "js/libs/lavaca.js[95930:95976]": "\n    _offlineAjaxHandlers.push(callback);\n  ",
    "js/libs/lavaca.js[97396:97515]": "\n    var index = ArrayUtils.indexOf(a, o);\n    if (index > -1) {\n      a.splice(index, 1);\n    }\n    return index;\n  ",
    "js/libs/lavaca.js[97846:97972]": "\n    var index = ArrayUtils.indexOf(a, o);\n    if (index === -1) {\n      a[index = a.length] = o;\n    }\n    return index;\n  ",
    "js/libs/lavaca.js[98194:98316]": "\n    return Array.isArray === 'function' ? Array.isArray(a) : Object.prototype.toString.call(a) === '[object Array]';\n  ",
    "js/libs/lavaca.js[99985:100059]": "\n      var id = uuid();\n      this.set(id, value);\n      return id;\n    ",
    "js/libs/lavaca.js[100250:100286]": "\n      delete this['@' + id];\n    ",
    "js/libs/lavaca.js[101669:101722]": "\n      return JSON.stringify(this.toObject());\n    ",
    "js/libs/lavaca.js[101962:102214]": "\n      var results = [];\n      results['ids'] = [];\n      this.each(function(prop, value) {\n        results.push(typeof value.toObject === 'function' ? value.toObject() : value);\n        results['ids'].push(prop);\n      });\n      return results;\n    ",
    "js/libs/lavaca.js[102316:102406]": "\n       this.each(function(key, item) {\n         this.remove(key);\n       }, this);\n    ",
    "js/libs/lavaca.js[102508:102627]": "\n      var count = 0;\n      this.each(function(key, item) {\n        count++;\n      }, this);\n      return count;\n    ",
    "js/libs/lavaca.js[102743:102829]": "\n      this.clear();\n      Disposable.prototype.dispose.apply(this, arguments);\n    ",
    "js/libs/lavaca.js[104936:104976]": "\n      return this.name === name;\n    ",
    "js/libs/lavaca.js[105169:105407]": "\n      if (!this.hasLoaded) {\n        if (this.code) {\n          this.add(this.code);\n        } else if (this.src) {\n          this.load(this.src);\n        }\n        this.hasLoaded = true;\n      }\n      return this.cache.get(code);\n    ",
    "js/libs/lavaca.js[105561:105640]": "\n      for (var n in data) {\n        this.cache.set(n, data[n]);\n      }\n    ",
    "js/libs/lavaca.js[105823:105898]": "\n      this.add(typeof text === 'string' ? JSON.parse(text) : text);\n    ",
    "js/libs/lavaca.js[106063:106243]": "\n      var self = this;\n      Connectivity.ajax({\n        async: false,\n        url: url,\n        success: function(resp) {\n          self.process(resp);\n        }\n      });\n    ",
    "js/libs/lavaca.js[106491:106617]": "\n    var map = name;\n    if (typeof map === 'string') {\n      map = cache.get(name);\n    }\n    cache.set('default', map);\n  ",
    "js/libs/lavaca.js[107034:107234]": "\n    if (!code) {\n      code = name;\n      name = defaultName;\n    }\n    if (name) {\n      var map = cache.get(name);\n      if (map) {\n        return map.get(code);\n      }\n    }\n    return null;\n  ",
    "js/libs/lavaca.js[107804:108195]": "\n        var item = $(this),\n            src = item.attr('data-src'),\n            name = item.attr('data-name'),\n            isDefault = typeof item.attr('data-default') === 'string',\n            code = item.text(),\n            map;\n        map = construct(name, src, code);\n        cache.set(map.name, map);\n        if (isDefault) {\n          Map.setDefault(cache, name);\n        }\n      ",
    "js/libs/lavaca.js[108365:108391]": "\n    cache.dispose();\n  ",
    "js/libs/lavaca.js[108626:108724]": "\n    if (code) {\n      code = JSON.parse(code);\n    }\n    return new Config(name, src, code);\n  ",
    "js/libs/lavaca.js[109088:109127]": "\n    Map.setDefault(_cache, name);\n  ",
    "js/libs/lavaca.js[109350:109394]": "\n    return _cache.get('default').name;\n  ",
    "js/libs/lavaca.js[109865:109921]": "\n    return Map.get(_cache, name, code, 'default');\n  ",
    "js/libs/lavaca.js[110410:110440]": "\n    Map.dispose(_cache);\n  ",
    "js/libs/lavaca.js[111507:111679]": "\n    var keys = model.flags[flag];\n    if (!keys) {\n      keys = model.flags[flag] = [];\n    }\n    if (!ArrayUtils.contains(keys, name)) {\n      keys.push(name);\n    }\n  ",
    "js/libs/lavaca.js[112198:112398]": "\n    var isValid = true;\n    for(var attribute in messages){\n      if (messages[attribute].length > 0){\n        isValid = false;\n      }\n    }\n    messages.isValid = isValid;\n    return messages;\n  ",
    "js/libs/lavaca.js[114551:114836]": "\n      var attr = this.attributes.get(attribute),\n          flags;\n      if (typeof attr === 'function') {\n        flags = this.flags[Model.DO_NOT_COMPUTE];\n        return !flags || ArrayUtils.indexOf(flags, attribute) === -1 ? attr.call(this) : attr;\n      }\n      return attr;\n    ",
    "js/libs/lavaca.js[115094:115120]": "\n      return true;\n    ",
    "js/libs/lavaca.js[117146:117196]": "\n      return this.get(attribute) !== null;\n    ",
    "js/libs/lavaca.js[117479:117527]": "\n      return this.get(this.idAttribute);\n    ",
    "js/libs/lavaca.js[117736:117776]": "\n      return null === this.id();\n    ",
    "js/libs/lavaca.js[119080:119638]": "\n      if (flag) {\n        var attrs = this.flags[flag],\n            i = -1,\n            attr,\n            item;\n        if (attrs) {\n          while (!!(attr = attrs[++i])) {\n            ArrayUtils.remove(this.unsavedAttributes, attr);\n            item = this.get(attr);\n            if (item && item.dispose) {\n              item.dispose();\n            }\n            this.set(attr, null);\n          }\n        }\n      } else {\n        this.attributes.dispose();\n        this.attributes = new Cache();\n        this.unsavedAttributes.length = 0;\n      }\n    ",
    "js/libs/lavaca.js[119784:119854]": "\n      return new this.constructor(this.attributes.toObject());\n    ",
    "js/libs/lavaca.js[120294:120379]": "\n      this.rules.get(attribute, []).push({rule: callback, message: message});\n    ",
    "js/libs/lavaca.js[121642:121719]": "\n          messages[attributeName] = this.validate(attributeName);\n        ",
    "js/libs/lavaca.js[121977:122251]": "\n      response = this.parse(response);\n      if (this.responseFilter && typeof this.responseFilter === 'function') {\n        response = this.responseFilter(response);\n      }\n      this.apply(response, true);\n      this.trigger('fetchSuccess', {response: response});\n    ",
    "js/libs/lavaca.js[122443:122506]": "\n      this.trigger('fetchError', {response: response});\n    ",
    "js/libs/lavaca.js[123760:124111]": "\n      if (typeof url === 'object') {\n        options = url;\n      } else {\n        options = clone(options || {});\n        options.url = url;\n      }\n      options.url = this.getApiURL(options.url || this.url);\n      return Promise.when(this, Connectivity.ajax(options))\n        .success(this.onFetchSuccess)\n        .error(this.onFetchError);\n    ",
    "js/libs/lavaca.js[124458:124686]": "\n      var badURL = '/please_set_model_url',\n          apiRoot = Config.get('apiRoot'),\n          apiURL;\n      if (!relPath) {\n        return badURL;\n      }\n      apiURL = (apiRoot || '') + relPath;\n      return apiURL;\n    ",
    "js/libs/lavaca.js[125488:126520]": "\n      var promise = new Promise(this),\n          attributes = this.toObject(),\n          changedAttributes = {},\n          i = -1,\n          attribute,\n          result;\n      while (!!(attribute = this.unsavedAttributes[++i])) {\n        changedAttributes[attribute] = attributes[attribute];\n      }\n      promise\n        .success(function(value) {\n          var idAttribute = this.idAttribute;\n          if (this.isNew() && value[idAttribute] !== UNDEFINED) {\n            this.set(idAttribute, value[idAttribute]);\n          }\n          this.unsavedAttributes = [];\n          this.trigger('saveSuccess', {response: value});\n        })\n        .error(function(value) {\n          this.trigger('saveError', {response: value});\n        });\n      result = callback.call(thisp || this, this, changedAttributes, attributes);\n      if (result instanceof Promise) {\n        promise.when(result);\n      } else if (result) {\n        promise.resolve(result);\n      } else {\n        promise.reject(result);\n      }\n      return promise;\n    ",
    "js/libs/lavaca.js[126761:127264]": "\n      return this.save(function(model, changedAttributes, attributes) {\n        var id = this.id(),\n            data;\n        if (this.isNew()) {\n          data = attributes;\n        } else {\n          changedAttributes[this.idAttribute] = id;\n          data = changedAttributes;\n        }\n        return Promise.when(this, Connectivity.ajax({\n            url: url,\n            cache: false,\n            type: 'POST',\n            data: data,\n            dataType: 'json'\n          }));\n      });\n    ",
    "js/libs/lavaca.js[127948:128001]": "\n      return JSON.stringify(this.toObject());\n    ",
    "js/libs/lavaca.js[129672:129779]": "\n        if (!attr || e.attribute === attr) {\n          callback.call(thisp || this, e);\n        }\n      ",
    "js/libs/lavaca.js[130259:130289]": "\n      return response;\n    ",
    "js/libs/lavaca.js[131218:131245]": "\n      // Do nothing\n    ",
    "js/libs/lavaca.js[131475:131506]": "\n      throw 'Abstract';\n    ",
    "js/libs/lavaca.js[131686:131717]": "\n      this.code = text;\n    ",
    "js/libs/lavaca.js[133258:133288]": "\n    Map.dispose(_cache);\n  ",
    "js/libs/lavaca.js[133607:133776]": "\n    var template = Template.get(name);\n    if (!template) {\n      throw 'No template named \"' + name + '\"';\n    } else {\n      return template.render(model);\n    }\n  ",
    "js/libs/lavaca.js[134878:135016]": "\n    if (window.console) {\n      console.log.apply(console, arguments);\n    } else {\n      alert([].join.call(arguments, ' '));\n    }\n  ",
    "js/libs/lavaca.js[139278:140300]": "\n      var self = this,\n        promise = new Promise(this),\n        renderPromise = new Promise(this),\n        template = Template.get(this.template),\n        model = this.model;\n      if (model instanceof Model) {\n        model = model.toObject();\n      }\n      /**\n       * Fires when html from template has rendered\n       * @event rendersuccess\n       */\n      promise\n        .success(function(html) {\n          this.trigger('rendersuccess', {html: html});\n          renderPromise.resolve();\n        })\n      /**\n       * Fired when there was an error during rendering process\n       * @event rendererror\n       */\n        .error(function(err) {\n          this.trigger('rendererror', {err: err});\n          renderPromise.reject();\n        });\n      template\n        .render(model)\n        .success(promise.resolver())\n        .error(promise.rejector())\n        .then(function() {\n          if (self.className){\n            self.el.addClass(self.className);\n          }\n        });\n\n      return renderPromise;\n    ",
    "js/libs/lavaca.js[143742:145870]": "\n      var self = this,\n        templateRenderPromise = new Promise(this),\n        redrawPromise = new Promise(this),\n        template = Template.get(this.template),\n        replaceAll;\n      if (typeof selector === 'object' || selector instanceof Model) {\n        model = selector;\n        replaceAll = true;\n        selector = null;\n      }\n      else if (typeof selector === 'boolean') {\n        replaceAll = selector;\n        selector = null;\n      } else if (!selector) {\n        replaceAll = true;\n      }\n      model = model || this.model;\n      if (model instanceof Model) {\n        model = model.toObject();\n      }\n\n      // process widget, child view, and\n      // child view event maps\n      function processMaps() {\n        self.createWidgets();\n        self.createChildViews();\n        self.applyChildViewEvents();\n      }\n      templateRenderPromise\n        .success(function(html) {\n          if (replaceAll) {\n            this.disposeChildViews(this.el);\n            this.disposeWidgets(this.el);\n            this.el.html(html);\n            processMaps();\n            redrawPromise.resolve(html);\n            return;\n          }\n          if(selector) {\n            var $newEl = $('<div>' + html + '</div>').find(selector),\n              $oldEl = this.el.find(selector);\n            if($newEl.length === $oldEl.length) {\n              $oldEl.each(function(index) {\n                var $el = $(this);\n                self.disposeChildViews($el);\n                self.disposeWidgets($el);\n                $el.replaceWith($newEl.eq(index)).remove();\n              });\n              processMaps();\n              redrawPromise.resolve(html);\n            } else {\n              redrawPromise.reject('Count of items matching selector is not the same in the original html and in the newly rendered html.');\n            }\n          } else {\n            redrawPromise.resolve(html);\n          }\n        })\n        .error(redrawPromise.rejector());\n      template\n        .render(model)\n        .success(templateRenderPromise.resolver())\n        .error(templateRenderPromise.rejector());\n      return redrawPromise;\n    ",
    "js/libs/lavaca.js[146080:146541]": "\n      var childViewSearch,\n        self = this;\n\n      // Remove child views\n      childViewSearch = $el.find('[data-view-id]');\n      if ($el !== self.el && $el.is('[data-view-id]')) {\n        childViewSearch = childViewSearch.add($el);\n      }\n      childViewSearch.each(function(index, item) {\n        var $item = $(item),\n          childView = $item.data('view');\n\n        self.childViews.remove(childView.id);\n        childView.dispose();\n      });\n    ",
    "js/libs/lavaca.js[146744:147171]": "\n      var self = this;\n\n      // Remove widgets\n      $el.add($el.find('[data-has-widgets]')).each(function(index, item) {\n        var $item = $(item),\n          widgets = $item.data('widgets'),\n          selector, widget;\n        for (selector in widgets) {\n          widget = widgets[selector];\n          self.widgets.remove(widget.id);\n          widget.dispose();\n        }\n      });\n      $el.removeData('widgets');\n    ",
    "js/libs/lavaca.js[147298:147862]": "\n      var type,\n        callback,\n        dotIndex;\n      if (this.eventMap\n        && this.eventMap.model\n        && this.model\n        && this.model instanceof EventDispatcher) {\n        for (type in this.eventMap.model) {\n          callback = this.eventMap.model[type];\n          if (typeof callback === 'object') {\n            callback = callback.on;\n          }\n          dotIndex = type.indexOf('.');\n          if (dotIndex !== -1) {\n            type = type.substr(0, dotIndex);\n          }\n          this.model.off(type, callback);\n        }\n      }\n    ",
    "js/libs/lavaca.js[151910:152289]": "\n            var $el = $(item),\n              widgetMap = $el.data('widgets') || {},\n              widget;\n            if (!widgetMap[n]) {\n              widget = new o($(item));\n              widgetMap[n] = widget;\n              cache.set(widget.id, widget);\n              $el.data('widgets', widgetMap);\n              $el.attr('data-has-widgets','');\n            }\n          ",
    "js/libs/lavaca.js[153096:153376]": "\n      if (typeof selector === 'object') {\n        var widgetTypes = selector;\n        for (selector in widgetTypes) {\n          this.mapWidget(selector, widgetTypes[selector]);\n        }\n      } else {\n        this.widgetMap[selector] = TWidget;\n      }\n      return this;\n    ",
    "js/libs/lavaca.js[153751:153994]": "\n            var $el = $(item),\n              childView;\n            if (!$el.data('view')) {\n              childView = new o.TView($el, o.model || self.model, self);\n              cache.set(childView.id, childView);\n            }\n          ",
    "js/libs/lavaca.js[156019:156410]": "\n      if (typeof type === 'object'){\n        var eventTypes = type;\n        for (type in eventTypes){\n          //add in view type to limit events created\n          this.mapChildViewEvent(type, eventTypes[type].callback, eventTypes[type].TView);\n        }\n      } else {\n        this.childViewEventMap[type] = {\n          TView: TView,\n          callback: callback\n        };\n      }\n    ",
    "js/libs/lavaca.js[156759:157233]": "\n          var callbacks,\n            callback,\n            i = -1;\n\n          if (!childViewEventMap[type].TView || item instanceof childViewEventMap[type].TView) {\n            callbacks = item.callbacks[type] || [];\n            while (!!(callback = callbacks[++i])) {\n              if (callback === childViewEventMap[type].callback) {\n                return;\n              }\n            }\n            item.on(type, childViewEventMap[type].callback);\n          }\n        ",
    "js/libs/lavaca.js[158120:158145]": "\n      log(e.err);\n    ",
    "js/libs/lavaca.js[158257:158689]": "\n      if (this.model) {\n        this.clearModelEvents();\n      }\n      if (this.childViews.count()) {\n        this.disposeChildViews(this.el);\n      }\n      if (this.widgets.count()) {\n        this.disposeWidgets(this.el);\n      }\n\n      // Do not dispose of template or model\n      this.template\n        = this.model\n        = this.parentView\n        = null;\n\n      EventDispatcher.prototype.dispose.apply(this, arguments);\n    ",
    "js/libs/lavaca.js[161951:162175]": "\n          /**\n           * Fired when there was an error during rendering process\n           * @event rendererror\n           */\n          this.trigger('rendererror', {err: err});\n          renderPromise.reject();\n        ",
    "js/libs/lavaca.js[163565:163885]": "\n      var promise = new Promise(this);\n      this.shell.detach();\n      delay(promise.resolver());\n      promise.then(function() {\n        /**\n         * Fired when there was an error during rendering process\n         * @event rendererror\n         */\n        this.trigger('exit');\n      });\n      return promise;\n    ",
    "js/libs/lavaca.js[169620:170116]": "\n      if (typeof layer === 'number') {\n        this.dismissLayersAbove(layer - 1);\n      } else if (layer instanceof PageView) {\n        this.dismiss(layer.layer);\n      } else {\n        layer = $(layer);\n        var index = layer.attr('data-layer-index');\n        if (index === null) {\n          layer = layer.closest('[data-layer-index]');\n          index = layer.attr('data-layer-index');\n        }\n        if (index !== null) {\n          this.dismiss(Number(index));\n        }\n      }\n    ",
    "js/libs/lavaca.js[170957:171481]": "\n            this.exitingPageViews.push(layer);\n            promise\n              .when(layer.exit(this.el, this.enteringPageViews))\n              .success(function() {\n                delay(function() {\n                  ArrayUtils.remove(this.exitingPageViews, layer);\n                  if (!layer.cacheKey || (exceptForView && exceptForView.cacheKey === layer.cacheKey)) {\n                    layer.dispose();\n                  }\n                }, this);\n              });\n            this.layers[i] = null;\n          ",
    "js/libs/lavaca.js[171745:172197]": "\n      // Don't dispose of any views that are currently displayed\n      //flush individual cacheKey\n      if (cacheKey){\n        this.pageViews.remove(cacheKey);\n      } else {\n        var i = -1,\n          layer;\n        while (!!(layer = this.layers[++i])) {\n          if (layer.cacheKey) {\n            this.pageViews.remove(layer.cacheKey);\n          }\n        }\n        this.pageViews.dispose();\n        this.pageViews = new Cache();\n      }\n    ",
    "js/libs/lavaca.js[172317:172371]": "\n      Disposable.prototype.dispose.call(this);\n    ",
    "js/libs/lavaca.js[172554:173865]": "\n\n  var Device = require('lavaca/env/Device'),\n      EventDispatcher = require('lavaca/events/EventDispatcher'),\n      Promise = require('lavaca/util/Promise');\n\n  /**\n   * A sub-browser management utility (also accessible via window.plugins.childBrowser)\n   * @class lavaca.env.ChildBrowser\n   * @extends Lavaca.events.EventDispatcher\n   *\n   * @event open\n   * @event close\n   * @event change\n   *\n   * @constructor\n   */\n  var ChildBrowser = EventDispatcher.extend({\n    /**\n     * Opens a web page in the child browser (or navigates to it)\n     * @method showWebPage\n     *\n     * @param {String} loc  The URL to open\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    showWebPage: function(loc) {\n      if (Device.isCordova()) {\n        return Device\n          .exec('ChildBrowser', 'showWebPage', [loc])\n          .error(function() {\n            window.location.href = loc;\n          });\n      } else {\n        window.open(loc);\n        return new Promise(window).resolve();\n      }\n    },\n    /**\n     * Closes the child browser, if it's open\n     * @method close\n     *\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    close: function() {\n      return Device.exec('ChildBrowser', 'close', []);\n    }\n  });\n\n  Device.register('childBrowser', ChildBrowser);\n\n  return ChildBrowser;\n\n",
    "js/libs/lavaca.js[174086:174288]": "\n    if (code) {\n      code = JSON.parse(code);\n    }\n    var map = new Translation(name, src, code);\n    if (!_cache.get(map.language)) {\n      _cache.set(map.language, map);\n    }\n    return map;\n  ",
    "js/libs/lavaca.js[174682:175324]": "\n    Map.apply(this, arguments);\n    var locale = name.toLowerCase().split('_');\n    /**\n     * The ISO 639-2 code for the translation's language\n     * @property {String} language\n     * @default null\n     */\n    this.language = locale[0];\n    /**\n     * The ISO 3166-1 code for the translation's country\n     * @property {String} country\n     * @default ''\n     */\n    this.country = locale[1] || '';\n    /**\n     * The locale of this translation (either lang or lang_COUNTRY)\n     * @property {String} locale\n     * @default null\n     */\n    this.locale = this.country\n      ? this.language + '_' + this.country\n      : this.language;\n  ",
    "js/libs/lavaca.js[175863:175978]": "\n      return language === this.language\n        && (!country || !this.country || country === this.country);\n    ",
    "js/libs/lavaca.js[176203:176297]": "\n    _cache.remove('default');\n    Map.setDefault(_cache, Translation.forLocale(locale));\n  ",
    "js/libs/lavaca.js[176554:176713]": "\n    locale = (locale || 'default').toLowerCase();\n    return _cache.get(locale)\n      || _cache.get(locale.split('_')[0])\n      || _cache.get('default');\n  ",
    "js/libs/lavaca.js[177294:177862]": "\n    if (!code) {\n      code = locale;\n      locale = 'default';\n    }\n    var translation = Translation.forLocale(locale),\n        result = null;\n    if (translation) {\n      result = translation.get(code);\n    }\n    if (result === null) {\n      translation = Translation.forLocale(locale.split('_')[0]);\n      if (translation) {\n        result = translation.get(code);\n      }\n    }\n    if (result === null) {\n      translation = Translation.forLocale('default');\n      if (translation) {\n        result = translation.get(code);\n      }\n    }\n    return result;\n  ",
    "js/libs/lavaca.js[178284:178388]": "\n    Map.init(_cache, 'text/x-translation', _construct, scope);\n    Translation.setDefault(locale);\n  ",
    "js/libs/lavaca.js[178505:178535]": "\n    Map.dispose(_cache);\n  ",
    "js/libs/lavaca.js[180498:180616]": "\n\n\twhile ( event && typeof event.originalEvent !== \"undefined\" ) {\n\t\tevent = event.originalEvent;\n\t}\n\treturn event;\n",
    "js/libs/lavaca.js[180666:181938]": "\n\n\tvar t = event.type,\n\t\toe, props, ne, prop, ct, touch, i, j, len;\n\n\tevent = $.Event( event );\n\tevent.type = eventType;\n\n\toe = event.originalEvent;\n\tprops = $.event.props;\n\n\t// addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280\n\t// https://github.com/jquery/jquery-mobile/issues/3280\n\tif ( t.search( /^(mouse|click)/ ) > -1 ) {\n\t\tprops = mouseEventProps;\n\t}\n\n\t// copy original event properties over to the new event\n\t// this would happen if we could call $.event.fix instead of $.Event\n\t// but we don't have a way to force an event to be fixed multiple times\n\tif ( oe ) {\n\t\tfor ( i = props.length, prop; i; ) {\n\t\t\tprop = props[ --i ];\n\t\t\tevent[ prop ] = oe[ prop ];\n\t\t}\n\t}\n\n\t// make sure that if the mouse and click virtual events are generated\n\t// without a .which one is defined\n\tif ( t.search(/mouse(down|up)|click/) > -1 && !event.which ) {\n\t\tevent.which = 1;\n\t}\n\n\tif ( t.search(/^touch/) !== -1 ) {\n\t\tne = getNativeEvent( oe );\n\t\tt = ne.touches;\n\t\tct = ne.changedTouches;\n\t\ttouch = ( t && t.length ) ? t[0] : ( ( ct && ct.length ) ? ct[ 0 ] : undefined );\n\n\t\tif ( touch ) {\n\t\t\tfor ( j = 0, len = touchEventProps.length; j < len; j++) {\n\t\t\t\tprop = touchEventProps[ j ];\n\t\t\t\tevent[ prop ] = touch[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn event;\n",
    "js/libs/lavaca.js[181983:182226]": "\n\n\tvar flags = {},\n\t\tb, k;\n\n\twhile ( element ) {\n\n\t\tb = $.data( element, dataPropertyName );\n\n\t\tfor (  k in b ) {\n\t\t\tif ( b[ k ] ) {\n\t\t\t\tflags[ k ] = flags.hasVirtualBinding = true;\n\t\t\t}\n\t\t}\n\t\telement = element.parentNode;\n\t}\n\treturn flags;\n",
    "js/libs/lavaca.js[182295:182493]": "\n\tvar b;\n\twhile ( element ) {\n\n\t\tb = $.data( element, dataPropertyName );\n\n\t\tif ( b && ( !eventType || b[ eventType ] ) ) {\n\t\t\treturn element;\n\t\t}\n\t\telement = element.parentNode;\n\t}\n\treturn null;\n",
    "js/libs/lavaca.js[182526:182558]": "\n\tblockTouchTriggers = false;\n",
    "js/libs/lavaca.js[182592:182623]": "\n\tblockTouchTriggers = true;\n",
    "js/libs/lavaca.js[182656:182834]": "\n\tlastTouchID = 0;\n\tclickBlockList.length = 0;\n\tblockMouseTriggers = false;\n\n\t// When mouse bindings are enabled, our\n\t// touch bindings are disabled.\n\tdisableTouchBindings();\n",
    "js/libs/lavaca.js[182868:182969]": "\n\t// When mouse bindings are disabled, our\n\t// touch bindings are enabled.\n\tenableTouchBindings();\n",
    "js/libs/lavaca.js[182998:183142]": "\n\tclearResetTimer();\n\tresetTimerID = setTimeout( function() {\n\t\tresetTimerID = 0;\n\t\tenableMouseBindings();\n\t}, $.vmouse.resetTimerDuration );\n",
    "js/libs/lavaca.js[183171:183252]": "\n\tif ( resetTimerID ) {\n\t\tclearTimeout( resetTimerID );\n\t\tresetTimerID = 0;\n\t}\n",
    "js/libs/lavaca.js[183310:183548]": "\n\tvar ve;\n\n\tif ( ( flags && flags[ eventType ] ) ||\n\t\t\t\t( !flags && getClosestElementWithVirtualBinding( event.target, eventType ) ) ) {\n\n\t\tve = createVirtualEvent( event, eventType );\n\n\t\t$( event.target).trigger( ve );\n\t}\n\n\treturn ve;\n",
    "js/libs/lavaca.js[183587:184043]": "\n\tvar touchID = $.data( event.target, touchTargetPropertyName );\n\n\tif ( !blockMouseTriggers && ( !lastTouchID || lastTouchID !== touchID ) ) {\n\t\tvar ve = triggerVirtualEvent( \"v\" + event.type, event );\n\t\tif ( ve ) {\n\t\t\tif ( ve.isDefaultPrevented() ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t\tif ( ve.isPropagationStopped() ) {\n\t\t\t\tevent.stopPropagation();\n\t\t\t}\n\t\t\tif ( ve.isImmediatePropagationStopped() ) {\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t}\n",
    "js/libs/lavaca.js[184080:184671]": "\n\n\tvar touches = getNativeEvent( event ).touches,\n\t\ttarget, flags;\n\n\tif ( touches && touches.length === 1 ) {\n\n\t\ttarget = event.target;\n\t\tflags = getVirtualBindingFlags( target );\n\n\t\tif ( flags.hasVirtualBinding ) {\n\n\t\t\tlastTouchID = nextTouchID++;\n\t\t\t$.data( target, touchTargetPropertyName, lastTouchID );\n\n\t\t\tclearResetTimer();\n\n\t\t\tdisableMouseBindings();\n\t\t\tdidScroll = false;\n\n\t\t\tvar t = getNativeEvent( event ).touches[ 0 ];\n\t\t\tstartX = t.pageX;\n\t\t\tstartY = t.pageY;\n\n\t\t\ttriggerVirtualEvent( \"vmouseover\", event, flags );\n\t\t\ttriggerVirtualEvent( \"vmousedown\", event, flags );\n\t\t}\n\t}\n",
    "js/libs/lavaca.js[184704:184902]": "\n\tif ( blockTouchTriggers ) {\n\t\treturn;\n\t}\n\n\tif ( !didScroll ) {\n\t\ttriggerVirtualEvent( \"vmousecancel\", event, getVirtualBindingFlags( event.target ) );\n\t}\n\n\tdidScroll = true;\n\tstartResetTimer();\n",
    "js/libs/lavaca.js[184938:185456]": "\n\tif ( blockTouchTriggers ) {\n\t\treturn;\n\t}\n\n\tvar t = getNativeEvent( event ).touches[ 0 ],\n\t\tdidCancel = didScroll,\n\t\tmoveThreshold = $.vmouse.moveDistanceThreshold,\n\t\tflags = getVirtualBindingFlags( event.target );\n\n\t\tdidScroll = didScroll ||\n\t\t\t( Math.abs( t.pageX - startX ) > moveThreshold ||\n\t\t\t\tMath.abs( t.pageY - startY ) > moveThreshold );\n\n\n\tif ( didScroll && !didCancel ) {\n\t\ttriggerVirtualEvent( \"vmousecancel\", event, flags );\n\t}\n\n\ttriggerVirtualEvent( \"vmousemove\", event, flags );\n\tstartResetTimer();\n",
    "js/libs/lavaca.js[185491:186388]": "\n\tif ( blockTouchTriggers ) {\n\t\treturn;\n\t}\n\n\tdisableTouchBindings();\n\n\tvar flags = getVirtualBindingFlags( event.target ),\n\t\tt;\n\ttriggerVirtualEvent( \"vmouseup\", event, flags );\n\n\tif ( !didScroll ) {\n\t\tvar ve = triggerVirtualEvent( \"vclick\", event, flags );\n\t\tif ( ve && ve.isDefaultPrevented() ) {\n\t\t\t// The target of the mouse events that follow the touchend\n\t\t\t// event don't necessarily match the target used during the\n\t\t\t// touch. This means we need to rely on coordinates for blocking\n\t\t\t// any click that is generated.\n\t\t\tt = getNativeEvent( event ).changedTouches[ 0 ];\n\t\t\tclickBlockList.push({\n\t\t\t\ttouchID: lastTouchID,\n\t\t\t\tx: t.clientX,\n\t\t\t\ty: t.clientY\n\t\t\t});\n\n\t\t\t// Prevent any mouse events that follow from triggering\n\t\t\t// virtual event notifications.\n\t\t\tblockMouseTriggers = true;\n\t\t}\n\t}\n\ttriggerVirtualEvent( \"vmouseout\", event, flags);\n\tdidScroll = false;\n\n\tstartResetTimer();\n",
    "js/libs/lavaca.js[186629:186631]": "",
    "js/libs/lavaca.js[189080:190433]": "\n\t\t\t// If this is the last virtual binding for this eventType,\n\t\t\t// remove its global handler from the document.\n\n\t\t\t--activeDocHandlers[ eventType ];\n\n\t\t\tif ( !activeDocHandlers[ eventType ] ) {\n\t\t\t\t$document.unbind( realType, mouseEventCallback );\n\t\t\t}\n\n\t\t\tif ( eventCaptureSupported ) {\n\t\t\t\t// If this is the last virtual mouse binding in existence,\n\t\t\t\t// remove our document touchstart listener.\n\n\t\t\t\t--activeDocHandlers[ \"touchstart\" ];\n\n\t\t\t\tif ( !activeDocHandlers[ \"touchstart\" ] ) {\n\t\t\t\t\t$document.unbind( \"touchstart\", handleTouchStart )\n\t\t\t\t\t\t.unbind( \"touchmove\", handleTouchMove )\n\t\t\t\t\t\t.unbind( \"touchend\", handleTouchEnd )\n\t\t\t\t\t\t.unbind( \"scroll\", handleScroll );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar $this = $( this ),\n\t\t\t\tbindings = $.data( this, dataPropertyName );\n\n\t\t\t// teardown may be called when an element was\n\t\t\t// removed from the DOM. If this is the case,\n\t\t\t// jQuery core may have already stripped the element\n\t\t\t// of any data bindings so we need to check it before\n\t\t\t// using it.\n\t\t\tif ( bindings ) {\n\t\t\t\tbindings[ eventType ] = false;\n\t\t\t}\n\n\t\t\t// Unregister the dummy event handler.\n\n\t\t\t$this.unbind( realType, dummyMouseHandler );\n\n\t\t\t// If this is the last virtual mouse binding on the\n\t\t\t// element, remove the binding data from the element.\n\n\t\t\tif ( !hasVirtualBindings( this ) ) {\n\t\t\t\t$this.removeData( dataPropertyName );\n\t\t\t}\n\t\t",
    "js/libs/lavaca.js[190933:193224]": "\n\t\tvar cnt = clickBlockList.length,\n\t\t\ttarget = e.target,\n\t\t\tx, y, ele, i, o, touchID;\n\n\t\tif ( cnt ) {\n\t\t\tx = e.clientX;\n\t\t\ty = e.clientY;\n\t\t\tthreshold = $.vmouse.clickDistanceThreshold;\n\n\t\t\t// The idea here is to run through the clickBlockList to see if\n\t\t\t// the current click event is in the proximity of one of our\n\t\t\t// vclick events that had preventDefault() called on it. If we find\n\t\t\t// one, then we block the click.\n\t\t\t//\n\t\t\t// Why do we have to rely on proximity?\n\t\t\t//\n\t\t\t// Because the target of the touch event that triggered the vclick\n\t\t\t// can be different from the target of the click event synthesized\n\t\t\t// by the browser. The target of a mouse/click event that is syntehsized\n\t\t\t// from a touch event seems to be implementation specific. For example,\n\t\t\t// some browsers will fire mouse/click events for a link that is near\n\t\t\t// a touch event, even though the target of the touchstart/touchend event\n\t\t\t// says the user touched outside the link. Also, it seems that with most\n\t\t\t// browsers, the target of the mouse/click event is not calculated until the\n\t\t\t// time it is dispatched, so if you replace an element that you touched\n\t\t\t// with another element, the target of the mouse/click will be the new\n\t\t\t// element underneath that point.\n\t\t\t//\n\t\t\t// Aside from proximity, we also check to see if the target and any\n\t\t\t// of its ancestors were the ones that blocked a click. This is necessary\n\t\t\t// because of the strange mouse/click target calculation done in the\n\t\t\t// Android 2.1 browser, where if you click on an element, and there is a\n\t\t\t// mouse/click handler on one of its ancestors, the target will be the\n\t\t\t// innermost child of the touched element, even if that child is no where\n\t\t\t// near the point of touch.\n\n\t\t\tele = target;\n\n\t\t\twhile ( ele ) {\n\t\t\t\tfor ( i = 0; i < cnt; i++ ) {\n\t\t\t\t\to = clickBlockList[ i ];\n\t\t\t\t\ttouchID = 0;\n\n\t\t\t\t\tif ( ( ele === target && Math.abs( o.x - x ) < threshold && Math.abs( o.y - y ) < threshold ) ||\n\t\t\t\t\t\t\t\t$.data( ele, touchTargetPropertyName ) === o.touchID ) {\n\t\t\t\t\t\t// XXX: We may want to consider removing matches from the block list\n\t\t\t\t\t\t//      instead of waiting for the reset timer to fire.\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tele = ele.parentNode;\n\t\t\t}\n\t\t}\n\t",
    "js/libs/lavaca.js[194520:194586]": "\n\t\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t\t",
    "js/libs/lavaca.js[194982:195113]": "\n\t\tvar originalType = event.type;\n\t\tevent.type = eventType;\n\t\t$.event.dispatch.call( obj, event );\n\t\tevent.type = originalType;\n\t",
    "js/libs/lavaca.js[195215:195822]": "\n\n\t\t\tvar thisObject = this,\n\t\t\t\t$this = $( thisObject ),\n\t\t\t\tscrolling,\n\t\t\t\ttimer;\n\n\t\t\tfunction trigger( event, state ) {\n\t\t\t\tscrolling = state;\n\t\t\t\ttriggerCustomEvent( thisObject, scrolling ? \"scrollstart\" : \"scrollstop\", event );\n\t\t\t}\n\n\t\t\t// iPhone triggers scroll after a small delay; use touchmove instead\n\t\t\t$this.bind( scrollEvent, function( event ) {\n\n\t\t\t\tif ( !$.event.special.scrollstart.enabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( !scrolling ) {\n\t\t\t\t\ttrigger( event, true );\n\t\t\t\t}\n\n\t\t\t\tclearTimeout( timer );\n\t\t\t\ttimer = setTimeout( function() {\n\t\t\t\t\ttrigger( event, false );\n\t\t\t\t}, 50 );\n\t\t\t});\n\t\t",
    "js/libs/lavaca.js[196029:197058]": "\n\n\t\t\t\tif ( event.which && event.which !== 1 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar origTarget = event.target,\n\t\t\t\t\torigEvent = event.originalEvent,\n\t\t\t\t\ttimer;\n\n\t\t\t\tfunction clearTapTimer() {\n\t\t\t\t\tclearTimeout( timer );\n\t\t\t\t}\n\n\t\t\t\tfunction clearTapHandlers() {\n\t\t\t\t\tclearTapTimer();\n\n\t\t\t\t\t$this.unbind( \"vclick\", clickHandler )\n\t\t\t\t\t\t.unbind( \"vmouseup\", clearTapTimer );\n\t\t\t\t\t$document.unbind( \"vmousecancel\", clearTapHandlers );\n\t\t\t\t}\n\n\t\t\t\tfunction clickHandler( event ) {\n\t\t\t\t\tclearTapHandlers();\n\n\t\t\t\t\t// ONLY trigger a 'tap' event if the start target is\n\t\t\t\t\t// the same as the stop target.\n\t\t\t\t\tif ( origTarget === event.target ) {\n\t\t\t\t\t\ttriggerCustomEvent( thisObject, \"tap\", event );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$this.bind( \"vmouseup\", clearTapTimer )\n\t\t\t\t\t.bind( \"vclick\", clickHandler );\n\t\t\t\t$document.bind( \"vmousecancel\", clearTapHandlers );\n\n\t\t\t\ttimer = setTimeout( function() {\n\t\t\t\t\ttriggerCustomEvent( thisObject, \"taphold\", $.Event( \"taphold\", { target: origTarget } ) );\n\t\t\t\t}, $.event.special.tap.tapholdThreshold );\n\t\t\t",
    "js/libs/lavaca.js[197530:197758]": "\n\t\t\tvar data = event.originalEvent.touches ?\n\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event;\n\t\t\treturn {\n\t\t\t\t\t\ttime: ( new Date() ).getTime(),\n\t\t\t\t\t\tcoords: [ data.pageX, data.pageY ],\n\t\t\t\t\t\torigin: $( event.target )\n\t\t\t\t\t};\n\t\t",
    "js/libs/lavaca.js[197787:197982]": "\n\t\t\tvar data = event.originalEvent.touches ?\n\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event;\n\t\t\treturn {\n\t\t\t\t\t\ttime: ( new Date() ).getTime(),\n\t\t\t\t\t\tcoords: [ data.pageX, data.pageY ]\n\t\t\t\t\t};\n\t\t",
    "js/libs/lavaca.js[198024:198444]": "\n\t\t\tif ( stop.time - start.time < $.event.special.swipe.durationThreshold &&\n\t\t\t\tMath.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&\n\t\t\t\tMath.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {\n\n\t\t\t\tstart.origin.trigger( \"swipe\" )\n\t\t\t\t\t.trigger( start.coords[0] > stop.coords[ 0 ] ? \"swipeleft\" : \"swiperight\" );\n\t\t\t}\n\t\t",
    "js/libs/lavaca.js[198467:199238]": "\n\t\t\tvar thisObject = this,\n\t\t\t\t$this = $( thisObject );\n\n\t\t\t$this.bind( touchStartEvent, function( event ) {\n\t\t\t\tvar start = $.event.special.swipe.start( event ),\n\t\t\t\t\tstop;\n\n\t\t\t\tfunction moveHandler( event ) {\n\t\t\t\t\tif ( !start ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstop = $.event.special.swipe.stop( event );\n\n\t\t\t\t\t// prevent scrolling\n\t\t\t\t\tif ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$this.bind( touchMoveEvent, moveHandler )\n\t\t\t\t\t.one( touchStopEvent, function() {\n\t\t\t\t\t\t$this.unbind( touchMoveEvent, moveHandler );\n\n\t\t\t\t\t\tif ( start && stop ) {\n\t\t\t\t\t\t\t$.event.special.swipe.handleSwipe( start, stop );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstart = stop = undefined;\n\t\t\t\t\t});\n\t\t\t});\n\t\t",
    "js/libs/lavaca.js[199434:199483]": "\n\t\t\t\t$( this ).bind( sourceEvent, $.noop );\n\t\t\t",
    "js/libs/lavaca.js[200200:200247]": "\n\t\t\t\t$( this ).bind( \"resize\", handler );\n\t\t\t",
    "js/libs/lavaca.js[200273:200322]": "\n\t\t\t\t$( this ).unbind( \"resize\", handler );\n\t\t\t",
    "js/libs/lavaca.js[200375:200732]": "\n\t\t\t\tcurr = ( new Date() ).getTime();\n\t\t\t\tdiff = curr - lastCall;\n\n\t\t\t\tif ( diff >= throttle ) {\n\n\t\t\t\t\tlastCall = curr;\n\t\t\t\t\t$( this ).trigger( \"throttledresize\" );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( heldCall ) {\n\t\t\t\t\t\tclearTimeout( heldCall );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Promise a held call will still execute\n\t\t\t\t\theldCall = setTimeout( handler, throttle - diff );\n\t\t\t\t}\n\t\t\t",
    "js/libs/lavaca.js[204027:204532]": "\n\t\t\t// If the event is supported natively, return false so that jQuery\n\t\t\t// will bind to the event using DOM methods.\n\t\t\tif ( $.support.orientation && !$.event.special.orientationchange.disabled ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Get the current orientation to avoid initial double-triggering.\n\t\t\tlast_orientation = get_orientation();\n\n\t\t\t// Because the orientationchange event doesn't exist, simulate the\n\t\t\t// event by testing window dimensions on resize.\n\t\t\twin.bind( \"throttledresize\", handler );\n\t\t",
    "js/libs/lavaca.js[204557:204929]": "\n\t\t\t// If the event is not supported natively, return false so that\n\t\t\t// jQuery will unbind the event using DOM methods.\n\t\t\tif ( $.support.orientation && !$.event.special.orientationchange.disabled ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Because the orientationchange event doesn't exist, unbind the\n\t\t\t// resize event handler.\n\t\t\twin.unbind( \"throttledresize\", handler );\n\t\t",
    "js/libs/lavaca.js[204960:205332]": "\n\t\t\t// Save a reference to the bound event handler.\n\t\t\tvar old_handler = handleObj.handler;\n\n\n\t\t\thandleObj.handler = function( event ) {\n\t\t\t\t// Modify event object, adding the .orientation property.\n\t\t\t\tevent.orientation = get_orientation();\n\n\t\t\t\t// Call the originally-bound event handler and return its result.\n\t\t\t\treturn old_handler.apply( this, arguments );\n\t\t\t};\n\t\t",
    "js/libs/lavaca.js[205502:205768]": "\n\t\t// Get the current orientation.\n\t\tvar orientation = get_orientation();\n\n\t\tif ( orientation !== last_orientation ) {\n\t\t\t// The orientation has changed, so trigger the orientationchange event.\n\t\t\tlast_orientation = orientation;\n\t\t\twin.trigger( event_name );\n\t\t}\n\t",
    "js/libs/lavaca.js[206000:206832]": "\n\t\tvar isPortrait = true, elem = document.documentElement;\n\n\t\t// prefer window orientation to the calculation based on screensize as\n\t\t// the actual screen resize takes place before or after the orientation change event\n\t\t// has been fired depending on implementation (eg android 2.3 is before, iphone after).\n\t\t// More testing is required to determine if a more reliable method of determining the new screensize\n\t\t// is possible when orientationchange is fired. (eg, use media queries + element + opacity)\n\t\tif ( $.support.orientation ) {\n\t\t\t// if the window orientation registers as 0 or 180 degrees report\n\t\t\t// portrait, otherwise landscape\n\t\t\tisPortrait = portrait_map[ window.orientation ];\n\t\t} else {\n\t\t\tisPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;\n\t\t}\n\n\t\treturn isPortrait ? \"portrait\" : \"landscape\";\n\t",
    "js/libs/lavaca.js[206872:206948]": "\n\t\treturn fn ? this.bind( event_name, fn ) : this.trigger( event_name );\n\t",
    "js/libs/lavaca.js[208145:208199]": "\n    e.preventDefault();\n    e.stopPropagation();\n  ",
    "js/libs/lavaca.js[209900:210166]": "\n      // If the error is equal to \"locked\", it means that the router or view manager was\n      // busy while while the user was attempting to navigate\n      if (err !== 'locked') {\n        alert('An error occurred while trying to display this URL.');\n      }\n    ",
    "js/libs/lavaca.js[210340:211110]": "\n      var link = $(e.currentTarget),\n          url = link.attr('href'),\n          rel = link.attr('rel'),\n          target = link.attr('target'),\n          isExternal = link.is('[data-external]');\n      if (/^((mailto)|(tel)|(sms))\\:/.test(url) || link.is('.ignore')) {\n        location.href = url;\n        return true;\n      } else {\n        e.preventDefault();\n      }\n      if (rel === 'back') {\n        History.back();\n      } else if (isExternal || rel === 'nofollow' || target === '_blank') {\n        e.stopPropagation();\n        new ChildBrowser().showWebPage(url);\n      } else if (rel === 'cancel') {\n        this.viewManager.dismiss(e.currentTarget);\n      } else if (url) {\n        this.router.exec(url, null, null).error(this.onInvalidRoute);\n      }\n    ",
    "js/libs/lavaca.js[211481:211551]": "\n      return Connectivity.ajax.apply(Connectivity, arguments);\n    ",
    "js/libs/lavaca.js[214676:214796]": "\n    collection.trigger(event, {\n      previousIndex: previousIndex,\n      index: index,\n      model: model\n    });\n  ",
    "js/libs/lavaca.js[214842:215145]": "\n    var compareVal = descending ? 1 : -1;\n    return function(modelA, modelB) {\n      var attrA = modelA.get(attr),\n          attrB = modelB.get(attr);\n      return (attrA === attrB)\n              ? 0\n              : attrA < attrB\n                ? compareVal\n                : -compareVal;\n    };\n  ",
    "js/libs/lavaca.js[217475:217560]": "\n      Model.prototype.clear.apply(this, arguments);\n      this.clearModels();\n    ",
    "js/libs/lavaca.js[217688:217985]": "\n      var i = -1,\n          model;\n      while (!!(model = this.models[++i])) {\n        this.remove(model);\n      }\n      this.changedOrder = false;\n      this.addedItems.length\n        = this.removedItems.length\n        = this.changedItems.length\n        = this.models.length\n        = 0;\n    ",
    "js/libs/lavaca.js[218241:218819]": "\n      var model = data instanceof this.TModel\n            ? data\n            : this.TModel.prototype instanceof Collection\n              ? new this.TModel(data[this.TModel.prototype.itemsProperty], data)\n              : new this.TModel(data),\n          index = ArrayUtils.indexOf(this.models, model);\n      if (index === -1) {\n        model\n          .on('change', this.onItemEvent, this)\n          .on('invalid', this.onItemEvent, this)\n          .on('saveSuccess', this.onItemEvent, this)\n          .on('saveError', this.onItemEvent, this);\n      }\n      return model;\n    ",
    "js/libs/lavaca.js[219918:221255]": "\n      var result = false,\n          idAttribute = this.TModel.prototype.idAttribute,\n          compareObj = {},\n          id,\n          i,\n          j,\n          model,\n          index,\n          items;\n      items = item && ArrayUtils.isArray(item) ? item : Array.prototype.slice.call(arguments, 1);\n      for (i = 0, j = items.length; i < j; i++) {\n        model = items[i];\n        if (typeof model === 'object') {\n          model = this.prepare(model);\n\n          // If it's a duplicate, remove the old item\n          id = model.get(idAttribute);\n          if (id !== null) {\n            compareObj[idAttribute] = id;\n            index = this.indexOf(compareObj);\n            if (index > -1 && !this.allowDuplicatedIds) {\n              this.remove(index);\n            }\n          }\n\n          this.models.splice(insertIndex, 0, model);\n          if (!this.suppressTracking) {\n            ArrayUtils.remove(this.removedItems, model);\n            ArrayUtils.remove(this.changedItems, model);\n            ArrayUtils.pushIfNotExists(this.addedItems, model);\n          }\n          _triggerItemEvent(this, 'addItem', null, insertIndex, this.models[insertIndex]);\n          insertIndex++;\n          result = true;\n        } else {\n          throw 'Only objects can be added to a Collection.';\n        }\n      }\n\n      return result;\n    ",
    "js/libs/lavaca.js[221964:222186]": "\n      if (arguments.length && arguments[0] instanceof Array) {\n        return this.add.apply(this, arguments[0]);\n      }\n      return this.insert.call(this, this.count(), Array.prototype.slice.call(arguments, 0));\n    ",
    "js/libs/lavaca.js[222677:223135]": "\n      if (oldIndex instanceof this.TModel) {\n        oldIndex = ArrayUtils.indexOf(this.models, oldIndex);\n      }\n      if (oldIndex > -1) {\n        var model = this.models.splice(oldIndex, 1)[0];\n        if (model) {\n          this.models.splice(newIndex, 0, model);\n          if (!this.suppressTracking) {\n            this.changedOrder = true;\n          }\n          _triggerItemEvent(this, 'moveItem', oldIndex, newIndex, model);\n        }\n      }\n    ",
    "js/libs/lavaca.js[224908:226659]": "\n      var n, it, items, index, i, removed;\n\n      if (arguments.length === 1 && ArrayUtils.isArray(item)) {\n        n = 0;\n        removed = [];\n        while (!!(it = item[n++])) {\n          removed.push(this.remove(it));\n        }\n        return removed;\n      } else if (arguments.length > 1) {\n        // Prevent passing multiple numeric arguments,\n        // which could have unexpected behavior\n        if (typeof item === 'number' && item % 1 === 0) { // is integer\n          return this.remove(item);\n        } else {\n          return this.remove([].slice.call(arguments));\n        }\n      }\n\n      if (item instanceof this.TModel) {\n        index = ArrayUtils.remove(this.models, item);\n        if (index > -1) {\n          if (!this.suppressTracking) {\n            ArrayUtils.remove(this.addedItems, item);\n            ArrayUtils.remove(this.changedItems, item);\n            ArrayUtils.pushIfNotExists(this.removedItems, item);\n          }\n          item\n            .off('change', this.onItemEvent)\n            .off('invalid', this.onItemEvent)\n            .off('saveSuccess', this.onItemEvent)\n            .off('saveError', this.onItemEvent);\n          _triggerItemEvent(this, 'removeItem', index, null, item);\n          return true;\n        } else {\n          return false;\n        }\n      } else if (typeof item === 'number' && item % 1 === 0) { // is integer\n        if (item >= 0 && item < this.count()) {\n          return this.remove(this.itemAt(item));\n        } else {\n          return false;\n        }\n      } else {\n        items = this.filter(item),\n        i = -1,\n        removed = false;\n        while (!!(item = items[++i])) {\n          removed = this.remove(item) || removed;\n        }\n        return removed;\n      }\n    ",
    "js/libs/lavaca.js[228415:228580]": "\n          for (var n in attrs) {\n            if (item.get(n) !== attrs[n]) {\n              return false;\n            }\n          }\n          return true;\n        ",
    "js/libs/lavaca.js[229489:229542]": "\n      return this.filter(test, 1)[0] || null;\n    ",
    "js/libs/lavaca.js[230325:230434]": "\n      var match = this.first(test);\n      return match ? ArrayUtils.indexOf(this.models, match) : -1;\n    ",
    "js/libs/lavaca.js[233140:233761]": "\n      var comparator = typeof attribute === \"function\" ? attribute : _getComparator(attribute, descending),\n          oldModels = clone(this.models),\n          oldIndex;\n      this.models.sort(comparator, this);\n      if (!this.suppressTracking) {\n        this.changedOrder = true;\n      }\n      if (!this.suppressEvents) {\n        this.each(function(index, model) {\n          oldIndex = ArrayUtils.indexOf(oldModels, model);\n          if (oldIndex !== index) {\n            _triggerItemEvent(this, 'moveItem', ArrayUtils.indexOf(oldModels, model), index, model);\n          }\n        });\n      }\n      return this;\n    ",
    "js/libs/lavaca.js[233989:234489]": "\n      var oldModels = clone(this.models),\n          oldIndex;\n      this.models.reverse();\n      if (!this.suppressTracking) {\n        this.changedOrder = true;\n      }\n      if (!this.suppressEvents) {\n        this.each(function(index, model) {\n          oldIndex = ArrayUtils.indexOf(oldModels, model);\n          if (oldIndex !== index) {\n            _triggerItemEvent(this, 'moveItem', ArrayUtils.indexOf(oldModels, model), index, model);\n          }\n        });\n      }\n      return this;\n    ",
    "js/libs/lavaca.js[234732:235183]": "\n      var model = e.target,\n          index = ArrayUtils.indexOf(this.models, model);\n      if (e.type === 'change') {\n        ArrayUtils.pushIfNotExists(this.changedItems, model);\n      } else if (e.type === 'saveSuccess') {\n        ArrayUtils.remove(this.changedItems, model);\n      }\n      this.trigger(e.type + 'Item', merge({}, e, {\n        target: model,\n        model: model,\n        index: index,\n        previousIndex: null\n      }));\n    ",
    "js/libs/lavaca.js[235384:235901]": "\n      var list;\n      response = this.parse(response);\n      if (this.responseFilter && typeof this.responseFilter === 'function') {\n        response = this.responseFilter(response);\n      }\n      list = response;\n      if (!(list instanceof Array)) {\n        this.apply(response);\n        if (response && response.hasOwnProperty(this.itemsProperty)) {\n          list = response[this.itemsProperty];\n        }\n      }\n      this.add.apply(this, list);\n      this.trigger('fetchSuccess', {response: response});\n    ",
    "js/libs/lavaca.js[236142:236639]": "\n      return this.save(function(model, changedAttributes, attributes) {\n        var id = this.id(),\n            data;\n        if (this.isNew()) {\n          data = attributes;\n        } else {\n          changedAttributes[this.idAttribute] = id;\n          data = changedAttributes;\n        }\n        return (new Promise(this)).when(Connectivity.ajax({\n          url: url,\n          cache: false,\n          type: 'POST',\n          data: data,\n          dataType: 'json'\n        }));\n      });\n    ",
    "js/libs/lavaca.js[237588:237618]": "\n      return response;\n    ",
    "js/libs/lavaca.js[237857:237876]": "\n    return s;\n  ",
    "js/libs/lavaca.js[239323:239671]": "\n    var args,\n        fn = _noop,\n        i,\n        j;\n    if (arguments[1] instanceof Array) {\n      args = arguments[1];\n      fn = arguments[2] || _noop;\n    } else {\n      args = [].slice.call(arguments, 1);\n    }\n    for (i = 0, j = args.length; i < j; i++) {\n      s = s.split('{' + i + '}').join(fn(args[i] + ''));\n    }\n    return s;\n  ",
    "js/libs/lavaca.js[239888:240007]": "\n    s = '' + s;\n    for (var n in _htmlEscapes) {\n      s = s.split(n).join(_htmlEscapes[n]);\n    }\n    return s;\n  ",
    "js/libs/lavaca.js[242380:242431]": "\n          document.title = state.title;\n        ",
    "js/libs/lavaca.js[244086:244157]": "\n      return StringUtils.format(str, args, encodeURIComponent);\n    ",
    "js/libs/lavaca.js[244619:244693]": "\n      return this.router.unlock().exec(this.url(str, args || []));\n    ",
    "js/libs/lavaca.js[245267:265293]": "\n\n  var EventDispatcher = require('lavaca/events/EventDispatcher'),\n      Connectivity = require('lavaca/net/Connectivity'),\n      ArrayUtils = require('lavaca/util/ArrayUtils'),\n      Cache = require('lavaca/util/Cache'),\n      Promise = require('lavaca/util/Promise'),\n      clone = require('mout/lang/deepClone'),\n      merge = require('mout/object/merge'),\n      Config = require('lavaca/util/Config');\n\n\n  var UNDEFINED;\n\n  function _triggerAttributeEvent(model, event, attribute, previous, value, messages) {\n    model.trigger(event, {\n      attribute: attribute,\n      previous: previous === UNDEFINED ? null : previous,\n      value: value === UNDEFINED ? model.get(attribute) : value,\n      messages: messages || []\n    });\n  }\n\n  function _setFlagOn(model, name, flag) {\n    var keys = model.flags[flag];\n    if (!keys) {\n      keys = model.flags[flag] = [];\n    }\n    if (!ArrayUtils.contains(keys, name)) {\n      keys.push(name);\n    }\n  }\n\n  function _suppressChecked(model, suppress, callback) {\n    suppress = !!suppress;\n    var props = ['suppressValidation', 'suppressEvents', 'suppressTracking'],\n        old = {},\n        i = -1,\n        prop,\n        result;\n    while (!!(prop = props[++i])) {\n      old[prop] = model[prop];\n      model[prop] = suppress || model[prop];\n    }\n    result = callback.call(model);\n    i = -1;\n    while (!!(prop = props[++i])) {\n      model[prop] = old[prop];\n    }\n    return result;\n  }\n\n  function _isValid(messages){\n    var isValid = true;\n    for(var attribute in messages){\n      if (messages[attribute].length > 0){\n        isValid = false;\n      }\n    }\n    messages.isValid = isValid;\n    return messages;\n  }\n\n\n  // Virtual type\n  /**\n   * Event type used when an attribute is modified\n   * @class lavaca.mvc.AttributeEvent\n   * @extends Event\n   */\n   /**\n   * The name of the event-causing attribute\n   * @property {String} attribute\n   * @default null\n   */\n   /**\n   * The value of the attribute before the event\n   * @property {Object} previous\n   * @default null\n   */\n   /**\n   * The value of the attribute after the event\n   * @property {Object} value\n   * @default null\n   */\n   /**\n   * A list of validation messages the change caused\n   * @property {Array} messages\n   * @default []\n   */\n\n  /**\n   * Basic model type\n   * @class lavaca.mvc.Model\n   * @extends lavaca.events.EventDispatcher\n   *\n   * Place the events where they are triggered in the code, see the yuidoc syntax reference and view.js for rendersuccess trigger\n   * @event change\n   * @event invalid\n   * @event fetchSuccess\n   * @event fetchError\n   * @event saveSuccess\n   * @event saveError\n   *\n   * @constructor\n   * @param {Object} [map]  A parameter hash to apply to the model\n   */\n  var Model = EventDispatcher.extend(function(map) {\n    EventDispatcher.call(this);\n    this.attributes = new Cache();\n    this.rules = new Cache();\n    this.unsavedAttributes = [];\n    this.flags = {};\n    if (this.defaults) {\n      map = merge({}, this.defaults, map);\n    }\n    if (map) {\n      this.suppressEvents\n        = this.suppressTracking\n        = true;\n      this.apply(map);\n      this.suppressEvents\n        = this.suppressTracking\n        = false;\n    }\n  }, {\n    /**\n     * When true, attributes are not validated\n     * @property suppressValidation\n     * @default false\n     *\n     * @type Boolean\n     */\n\n    suppressValidation: false,\n    /**\n     * When true, changes to attributes are not tracked\n     * @property suppressTracking\n     * @default false\n     *\n     * @type Boolean\n     */\n\n    suppressTracking: false,\n    /**\n     * Gets the value of a attribute\n     * @method get\n     *\n     * @param {String} attribute  The name of the attribute\n     * @return {Object}  The value of the attribute, or null if there is no value\n     */\n    get: function(attribute) {\n      var attr = this.attributes.get(attribute),\n          flags;\n      if (typeof attr === 'function') {\n        flags = this.flags[Model.DO_NOT_COMPUTE];\n        return !flags || ArrayUtils.indexOf(flags, attribute) === -1 ? attr.call(this) : attr;\n      }\n      return attr;\n    },\n    /**\n     * Determines whether or not an attribute can be assigned\n     * @method canSet\n     *\n     * @param {String} attribute  The name of the attribute\n     * @return {Boolean}  True if you can assign to the attribute\n     */\n    canSet: function() {\n      return true;\n    },\n    /**\n     * Sets the value of the attribute, if it passes validation\n     * @method set\n     *\n     * @param {String} attribute  The name of the attribute\n     * @param {Object} value  The new value\n     * @return {Boolean}  True if attribute was set, false otherwise\n     *\n     */\n    /**\n     * Sets the value of the attribute, if it passes validation\n     * @method set\n     *\n     * @param {String} attribute  The name of the attribute\n     * @param {Object} value  The new value\n     * @param {String} flag  A metadata flag describing the attribute\n     * @param {Boolean} suppress  When true, validation, events and tracking are suppressed\n     * @return {Boolean}  True if attribute was set, false otherwise\n     */\n//* @event invalid\n//* @event change\n\n\n    set: function(attribute, value, flag, suppress) {\n      return _suppressChecked(this, suppress, function() {\n        if (!this.canSet(attribute)) {\n          return false;\n        }\n        var previous = this.attributes.get(attribute),\n            messages = this.suppressValidation ? [] : this.validate(attribute, value);\n        if (messages.length) {\n          _triggerAttributeEvent(this, 'invalid', attribute, previous, value, messages);\n          return false;\n        } else {\n          if (previous !== value) {\n            this.attributes.set(attribute, value);\n            if (flag) {\n              _setFlagOn(this, attribute, flag);\n            }\n            _triggerAttributeEvent(this, 'change', attribute, previous, value);\n            if (!this.suppressTracking\n                && !ArrayUtils.contains(this.unsavedAttributes, attribute)) {\n              this.unsavedAttributes.push(attribute);\n            }\n          }\n          return true;\n        }\n      });\n    },\n    /**\n     * Determines whether or not this model has a named attribute\n     * @method has\n     *\n     * @param {String} attribute  The name of the attribute\n     * @return {Boolean}  True if the attribute exists and has a value\n     */\n    has: function(attribute) {\n      return this.get(attribute) !== null;\n    },\n    /**\n     * The name of the ID attribute\n     * @property id\n     * @default 'id'\n     *\n     * @type String\n     */\n\n    idAttribute: 'id',\n    /**\n     * Gets the ID of the model\n     * @method id\n     *\n     * @return {String}  The ID of the model\n     */\n    id: function() {\n      return this.get(this.idAttribute);\n    },\n    /**\n     * Determines whether or not this model has been saved before\n     * @method isNew\n     *\n     * @return {Boolean}  True when the model has no ID associated with it\n     */\n    isNew: function() {\n      return null === this.id();\n    },\n    /**\n     * Ensures that a map is suitable to be applied to this model\n     * @method parse\n     *\n     * @param {Object} map  The string or key-value hash to parse\n     * @return {Object}  The parsed version of the map\n     */\n    parse: function(map) {\n      if (typeof map === 'string') {\n        map = JSON.parse(map);\n      }\n      return map;\n    },\n    /**\n     * Sets each attribute of this model according to the map\n     * @method apply\n     *\n     * @param {Object} map  The string or key-value map to parse and apply\n     */\n    /**\n     * Sets each attribute of this model according to the map\n     * @method apply\n     *\n     * @param {Object} map  The string or key-value map to parse and apply\n     * @param {Boolean} suppress  When true, validation, events and tracking are suppressed\n     */\n    apply: function(map, suppress) {\n      _suppressChecked(this, suppress, function() {\n        map = this.parse(map);\n        for (var n in map) {\n          this.set(n, map[n]);\n        }\n      });\n    },\n    /**\n     * Removes all data from the model or removes selected flag from model.\n     * @method clear\n     *\n     * @sig\n     * Removes all flagged data from the model\n     * @param {String} flag  The metadata flag describing the data to remove\n     */\n    clear: function(flag) {\n      if (flag) {\n        var attrs = this.flags[flag],\n            i = -1,\n            attr,\n            item;\n        if (attrs) {\n          while (!!(attr = attrs[++i])) {\n            ArrayUtils.remove(this.unsavedAttributes, attr);\n            item = this.get(attr);\n            if (item && item.dispose) {\n              item.dispose();\n            }\n            this.set(attr, null);\n          }\n        }\n      } else {\n        this.attributes.dispose();\n        this.attributes = new Cache();\n        this.unsavedAttributes.length = 0;\n      }\n    },\n    /**\n     * Makes a copy of this model\n     * @method clone\n     *\n     * @return {Lavaca.mvc.Model}  The copy\n     */\n    clone: function() {\n      return new this.constructor(this.attributes.toObject());\n    },\n    /**\n     * Adds a validation rule to this model\n     * @method addRule\n     *\n     * @param {String} attribute  The name of the attribute to which the rule applies\n     * @param {Function} callback  The callback to use to validate the attribute, in the\n     *   form callback(attribute, value)\n     * @param {String} message  A text message used when a value fails the test\n     */\n    addRule: function(attribute, callback, message) {\n      this.rules.get(attribute, []).push({rule: callback, message: message});\n    },\n    /**\n     * Validates all attributes on the model\n     * @method validate\n     *\n     * @return {Object}  A map of attribute names to validation error messages\n     */\n    /**\n     * Runs validation tests for a specific attribute\n     * @method validate\n     *\n     * @param {String}  The name of the attribute to test\n     * @return {Array}  A list of validation error messages\n     */\n    /**\n     * Runs validation against a potential value for a attribute\n     * @method validate\n     * @param {String} attribute  The name of the attribute\n     * @param {Object} value  The potential value for the attribute\n     * @return {Array}  A list of validation error messages\n     */\n    validate: function(attribute, value) {\n      var messages,\n          rules,\n          i = -1,\n          rule;\n      if (attribute) {\n        messages = [];\n        value = value === UNDEFINED ? this.get(attribute, value) : value;\n        rules = this.rules.get(attribute);\n        if (rules) {\n          while (!!(rule = rules[++i])) {\n            if (!rule.rule(attribute, value)) {\n              messages.push(rule.message);\n            }\n          }\n        }\n        return messages;\n      } else {\n        messages = {};\n        this.rules.each(function(attributeName) {\n          messages[attributeName] = this.validate(attributeName);\n        }, this);\n        return _isValid(messages);\n      }\n    },\n    /**\n     * Processes the data received from a fetch request\n     * @method onFetchSuccess\n     *\n     * @param {Object} response  The response data\n     */\n    onFetchSuccess: function(response) {\n      response = this.parse(response);\n      if (this.responseFilter && typeof this.responseFilter === 'function') {\n        response = this.responseFilter(response);\n      }\n      this.apply(response, true);\n      this.trigger('fetchSuccess', {response: response});\n    },\n    /**\n     * Triggered when the model is unable to fetch data\n     * @method onFetchError\n     *\n     * @param {Object} value  The error value\n     */\n    onFetchError: function(response) {\n      this.trigger('fetchError', {response: response});\n    },\n    /**\n     * Loads the data for this model from the server and only apply to this model attributes (Note: Does not clear the model first)\n     * @method fetch\n     *\n     * @event fetchSuccess\n     * @event fetchError\n     */\n    /**\n     * Loads the data for this model from the server and only apply to this model attributes (Note: Does not clear the model first)\n     * @method fetch\n     *\n     * @param {String} url  The URL from which to load the data\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Loads the data for this model from the server and only apply to this model attributes (Note: Does not clear the model first)\n     * @method fetch\n     *\n     * @param {Object} options  jQuery AJAX settings. If url property is missing, fetch() will try to use the url property on this model\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Loads the data for this model from the server and only apply to this model attributes (Note: Does not clear the model first)\n     * @method fetch\n     *\n     * @param {String} url  The URL from which to load the data\n     * @param {Object} options  jQuery AJAX settings\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    fetch: function(url, options) {\n      if (typeof url === 'object') {\n        options = url;\n      } else {\n        options = clone(options || {});\n        options.url = url;\n      }\n      options.url = this.getApiURL(options.url || this.url);\n      return Promise.when(this, Connectivity.ajax(options))\n        .success(this.onFetchSuccess)\n        .error(this.onFetchError);\n    },\n    /**\n     * Converts a relative path to an absolute api url based on environment config 'apiRoot'\n     * @method getApiURL\n     *\n     * @param {String} relPath  A relative path\n     * @return {String}  A formated api url or an apparently bad url '/please_set_model_url' if relPath argument is faslsy\n     */\n    getApiURL: function(relPath) {\n      var badURL = '/please_set_model_url',\n          apiRoot = Config.get('apiRoot'),\n          apiURL;\n      if (!relPath) {\n        return badURL;\n      }\n      apiURL = (apiRoot || '') + relPath;\n      return apiURL;\n    },\n    /**\n     * Saves the model\n     * @method save\n     *\n     *\n     * @param {Function} callback  A function callback(model, changedAttributes, attributes)\n     *   that returns either a promise or a truthy value\n     *   indicating whether the operation failed or succeeded\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Saves the model\n     * @method save\n     *\n     * @param {Function} callback  A function callback(model, changedAttributes, attributes)\n     *   that returns either a promise or a truthy value\n     *   indicating whether the operation failed or succeeded\n     * @param {Object} thisp  The context for the callback\n     * @return {Lavaca.util.Promise}  A promise\n     */\n\n//* @event saveSuccess\n//* @event saveError\n\n    save: function(callback, thisp) {\n      var promise = new Promise(this),\n          attributes = this.toObject(),\n          changedAttributes = {},\n          i = -1,\n          attribute,\n          result;\n      while (!!(attribute = this.unsavedAttributes[++i])) {\n        changedAttributes[attribute] = attributes[attribute];\n      }\n      promise\n        .success(function(value) {\n          var idAttribute = this.idAttribute;\n          if (this.isNew() && value[idAttribute] !== UNDEFINED) {\n            this.set(idAttribute, value[idAttribute]);\n          }\n          this.unsavedAttributes = [];\n          this.trigger('saveSuccess', {response: value});\n        })\n        .error(function(value) {\n          this.trigger('saveError', {response: value});\n        });\n      result = callback.call(thisp || this, this, changedAttributes, attributes);\n      if (result instanceof Promise) {\n        promise.when(result);\n      } else if (result) {\n        promise.resolve(result);\n      } else {\n        promise.reject(result);\n      }\n      return promise;\n    },\n    /**\n     * Saves the model to the server via POST\n     * @method saveToServer\n     *\n     * @param {String} url  The URL to which to post the data\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    saveToServer: function(url) {\n      return this.save(function(model, changedAttributes, attributes) {\n        var id = this.id(),\n            data;\n        if (this.isNew()) {\n          data = attributes;\n        } else {\n          changedAttributes[this.idAttribute] = id;\n          data = changedAttributes;\n        }\n        return Promise.when(this, Connectivity.ajax({\n            url: url,\n            cache: false,\n            type: 'POST',\n            data: data,\n            dataType: 'json'\n          }));\n      });\n    },\n    /**\n     * Converts this model to a key-value hash\n     * @method toObject\n     *\n     * @return {Object}  The key-value hash\n     */\n    toObject: function() {\n      var obj = this.attributes.toObject(),\n          flags;\n      for(var key in obj) {\n        if(typeof obj[key] === \"function\") {\n          flags = this.flags[Model.DO_NOT_COMPUTE];\n          if (!flags || ArrayUtils.indexOf(flags, key) === -1) {\n            obj[key] = obj[key].call(this);\n          }\n        }\n      }\n      return obj;\n    },\n    /**\n     * Converts this model to JSON\n     * @method toJSON\n     *\n     * @return {String}  The JSON string representing the model\n     */\n    toJSON: function() {\n      return JSON.stringify(this.toObject());\n    },\n    /**\n     * Bind an event handler to this object\n     * @method on\n     *\n     *\n     * @param {String} type  The name of the event\n     * @param {Function} callback  The function to execute when the event occurs\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    /**\n     * Bind an event handler to this object\n     * @method on\n     *\n     * @param {String} type  The name of the event\n     * @param {String} attr  An attribute to which to limit the scope of events\n     * @param {Function} callback  The function to execute when the event occurs\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    /**\n     * Bind an event handler to this object\n     * @method on\n     * @param {String} type  The name of the event\n     * @param {Function} callback  The function to execute when the event occurs\n     * @param {Object} thisp  The context of the handler\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    /**\n     * Bind an event handler to this object\n     * @method on\n     * @param {String} type  The name of the event\n     * @param {String} attr  An attribute to which to limit the scope of events\n     * @param {Function} callback  The function to execute when the event occurs\n     * @param {Object} thisp  The context of the handler\n     * @return {Lavaca.events.EventDispatcher}  This event dispatcher (for chaining)\n     */\n    on: function(type, attr, callback, thisp) {\n      if (typeof attr === 'function') {\n        thisp = callback;\n        callback = attr;\n        attr = null;\n      }\n      function handler(e) {\n        if (!attr || e.attribute === attr) {\n          callback.call(thisp || this, e);\n        }\n      }\n      handler.fn = callback;\n      handler.thisp = thisp;\n      return EventDispatcher.prototype.on.call(this, type, handler, thisp);\n    },\n    /**\n    * Filters the raw response from onFetchSuccess() down to a custom object. (Meant to be overriden)\n    * @method responseFilter\n    *\n    * @param {Object} response  The raw response passed in onFetchSuccess()\n    * @return {Object}  An object to be applied to this model instance\n    */\n    responseFilter: function(response) {\n      return response;\n    }\n  });\n  /**\n   * @field {String} SENSITIVE\n   * @static\n   * @default 'sensitive'\n   * Flag indicating that data is sensitive\n   */\n  Model.SENSITIVE = 'sensitive';\n  /**\n   * @field {String} DO_NOT_COMPUTE\n   * @static\n   * @default 'do_not_compute'\n   * Flag indicating that the selected attribute should not be executed\n   * as a computed property and should instead just return the function.\n   */\n  Model.DO_NOT_COMPUTE = 'do_not_compute';\n\n  return Model;\n\n",
    "js/libs/lavaca.js[265460:270493]": "\n\n  var $ = require('$'),\n      Model = require('lavaca/mvc/Model'),\n      View = require('lavaca/mvc/View'),\n      Template = require('lavaca/ui/Template'),\n      Promise = require('lavaca/util/Promise'),\n      delay = require('lavaca/util/delay');\n\n  /**\n   * Page View type, represents an entire screen\n   * @class lavaca.mvc.PageView\n   * @extends lavaca.mvc.View\n   *\n   * @constructor\n   * @param {Object} el  The element that the PageView is bound to\n   * @param {Object} model  The model used by the view\n   * @param {Number} [layer]  The index of the layer on which the view sits\n   *\n   */\n  var PageView = View.extend(function(el, model, layer) {\n\n    View.call(this, el, model);\n    /**\n     * The index of the layer on which the view sits\n     * @property {Number} layer\n     * @default 0\n     */\n    this.layer = layer || 0;\n\n\n  }, {\n\n    /**\n     * The element containing the view\n     * @property {jQuery} shell\n     * @default null\n     */\n    shell: null,\n\n    /**\n     * Creates the view's wrapper element\n     * @method wrapper\n     * @return {jQuery}  The wrapper element\n     */\n    wrapper: function() {\n      return $('<div class=\"view\"></div>');\n    },\n    /**\n     * Creates the view's interior content wrapper element\n     * @method interior\n     * @return {jQuery} The interior content wrapper element\n     */\n    interior: function() {\n      return $('<div class=\"view-interior\"></div>');\n    },\n\n\n    /**\n     * Adds this view to a container\n     * @method insertInto\n     * @param {jQuery} container  The containing element\n     */\n    insertInto: function(container) {\n      if (this.shell.parent()[0] !== container[0]) {\n        var layers = container.children('[data-layer-index]'),\n            i = -1,\n            layer;\n        while (!!(layer = layers[++i])) {\n          layer = $(layer);\n          if (layer.attr('data-layer-index') > this.index) {\n            this.shell.insertBefore(layer);\n            return;\n          }\n        }\n        container.append(this.shell);\n      }\n    },\n    /**\n     * Renders the view using its template and model, overrides the View class render method\n     * @method render\n     *\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    render: function() {\n      var promise = new Promise(this),\n          renderPromise = new Promise(this),\n          template = Template.get(this.template),\n          model = this.model;\n      if (model instanceof Model) {\n        model = model.toObject();\n      }\n      if (this.el) {\n        this.el.remove();\n      }\n\n      this.shell = this.wrapper();\n      this.el = this.interior();\n      this.shell.append(this.el);\n      this.shell.attr('data-layer-index', this.layer);\n      if (this.className) {\n        this.shell.addClass(this.className);\n      }\n      promise\n        .success(function(html) {\n          /**\n           * Fires when html from template has rendered\n           * @event rendersuccess\n           */\n          this.trigger('rendersuccess', {html: html});\n          renderPromise.resolve();\n        })\n        .error(function(err) {\n          /**\n           * Fired when there was an error during rendering process\n           * @event rendererror\n           */\n          this.trigger('rendererror', {err: err});\n          renderPromise.reject();\n        });\n      template\n        .render(model)\n        .success(promise.resolver())\n        .error(promise.rejector());\n\n      return renderPromise;\n    },\n    /**\n     * Executes when the user navigates to this view\n     * @method enter\n     * @param {jQuery} container  The parent element of all views\n     * @param {Array} exitingViews  The views that are exiting as this one enters\n     * @return {lavaca.util.Promise}  A promise\n     */\n    enter: function(container) {\n      var promise = new Promise(this),\n          renderPromise;\n      container = $(container);\n      if (!this.hasRendered) {\n        renderPromise = this\n          .render()\n          .error(promise.rejector());\n      }\n      this.insertInto(container);\n      if (renderPromise) {\n        promise.when(renderPromise);\n      } else {\n        delay(promise.resolver());\n      }\n      promise.then(function() {\n        /**\n         * Fired when there was an error during rendering process\n         * @event rendererror\n         */\n        this.trigger('enter');\n      });\n      return promise;\n    },\n    /**\n     * Executes when the user navigates away from this view\n     * @method exit\n     *\n     * @param {jQuery} container  The parent element of all views\n     * @param {Array} enteringViews  The views that are entering as this one exits\n     * @return {lavaca.util.Promise}  A promise\n     */\n    exit: function() {\n      var promise = new Promise(this);\n      this.shell.detach();\n      delay(promise.resolver());\n      promise.then(function() {\n        /**\n         * Fired when there was an error during rendering process\n         * @event rendererror\n         */\n        this.trigger('exit');\n      });\n      return promise;\n    }\n  });\n\n  return PageView;\n\n",
    "js/libs/lavaca.js[270640:277281]": "\n\n  var Disposable = require('lavaca/util/Disposable'),\n      delay = require('lavaca/util/delay'),\n      clone = require('mout/lang/deepClone'),\n      merge = require('mout/object/merge');\n\n  function _multivariablePattern() {\n    return new RegExp('\\\\{\\\\*(.*?)\\\\}', 'g');\n  }\n\n  function _variablePattern() {\n    return new RegExp('\\\\{([^\\\\/]*?)\\\\}', 'g');\n  }\n\n  function _variableCharacters() {\n    return new RegExp('[\\\\{\\\\}\\\\*]', 'g');\n  }\n\n  function _datePattern() {\n    return new RegExp('^\\\\d{4}-[0-1]\\\\d-[0-3]\\\\d$', 'g');\n  }\n\n  function _patternToRegExp(pattern) {\n    if (pattern === '/') {\n      return new RegExp('^\\\\/(\\\\?.*)?(#.*)?$', 'g');\n    }\n    if (pattern.charAt(0) === '/') {\n      pattern = pattern.slice(1);\n    }\n    pattern = pattern.split('/');\n    var exp = '^',\n        i = -1,\n        part;\n    while (!!(part = pattern[++i])) {\n      if (_multivariablePattern().test(part)) {\n        exp += '(/([^/?#]+))*?';\n      } else if (_variablePattern().test(part)) {\n        exp += '/([^/?#]+)';\n      } else {\n        exp += '/' + part;\n      }\n    }\n    exp += '(\\\\?.*)?(#\\\\.*)?$';\n    return new RegExp(exp, 'g');\n  }\n\n  function _scrubURLValue(value) {\n    value = decodeURIComponent(value);\n    if (!isNaN(value)) {\n      value = Number(value);\n    } else if (value.toLowerCase() === 'true') {\n      value = true;\n    } else if (value.toLowerCase() === 'false') {\n      value = false;\n    } else if (_datePattern().test(value)) {\n      value = value.split('-');\n      value = new Date(Number(value[0]), Number(value[1]) - 1, Number(value[2]));\n    }\n    return value;\n  }\n\n  /**\n   * @class lavaca.mvc.Route\n   * @extends lavaca.util.Disposable\n   * A relationship between a URL pattern and a controller action\n   *\n   * @constructor\n   * @param {String} pattern  The route URL pattern\n   *   Route URL patterns should be in the form /path/{foo}/path/{*bar}.\n   *   The path variables, along with query string parameters, will be passed\n   *   to the controller action as a params object. In this case, when passed\n   *   the URL /path/something/path/1/2/3?abc=def, the params object would be\n   *   {foo: 'something', bar: [1, 2, 3], abc: 'def'}.\n   * @param {Function} TController  The type of controller that performs the action\n   *   (Should derive from [[Lavaca.mvc.Controller]])\n   * @param {String} action  The name of the controller method to call\n   * @param {Object} params  Key-value pairs that will be merged into the params\n   *   object that is passed to the controller action\n   */\n  var Route = Disposable.extend(function(pattern, TController, action, params) {\n    Disposable.call(this);\n    this.pattern = pattern;\n    this.TController = TController;\n    this.action = action;\n    this.params = params || {};\n  }, {\n    /**\n     * Tests if this route applies to a URL\n     * @method matches\n     *\n     * @param {String} url  The URL to test\n     * @return {Boolean}  True when this route matches the URL\n     */\n    matches: function(url) {\n      return _patternToRegExp(this.pattern).test(url);\n    },\n    /**\n     * Converts a URL into a params object according to this route's pattern\n     * @method parse\n     *\n     * @param {String} url  The URL to convert\n     * @return {Object}  The params object\n     */\n    parse: function(url) {\n      var result = clone(this.params),\n          pattern = this.pattern.slice(1),\n          urlParts = url.split('#'),\n          i,\n          query,\n          path,\n          pathItem,\n          patternItem,\n          name;\n      result.url = url;\n      result.route = this;\n      urlParts = urlParts[1] ? urlParts[1].split('?') : urlParts[0].split('?');\n      query = urlParts[1];\n      if (query) {\n        i = -1;\n        query = query.split('&');\n        while (!!(pathItem = query[++i])) {\n          pathItem = pathItem.split('=');\n          name = decodeURIComponent(pathItem[0]);\n          if (result[name] !== undefined) {\n            if (!(result[name] instanceof Array)) {\n              result[name] = [result[name]];\n            }\n            result[name].push(_scrubURLValue(pathItem[1]));\n          } else {\n            result[name] = _scrubURLValue(pathItem[1]);\n          }\n        }\n      }\n      i = 0;\n      path = urlParts[0].replace(/(^(http(s?)\\:\\/\\/[^\\/]+)?\\/?)|(\\/$)/, '');\n      var breakApartPattern = new RegExp(pattern.replace(_multivariablePattern(), '(.+)').replace(_variablePattern(), '([^/]+)')),\n          brokenPath = breakApartPattern.exec(path),\n          brokenPattern = breakApartPattern.exec(pattern);\n      while (!!(pathItem = brokenPath[++i])) {\n        patternItem = brokenPattern[i];\n        if (_multivariablePattern().test(patternItem)) {\n          pathItem = pathItem.split('/');\n        }\n        result[patternItem.replace(_variableCharacters(), '')] = pathItem;\n      }\n      return result;\n    },\n    /**\n     * Executes this route's controller action see if work\n     * @method exec\n     *\n     * @param {String} url  The URL that supplies parameters to this route\n     * @param {Lavaca.mvc.Router} router  The router used by the application\n     * @param {Lavaca.mvc.ViewManager}  viewManager The view manager used by the application\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Executes this route's controller action see if work\n     * @method exec\n     *\n     * @param {String} url  The URL that supplies parameters to this route\n     * @param {Lavaca.mvc.Router} router  The router used by the application\n     * @param {Lavaca.mvc.ViewManager}  viewManager The view manager used by the application\n     * @param {Object} state  A history record object\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Executes this route's controller action see if work\n     * @method exec\n     *\n     * @param {String} url  The URL that supplies parameters to this route\n     * @param {Lavaca.mvc.Router} router  The router used by the application\n     * @param {Lavaca.mvc.ViewManager}  viewManager The view manager used by the application\n     * @param {Object} state  A history record object\n     * @param {Object} params  Additional parameters to pass to the controller action\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    exec: function(url, router, viewManager, state, params) {\n      var controller = new this.TController(router, viewManager),\n          urlParams = this.parse(url),\n          promise = controller.exec(this.action, merge(urlParams, params), state);\n      function dispose() {\n        delay(controller.dispose, controller);\n      }\n      promise.then(dispose, dispose);\n      return promise;\n    }\n  });\n\n  return Route;\n\n",
    "js/libs/lavaca.js[277420:283056]": "\n\n  var Route = require('./Route'),\n      History = require('lavaca/net/History'),\n      Disposable = require('lavaca/util/Disposable'),\n      Promise = require('lavaca/util/Promise');\n\n  /**\n   * @class lavaca.mvc.Router\n   * @extends lavaca.util.Disposable\n   * URL manager\n   *\n   * @constructor\n   * @param {Lavaca.mvc.ViewManager} viewManager  The view manager\n   */\n  var Router = Disposable.extend(function(viewManager) {\n    Disposable.call(this);\n    /**\n     * @field {Array} routes\n     * @default []\n     * The [[Lavaca.mvc.Route]]s used by this router\n     */\n    this.routes = [];\n    /**\n     * @field {Lavaca.mvc.ViewManager} viewManager\n     * @default null\n     * The view manager used by this router\n     */\n    this.viewManager = viewManager;\n\n  }, {\n    /**\n     * @field {Boolean} locked\n     * @default false\n     * When true, the router is prevented from executing a route\n     */\n    locked: false,\n    /**\n     * @field {Boolean} hasNavigated\n     * @default false\n     * Whether or not this router has been used to navigate\n     */\n    hasNavigated: false,\n\n    startHistory: function() {\n      this.onpopstate = function(e) {\n        if (this.hasNavigated) {\n          History.isRoutingBack = e.direction === 'back';\n          this.exec(e.url, e).always(function() {\n            History.isRoutingBack = false;\n          });\n        }\n      };\n      History.on('popstate', this.onpopstate, this);\n    },\n    /**\n     * Sets the viewManager property on the instance which is the view manager used by this router\n     * @method setEl\n     *\n     * @param {Lavaca.mvc.ViewManager} viewManager\n     * @return {Lavaca.mvc.Router}  This Router instance\n     */\n    setViewManager: function(viewManager) {\n      this.viewManager = viewManager;\n      return this;\n    },\n    /**\n     * Adds multiple routes\n     * @method add\n     *\n     * @param {Object} map  A hash in the form {pattern: [TController, action, params]}\n     *   or {pattern: {controller: TController, action: action, params: params}\n     * @return {Lavaca.mvc.Router}  The router (for chaining)\n     */\n    /**\n     * Adds a route\n     * @method add\n     *\n     * @param {String} pattern  The route URL pattern\n     * @param {Function} TController  The type of controller to perform the action (should derive from [[Lavaca.mvc.Controller]])\n     * @param {String} action  The name of the controller method to call\n     * @return {Lavaca.mvc.Router}  The router (for chaining)\n     */\n    /**\n     * Adds a route\n     * @method add\n     *\n     * @param {String} pattern  The route URL pattern\n     * @param {Function} TController  The type of controller to perform the action (should derive from [[Lavaca.mvc.Controller]])\n     * @param {String} action  The name of the controller method to call\n     * @param {Object} params  Key-value pairs that will be passed to the action\n     * @return {Lavaca.mvc.Router}  The router (for chaining)\n     */\n    add: function(pattern, TController, action, params) {\n      if (typeof pattern === 'object') {\n        for (var p in pattern) {\n          var args = pattern[p];\n          if (args instanceof Array) {\n            TController = args[0];\n            action = args[1];\n            params = args[2];\n          } else {\n            TController = args.controller;\n            action = args.action;\n            params = args.params;\n          }\n          this.add(p, TController, action, params);\n        }\n      } else {\n        this.routes.push(new Route(pattern, TController, action, params));\n      }\n      return this;\n    },\n    /**\n     * Executes the action for a given URL\n     * @method exec\n     *\n     * @param {String} url  The URL\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Executes the action for a given URL\n     * @method exec\n     *\n     * @param {String} url  The URL\n     * @param {Object} state  A history record object\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Executes the action for a given URL\n     * @method exec\n     *\n     * @param {String} url  The URL\n     * @param {Object} state  A history record object\n     * @param {Object} params  Additional parameters to pass to the route\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    exec: function(url, state, params) {\n      if (this.locked) {\n        return (new Promise(this)).reject('locked');\n      } else {\n        this.locked = true;\n      }\n      if (!url) {\n        url = '/';\n      }\n      if (url.indexOf('http') === 0) {\n        url = url.replace(/^http(s?):\\/\\/.+?/, '');\n      }\n      var i = -1,\n          route,\n          promise = new Promise(this);\n      promise.always(function() {\n        this.unlock();\n      });\n      if (!this.hasNavigated) {\n        promise.success(function() {\n          this.hasNavigated = true;\n        });\n      }\n      while (!!(route = this.routes[++i])) {\n        if (route.matches(url)) {\n          return promise.when(route.exec(url, this, this.viewManager, state, params));\n        }\n      }\n      return promise.reject(url, state);\n    },\n    /**\n     * Unlocks the router so that it can be used again\n     * @method unlock\n     *\n     * @return {Lavaca.mvc.Router}  This router (for chaining)\n     */\n    unlock: function() {\n      this.locked = false;\n      return this;\n    },\n    /**\n     * Readies the router for garbage collection\n     * @method dispose\n     */\n    dispose: function() {\n      if (this.onpopstate) {\n        History.off('popstate', this.onpopstate);\n        this.onpopstate = null;\n      }\n      Disposable.prototype.dispose.apply(this, arguments);\n    }\n  });\n\n  return new Router();\n\n",
    "js/libs/lavaca.js[283270:306735]": "\n\n  var $ = require('$'),\n    EventDispatcher = require('lavaca/events/EventDispatcher'),\n    Model = require('lavaca/mvc/Model'),\n    Template = require('lavaca/ui/Template'),\n    Cache = require('lavaca/util/Cache'),\n    Promise = require('lavaca/util/Promise'),\n    log = require('lavaca/util/log'),\n    uuid = require('lavaca/util/uuid');\n\n\n\n\n  /**\n   * Base View Class\n   * @class lavaca.mvc.View\n   * @extends lavaca.events.EventDispatcher\n   * @constructor\n   * @param {Object | String} el the selector or Object for the element to attach to the view\n   * @param {Object} [model] the model for the view\n   * @param {Object} [parentView] the parent view for the view\n   *\n   *\n   */\n  var View = EventDispatcher.extend(function(el, model, parentView) {\n    EventDispatcher.call(this);\n\n    /**\n     * The model used by the view\n     * @property model\n     * @default null\n     * @optional\n     * @type lavaca.mvc.Model\n     *\n     */\n    this.model = model || null;\n\n    /**\n     * An id is applied to a data property on the views container\n     * @property id\n     * @default generated from className and unique identifier\n     * @type String\n     *\n     */\n    this.id = this.className + '-' + uuid();\n\n    /**\n     * If the view is created in the context of a childView, the parent view is assigned to this view\n     * @property parentView\n     * @default null\n     * @type Object\n     *\n     */\n    this.parentView = parentView || null;\n\n    /**\n     * The element that is either assigned to the view if in the context of a childView, or is created for the View\n     * if it is a PageView\n     * @property el\n     * @default null\n     * @type Object | String\n     *\n     */\n    this.el = typeof el === 'string' ? $(el) : (el || null);\n\n    /**\n     * A dictionary of selectors and event types in the form\n     * {eventType: {delegate: 'xyz', callback: func}}@property el\n     * @property eventMap\n     * @default {}\n     * @type Object\n     */\n    this.eventMap = {};\n    /**\n     * A dictionary of selectors, View types and models in the form\n     *   {selector: {TView: TView, model: model}}}\n     * @property {Object} childViewMap\n     * @default {}\n     * @type Object\n     *\n     */\n    this.childViewMap = {};\n    /**\n     * Interactive elements used by the view\n     * @property childViews\n     * @default lavaca.util.cache\n     * @type lavaca.util.Cache\n     */\n    this.childViews = new Cache();\n    /**\n     * A dictionary of selectors and widget types in the form\n     *   {selector: widgetType}\n     * @property {Object} widgetMap\n     * @default {}\n     * @type Object\n     */\n    this.widgetMap = {};\n    /**\n     * Interactive elements used by the view\n     * @property widgets\n     * @default lavaca.util.Cache\n     * @type lavaca.util.Cache\n     */\n    this.widgets = new Cache();\n    /**\n     *  A map of all the events to be applied to child Views in the form of\n     *  {type: {TView: TView, callback : callback}}\n     * @property childViewEventMap\n     * @default Object\n     * @type Object\n     */\n    this.childViewEventMap = {};\n\n    this\n      .on('rendersuccess', this.onRenderSuccess)\n      .on('rendererror', this.onRenderError);\n\n    if (this.autoRender) {\n      this.render();\n    }\n  }, {\n    /**\n     * The element associated with the view\n     * @property {jQuery} el\n     * @default null\n     *\n     */\n    el: null,\n    /**\n     * The name of the template associated with the view\n     * @property {String} template\n     * @default null\n     *\n     */\n    template: null,\n    /**\n     * A class name added to the view container\n     * @property String className\n     * @default null\n     *\n     */\n    className: null,\n    /**\n     * Will render any childViews automatically when set to true\n     * @property autoRender\n     * @default false\n     *\n     * @type Boolean\n     */\n    autoRender: false,\n    /**\n     * Renders the view using its template and model\n     * @method render\n     *\n     *\n     *\n     * @return {lavaca.util.Promise} A promise\n     */\n    render: function() {\n      var self = this,\n        promise = new Promise(this),\n        renderPromise = new Promise(this),\n        template = Template.get(this.template),\n        model = this.model;\n      if (model instanceof Model) {\n        model = model.toObject();\n      }\n      /**\n       * Fires when html from template has rendered\n       * @event rendersuccess\n       */\n      promise\n        .success(function(html) {\n          this.trigger('rendersuccess', {html: html});\n          renderPromise.resolve();\n        })\n      /**\n       * Fired when there was an error during rendering process\n       * @event rendererror\n       */\n        .error(function(err) {\n          this.trigger('rendererror', {err: err});\n          renderPromise.reject();\n        });\n      template\n        .render(model)\n        .success(promise.resolver())\n        .error(promise.rejector())\n        .then(function() {\n          if (self.className){\n            self.el.addClass(self.className);\n          }\n        });\n\n      return renderPromise;\n    },\n\n    /**\n     * Re-renders the view's template and replaces the DOM nodes that match\n     * the selector argument. If no selector argument is provided, the whole view\n     * will be re-rendered. If the first parameter is passed as <code>false</code>\n     * the resulting html will pe passed with the promise and nothing will be replaced.\n     * Note: the number of elements that match the provided selector must be identical\n     * in the current markup and in the newly rendered markup or else the returned\n     * promise will be rejected.\n     * Re-renders the view's template using the view's model\n     * and redraws the entire view\n     * @method redraw\n     *\n     * @return {lavaca.util.Promise} A promise\n     */\n    /**\n     * Re-renders the view's template using the specified model\n     * and redraws the entire view\n     * @method redraw\n     * @param {Object} model  The data model to be passed to the template\n     * @return {lavaca.util.Promise} A promise\n     */\n    /**\n     * Re-renders the view's template using the view's model and only redraws the\n     * elements that match the specified selector string.\n     * Note: The numbers of items that match the selector must\n     * be exactly the same in the view's current markup and in the newly rendered\n     * markup. If that is not the case, the returned promise will be rejected and\n     * nothing will be redrawn.\n     * @method redraw\n     * @param {String} selector  Selector string that defines elements to redraw\n     * @return {lavaca.util.Promise} A promise\n     */\n    /**\n     * Re-renders the view's template using the specified model and only redraws the\n     * elements that match the specified selector string.\n     * Note: The numbers of items that match the selector must\n     * be exactly the same in the view's current markup and in the newly rendered\n     * markup. If that is not the case, the returned promise will be rejected and\n     * nothing will be redrawn.\n     * @method redraw\n     * @param {String} selector  Selector string that defines elements that will be updated\n     * @param {Object} model  The data model to be passed to the template\n     * @return {lavaca.util.Promise} A promise\n     */\n    /**\n     * Re-renders the view's template using the view's model. If shouldRedraw is true,\n     * the entire view will be redrawn. If shouldRedraw is false, nothing will be redrawn,\n     * but the returned promise will be resolved with the newly rendered content. This allows\n     * the caller to attach a success handler to the returned promise and define their own\n     * redrawing behavior.\n     * @method redraw\n     * @param {Boolean} shouldRedraw  Whether the view should be automatically redrawn.\n     * @return {lavaca.util.Promise}  A promise\n     */\n    /**\n     * Re-renders the view's template using the specified model. If shouldRedraw is true,\n     * the entire view will be redrawn. If shouldRedraw is false, nothing will be redrawn,\n     * but the returned promise will be resolved with the newly rendered content. This allows\n     * the caller to attach a success handler to the returned promise and define their own\n     * redrawing behavior.\n     * @method redraw\n     * @param {Boolean} shouldRedraw  Whether the view should be automatically redrawn.\n     * @param {Object} model  The data model to be passed to the template\n     * @return {lavaca.util.Promise}  A promise\n     */\n    redraw: function(selector, model) {\n      var self = this,\n        templateRenderPromise = new Promise(this),\n        redrawPromise = new Promise(this),\n        template = Template.get(this.template),\n        replaceAll;\n      if (typeof selector === 'object' || selector instanceof Model) {\n        model = selector;\n        replaceAll = true;\n        selector = null;\n      }\n      else if (typeof selector === 'boolean') {\n        replaceAll = selector;\n        selector = null;\n      } else if (!selector) {\n        replaceAll = true;\n      }\n      model = model || this.model;\n      if (model instanceof Model) {\n        model = model.toObject();\n      }\n\n      // process widget, child view, and\n      // child view event maps\n      function processMaps() {\n        self.createWidgets();\n        self.createChildViews();\n        self.applyChildViewEvents();\n      }\n      templateRenderPromise\n        .success(function(html) {\n          if (replaceAll) {\n            this.disposeChildViews(this.el);\n            this.disposeWidgets(this.el);\n            this.el.html(html);\n            processMaps();\n            redrawPromise.resolve(html);\n            return;\n          }\n          if(selector) {\n            var $newEl = $('<div>' + html + '</div>').find(selector),\n              $oldEl = this.el.find(selector);\n            if($newEl.length === $oldEl.length) {\n              $oldEl.each(function(index) {\n                var $el = $(this);\n                self.disposeChildViews($el);\n                self.disposeWidgets($el);\n                $el.replaceWith($newEl.eq(index)).remove();\n              });\n              processMaps();\n              redrawPromise.resolve(html);\n            } else {\n              redrawPromise.reject('Count of items matching selector is not the same in the original html and in the newly rendered html.');\n            }\n          } else {\n            redrawPromise.resolve(html);\n          }\n        })\n        .error(redrawPromise.rejector());\n      template\n        .render(model)\n        .success(templateRenderPromise.resolver())\n        .error(templateRenderPromise.rejector());\n      return redrawPromise;\n    },\n\n    /**\n     * Dispose old widgets and child views\n     * @method disposeChildViews\n     * @param  {Object} $el the $el to search for child views and widgets in\n     */\n    disposeChildViews: function ($el) {\n      var childViewSearch,\n        self = this;\n\n      // Remove child views\n      childViewSearch = $el.find('[data-view-id]');\n      if ($el !== self.el && $el.is('[data-view-id]')) {\n        childViewSearch = childViewSearch.add($el);\n      }\n      childViewSearch.each(function(index, item) {\n        var $item = $(item),\n          childView = $item.data('view');\n\n        self.childViews.remove(childView.id);\n        childView.dispose();\n      });\n    },\n    /**\n     * Dispose old widgets and child views\n     * @method disposeWidgets\n     * @param  {Object} $el the $el to search for child views and widgets in\n     */\n    disposeWidgets: function ($el) {\n      var self = this;\n\n      // Remove widgets\n      $el.add($el.find('[data-has-widgets]')).each(function(index, item) {\n        var $item = $(item),\n          widgets = $item.data('widgets'),\n          selector, widget;\n        for (selector in widgets) {\n          widget = widgets[selector];\n          self.widgets.remove(widget.id);\n          widget.dispose();\n        }\n      });\n      $el.removeData('widgets');\n    },\n    /**\n     * Unbinds events from the model\n     * @method clearModelEvents\n     *\n     */\n    clearModelEvents: function() {\n      var type,\n        callback,\n        dotIndex;\n      if (this.eventMap\n        && this.eventMap.model\n        && this.model\n        && this.model instanceof EventDispatcher) {\n        for (type in this.eventMap.model) {\n          callback = this.eventMap.model[type];\n          if (typeof callback === 'object') {\n            callback = callback.on;\n          }\n          dotIndex = type.indexOf('.');\n          if (dotIndex !== -1) {\n            type = type.substr(0, dotIndex);\n          }\n          this.model.off(type, callback);\n        }\n      }\n    },\n    /**\n     * Checks for strings in the event map to bind events to this automatically\n     * @method bindMappedEvents\n     */\n    bindMappedEvents: function() {\n      var callbacks,\n        delegate,\n        type;\n      for (delegate in this.eventMap) {\n        callbacks = this.eventMap[delegate];\n        for (type in callbacks) {\n          if (typeof this.eventMap[delegate][type] === 'string'){\n            this.eventMap[delegate][type] = this[this.eventMap[delegate][type]].bind(this);\n          }\n        }\n      }\n    },\n    /**\n     * Binds events to the view\n     * @method applyEvents\n     *\n     */\n    applyEvents: function() {\n      var el = this.el,\n        callbacks,\n        callback,\n        property,\n        delegate,\n        type,\n        dotIndex,\n        opts;\n      for (delegate in this.eventMap) {\n        callbacks = this.eventMap[delegate];\n        if (delegate === 'self') {\n          delegate = null;\n        }\n        for (type in callbacks) {\n          callback = callbacks[type];\n          if (typeof callback === 'object') {\n            opts = callback;\n            callback = callback.on;\n          } else {\n            opts = undefined;\n          }\n          if (typeof callback === 'string') {\n            if (callback in this) {\n              callback = this[callback].bind(this);\n            }\n          }\n          if (delegate === 'model') {\n            if (this.model && this.model instanceof Model) {\n              dotIndex = type.indexOf('.');\n              if (dotIndex !== -1) {\n                property = type.substr(dotIndex+1);\n                type = type.substr(0, dotIndex);\n              }\n              this.model.on(type, property, callback, this);\n            }\n          } else if (type === 'animationEnd' && el.animationEnd) {\n            el.animationEnd(delegate, callback);\n          } else if (type === 'transitionEnd' && el.transitionEnd) {\n            el.transitionEnd(delegate, callback);\n          } else {\n            el.on(type, delegate, callback);\n          }\n        }\n      }\n    },\n    /**\n     * Maps multiple delegated events for the view\n     * @method mapEvent\n     *\n     * @param {Object} map  A hash of the delegates, event types, and handlers\n     *     that will be bound when the view is rendered. The map should be in\n     *     the form <code>{delegate: {eventType: callback}}</code>. For example,\n     *     <code>{'.button': {click: onClickButton}}</code>. The events defined in\n     *     [[Lavaca.fx.Animation]] and [[Lavaca.fx.Transition]] are also supported.\n     *     To map an event to the view's el, use 'self' as the delegate. To map\n     *     events to the view's model, use 'model' as the delegate. To limit events\n     *     to only a particular property on the model, use a period-seperated\n     *     syntax such as <code>{model: {'change.myproperty': myCallback}}</code>\n     * @return {lavaca.mvc.View}  This view (for chaining)\n     */\n    /**\n     * Maps an event for the view\n     * @method mapEvent\n     * @param {String} delegate  The element to which to delegate the event\n     * @param {String} type  The type of event\n     * @param {Function} callback  The event handler\n     * @return {lavaca.mvc.View}  This view (for chaining)\n     */\n    mapEvent: function(delegate, type, callback) {\n      var o;\n      if (typeof delegate === 'object') {\n        o = delegate;\n        for (delegate in o) {\n          for (type in o[delegate]) {\n            this.mapEvent(delegate, type, o[delegate][type]);\n          }\n        }\n      } else {\n        o = this.eventMap[delegate];\n        if (!o) {\n          o = this.eventMap[delegate] = {};\n        }\n        o[type] = callback;\n      }\n      return this;\n    },\n    /**\n     * Initializes widgets on the view\n     * @method createWidgets\n     *\n     */\n    createWidgets: function() {\n      var cache = this.widgets,\n        n,\n        o;\n      for (n in this.widgetMap) {\n        o = this.widgetMap[n];\n        (n === 'self' ? this.el : this.el.find(n))\n          .each(function(index, item) {\n            var $el = $(item),\n              widgetMap = $el.data('widgets') || {},\n              widget;\n            if (!widgetMap[n]) {\n              widget = new o($(item));\n              widgetMap[n] = widget;\n              cache.set(widget.id, widget);\n              $el.data('widgets', widgetMap);\n              $el.attr('data-has-widgets','');\n            }\n          });\n      }\n    },\n    /**\n     * Assigns multiple widget types to elements on the view\n     * @method mapWidget\n     * @param {Object} map  A hash of selectors to widget types to be bound when the view is rendered.\n     *     The map should be in the form {selector: TWidget}. For example, {'form': Lavaca.ui.Form}\n     * @return {Lavaca.mvc.View}  This view (for chaining)\n     *\n     */\n    /**\n     * Assigns a widget type to be created for elements matching a selector when the view is rendered\n     * @method mapWidget\n     * @param {String} selector  The selector for the root element of the widget\n     * @param {Function} TWidget  The [[Lavaca.ui.Widget]]-derived type of widget to create\n     * @return {Lavaca.mvc.View}  This view (for chaining)\n     */\n    mapWidget: function(selector, TWidget) {\n      if (typeof selector === 'object') {\n        var widgetTypes = selector;\n        for (selector in widgetTypes) {\n          this.mapWidget(selector, widgetTypes[selector]);\n        }\n      } else {\n        this.widgetMap[selector] = TWidget;\n      }\n      return this;\n    },\n    /**\n     * Initializes child views on the view, called from onRenderSuccess\n     * @method createChildViews\n     *\n     */\n    createChildViews: function() {\n      var cache = this.childViews,\n        n,\n        self = this,\n        o;\n      for (n in this.childViewMap) {\n        o = this.childViewMap[n];\n        this.el.find(n)\n          .each(function(index, item) {\n            var $el = $(item),\n              childView;\n            if (!$el.data('view')) {\n              childView = new o.TView($el, o.model || self.model, self);\n              cache.set(childView.id, childView);\n            }\n          });\n      }\n    },\n    /**\n     * Assigns multiple Views to elements on the view\n     * @method mapChildView\n     * @param {Object} map  A hash of selectors to view types and models to be bound when the view is rendered.\n     *     The map should be in the form {selector: {TView : TView, model : lavaca.mvc.Model}}. For example, {'form': {TView : lavaca.mvc.ExampleView, model : lavaca.mvc.Model}}\n     * @return {lavaca.mvc.View}  This view (for chaining)\n     *\n     * Assigns a View type to be created for elements matching a selector when the view is rendered\n     * @method mapChildView\n     * @param {String} selector  The selector for the root element of the View\n     * @param {Function} TView  The [[Lavaca.mvc.View]]-derived type of view to create\n     * @param {Function} model  The [[Lavaca.mvc.Model]]-derived model instance to use in the child view\n     * @return {Lavaca.mvc.View}  This view (for chaining)\n     */\n    mapChildView: function(selector, TView, model) {\n      if (typeof selector === 'object') {\n        var childViewTypes = selector;\n        for (selector in childViewTypes) {\n          this.mapChildView(selector, childViewTypes[selector].TView, childViewTypes[selector].model);\n        }\n      } else {\n        this.childViewMap[selector] = { TView: TView, model: model };\n      }\n      return this;\n    },\n\n    /**\n     * Listen for events triggered from child views.\n     * @method mapChildViewEvent\n     *\n     * @param {String} type The type of event to listen for\n     * @param {Function} callback The method to execute when this event type has occured\n     * @param {Lavaca.mvc.View} TView (Optional) Only listen on child views of this type\n     */\n    /**\n     * Maps multiple child event types\n     * @method mapChildViewEvent\n     *\n     * @param {Object} map A hash of event types with callbacks and TView's associated with that type\n     *  The map should be in the form {type : {callback : {Function}, TView : TView}}\n     */\n    mapChildViewEvent: function(type, callback, TView) {\n      if (typeof type === 'object'){\n        var eventTypes = type;\n        for (type in eventTypes){\n          //add in view type to limit events created\n          this.mapChildViewEvent(type, eventTypes[type].callback, eventTypes[type].TView);\n        }\n      } else {\n        this.childViewEventMap[type] = {\n          TView: TView,\n          callback: callback\n        };\n      }\n    },\n\n    /**\n     * Called from onRenderSuccess of the view, adds listeners to all childviews if present\n     * @method applyChildViewEvent\n     *\n     */\n    applyChildViewEvents: function() {\n      var childViewEventMap = this.childViewEventMap,\n        type;\n      for (type in childViewEventMap) {\n        this.childViews.each(function(key, item) {\n          var callbacks,\n            callback,\n            i = -1;\n\n          if (!childViewEventMap[type].TView || item instanceof childViewEventMap[type].TView) {\n            callbacks = item.callbacks[type] || [];\n            while (!!(callback = callbacks[++i])) {\n              if (callback === childViewEventMap[type].callback) {\n                return;\n              }\n            }\n            item.on(type, childViewEventMap[type].callback);\n          }\n        });\n      }\n    },\n    /**\n     * Executes when the template renders successfully\n     * @method onRenderSuccess\n     *\n     * @param {Event} e  The render event. This object should have a string property named \"html\"\n     *   that contains the template's rendered HTML output.\n     */\n    onRenderSuccess: function(e) {\n      this.el.html(e.html);\n      this.bindMappedEvents();\n      this.applyEvents();\n      this.createWidgets();\n      this.createChildViews();\n      this.applyChildViewEvents();\n      this.el.data('view', this);\n      this.el.attr('data-view-id', this.id);\n      this.hasRendered = true;\n    },\n    /**\n     * Executes when the template fails to render\n     * @method onRenderError\n     *\n     * @param {Event} e  The error event. This object should have a string property named \"err\"\n     *   that contains the error message.\n     */\n    onRenderError: function(e) {\n      log(e.err);\n    },\n    /**\n     * Readies the view for garbage collection\n     * @method dispose\n     */\n    dispose: function() {\n      if (this.model) {\n        this.clearModelEvents();\n      }\n      if (this.childViews.count()) {\n        this.disposeChildViews(this.el);\n      }\n      if (this.widgets.count()) {\n        this.disposeWidgets(this.el);\n      }\n\n      // Do not dispose of template or model\n      this.template\n        = this.model\n        = this.parentView\n        = null;\n\n      EventDispatcher.prototype.dispose.apply(this, arguments);\n    }\n  });\n\n  return View;\n\n",
    "js/libs/lavaca.js[306980:315234]": "\n\n  var $ = require('$'),\n      PageView = require('lavaca/mvc/PageView'),\n      ArrayUtils = require('lavaca/util/ArrayUtils'),\n      Cache = require('lavaca/util/Cache'),\n      Disposable = require('lavaca/util/Disposable'),\n      Promise = require('lavaca/util/Promise'),\n      delay = require('lavaca/util/delay'),\n      merge = require('mout/object/merge'),\n      History = require('lavaca/net/History');\n\n  /**\n   * Manager responsible for drawing views\n   * @class lavaca.mvc.ViewManager\n   * @extends lavaca.util.Disposable\n   *\n   * @constructor\n   * @param {jQuery} el  The element that contains all layers\n   */\n  var ViewManager = Disposable.extend(function(el) {\n    Disposable.call(this);\n    /**\n    * The element that contains all view layers\n     * @property {jQuery} el\n     * @default null\n     */\n    this.el = $(el || document.body);\n    /**\n     * A cache containing all views\n     * @property {Lavaca.util.Cache} views\n     * @default new Lavaca.util.Cache()\n     */\n    this.pageViews = new Cache();\n    /**\n     * A list containing all layers\n     * @property {Array} layers\n     * @default []\n     */\n    this.layers = [];\n    /**\n     * A list containing all views that are currently exiting\n     * @property {Array} exitingPageViews\n     * @default []\n     */\n    this.exitingPageViews = [];\n    /**\n     * A list containing all views that are currently entering\n     * @property {Array} enteringPageViews\n     * @default []\n     */\n    this.enteringPageViews = [];\n  }, {\n    /**\n     * When true, the view manager is prevented from loading views.\n     * @property {Boolean} locked\n     * @default false\n     */\n    locked: false,\n    /**\n     * Sets the el property on the instance\n     * @method setEl\n     *\n     * @param {jQuery} el  A jQuery object of the element that contains all layers\n     * @return {Lavaca.mvc.ViewManager}  This View Manager instance\n     */\n    /**\n     * Sets the el property on the instance\n     * @method setEl\n     *\n     * @param {String} el  A CSS selector matching the element that contains all layers\n     * @return {Lavaca.mvc.ViewManager}  This View Manager instance\n     */\n    setEl: function(el) {\n      this.el = typeof el === 'string' ? $(el) : el;\n      return this;\n    },\n    /**\n     * Loads a view\n     * @method load\n     *\n     * @param {String} cacheKey  The cache key associated with the view\n     * @param {Function} TPageView  The type of view to load (should derive from [[Lavaca.mvc.View]])\n     * @param {Object} model  The views model\n     * @param {Number} layer  The index of the layer on which the view will sit\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Loads a view\n     * @method load\n     *\n     * @param {String} cacheKey  The cache key associated with the view\n     * @param {Function} TPageView  The type of view to load (should derive from [[Lavaca.mvc.View]])\n     * @param {Object} model  The views model\n     * @param {Object} params  Parameters to be mapped to the view\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    load: function(cacheKey, TPageView, model, params) {\n      if (this.locked) {\n        return (new Promise(this)).reject('locked');\n      } else {\n        this.locked = true;\n      }\n      params = params || {};\n      var self = this,\n          layer = layer || 0,\n          pageView = this.pageViews.get(cacheKey),\n          promise = new Promise(this),\n          enterPromise = new Promise(promise),\n          renderPromise = null,\n          exitPromise = null;\n      promise.always(function() {\n        this.locked = false;\n      });\n      if (typeof params === 'number') {\n        layer = params;\n      } else if (params.layer) {\n        layer = params.layer;\n      }\n      if (!pageView) {\n        if (History.isRoutingBack && self.layers[layer] instanceof TPageView) {\n          pageView = self.layers[layer];\n        } else {\n          pageView = new TPageView(null, model, layer);\n          if (typeof params === 'object') {\n            merge(pageView, params);\n          }\n          renderPromise = pageView.render();\n          if (cacheKey !== null) {\n            this.pageViews.set(cacheKey, pageView);\n            pageView.cacheKey = cacheKey;\n          }\n        }\n      }\n      function lastly() {\n        self.enteringPageViews = [pageView];\n        promise.success(function() {\n          delay(function() {\n            self.enteringPageViews = [];\n          });\n        });\n        exitPromise = self.dismissLayersAbove(layer - 1, pageView);\n        if (self.layers[layer] !== pageView) {\n          enterPromise\n            .when(pageView.enter(self.el, self.exitingPageViews), exitPromise)\n            .then(promise.resolve);\n          self.layers[layer] = pageView;\n        } else {\n          promise.when(exitPromise);\n        }\n      }\n      if (renderPromise) {\n        renderPromise.then(lastly, promise.rejector());\n      } else {\n        lastly();\n      }\n      return promise;\n    },\n    /**\n     * Removes all views on a layer\n     * @method dismiss\n     *\n     * @param {Number} index  The index of the layer to remove\n     */\n    /**\n     * Removes all views on a layer\n     * @method dismiss\n     *\n     * @param {jQuery} el  An element on the layer to remove (or the layer itself)\n     */\n    /**\n     * Removes all views on a layer\n     * @method dismiss\n     *\n     * @param {Lavaca.mvc.View} view  The view on the layer to remove\n     */\n    dismiss: function(layer) {\n      if (typeof layer === 'number') {\n        this.dismissLayersAbove(layer - 1);\n      } else if (layer instanceof PageView) {\n        this.dismiss(layer.layer);\n      } else {\n        layer = $(layer);\n        var index = layer.attr('data-layer-index');\n        if (index === null) {\n          layer = layer.closest('[data-layer-index]');\n          index = layer.attr('data-layer-index');\n        }\n        if (index !== null) {\n          this.dismiss(Number(index));\n        }\n      }\n    },\n    /**\n     * Removes all layers above a given index\n     * @method dismissLayersAbove\n     *\n     * @param {Number}  index The index above which to clear\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Removes all layers above a given index\n     * @method dismissLayersAbove\n     *\n     * @param {Number} index  The index above which to clear\n     * @param {Lavaca.mvc.View}  exceptForView A view that should not be dismissed\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    dismissLayersAbove: function(index, exceptForView) {\n      var promise = new Promise(this),\n          dismissedLayers = false,\n          i,\n          layer;\n      for (i = this.layers.length - 1; i > index; i--) {\n        if ((layer = this.layers[i]) && (!exceptForView || exceptForView !== layer)) {\n          (function(layer) {\n            this.exitingPageViews.push(layer);\n            promise\n              .when(layer.exit(this.el, this.enteringPageViews))\n              .success(function() {\n                delay(function() {\n                  ArrayUtils.remove(this.exitingPageViews, layer);\n                  if (!layer.cacheKey || (exceptForView && exceptForView.cacheKey === layer.cacheKey)) {\n                    layer.dispose();\n                  }\n                }, this);\n              });\n            this.layers[i] = null;\n          }).call(this, layer);\n          dismissedLayers = true;\n        }\n      }\n      if (!dismissedLayers) {\n        promise.resolve();\n      }\n      return promise;\n    },\n    /**\n     * Empties the view cache\n     * @method flush\n     */\n    flush: function(cacheKey) {\n      // Don't dispose of any views that are currently displayed\n      //flush individual cacheKey\n      if (cacheKey){\n        this.pageViews.remove(cacheKey);\n      } else {\n        var i = -1,\n          layer;\n        while (!!(layer = this.layers[++i])) {\n          if (layer.cacheKey) {\n            this.pageViews.remove(layer.cacheKey);\n          }\n        }\n        this.pageViews.dispose();\n        this.pageViews = new Cache();\n      }\n    },\n    /**\n     * Readies the view manager for garbage collection\n     * @method dispose\n     */\n    dispose: function() {\n      Disposable.prototype.dispose.call(this);\n    }\n  });\n\n  return new ViewManager(null);\n\n",
    "js/libs/lavaca.js[315349:317884]": "\n\n  var $ = require('$'),\n      Promise = require('lavaca/util/Promise'),\n      resolve = require('lavaca/util/resolve');\n\n  /**\n   * A utility type for working under different network connectivity situatioConnectivity.\n   * @class lavaca.net.Connectivity\n   */\n\n  var _navigatorOnlineSupported = typeof navigator.onLine === 'boolean',\n      _offlineAjaxHandlers = [],\n      _offlineErrorCode = 'offline';\n\n  function _onAjaxError(arg) {\n    if (arg === _offlineErrorCode) {\n      var i = -1,\n          callback;\n      while (!!(callback = _offlineAjaxHandlers[++i])) {\n        callback(arg);\n      }\n    }\n  }\n\n  var Connectivity = {};\n\n  /**\n   * Attempts to detect whether or not the browser is connected\n   * @method isOffline\n   * @static\n   *\n   * @return {Boolean}  True if the browser is offline; false if the browser is online\n   *    or if connection status cannot be determined\n   */\n  Connectivity.isOffline = function() {\n    var connectionType = resolve('navigator.connection.type');\n    if (connectionType !== null) {\n      return connectionType === resolve('Connection.NONE');\n    } else {\n      return _navigatorOnlineSupported ? !navigator.onLine : false;\n    }\n  };\n\n  /**\n   * Makes an AJAX request if the user is online. If the user is offline, the returned\n   * promise will be rejected with the string argument \"offline\"\n   * @method ajax\n   * @static\n   *\n   * @param {Object} opts  jQuery-style AJAX options\n   * @return {Lavaca.util.Promise}  A promise\n   */\n  Connectivity.ajax = function(opts) {\n    var promise = new Promise(),\n        origSuccess = opts.success,\n        origError = opts.error;\n    opts.success = function() {\n      if (origSuccess) {\n        origSuccess.apply(this, arguments);\n      }\n      promise.resolve.apply(promise, arguments);\n    };\n    opts.error = function() {\n      if (origError) {\n        origError.apply(this, arguments);\n      }\n      promise.reject.apply(promise, arguments);\n    };\n    if (Connectivity.isOffline()) {\n      promise.reject(_offlineErrorCode);\n    } else {\n      $.ajax(opts);\n    }\n    promise.error(_onAjaxError);\n    return promise;\n  };\n\n  /**\n   * Adds a callback to be executed whenever any Lavaca.net.Connectivity.ajax() call is\n   * blocked as a result of a lack of internet connection.\n   * @method registerOfflineAjaxHandler\n   * @static\n   *\n   * @param {Function} callback  The callback to execute\n   */\n  Connectivity.registerOfflineAjaxHandler = function(callback) {\n    _offlineAjaxHandlers.push(callback);\n  };\n\n  return Connectivity;\n\n",
    "js/libs/lavaca.js[317997:326926]": "\n\n  var EventDispatcher = require('lavaca/events/EventDispatcher'),\n      uuid = require('lavaca/util/uuid');\n\n  var _isAndroid = navigator.userAgent.indexOf('Android') > -1,\n      _standardsMode = !_isAndroid && typeof history.pushState === 'function',\n      _hasPushed = false,\n      _lastHash,\n      _hist,\n      _currentId,\n      _pushCount = 0;\n\n  function _insertState(hist, position, id, state, title, url) {\n    hist.position = position;\n    var record = {\n          id: id,\n          state: state,\n          title: title,\n          url: url\n        };\n    hist.sequence[position] = record;\n    location.hash = _lastHash = url + '#@' + id;\n    return record;\n  }\n\n  /**\n   * HTML5 history abstraction layer\n   * @class lavaca.net.History\n   * @extends lavaca.events.EventDispatcher\n   *\n   * @event popstate\n   *\n   * @constructor\n   */\n  var History = EventDispatcher.extend(function() {\n    EventDispatcher.call(this);\n    /**\n     * A list containing history states generated by the app (not used for HTML5 history)\n     * @property {Array} sequence\n     */\n    this.sequence = [];\n    /**\n     * The current index in the history sequence (not used for HTML5 history)\n     * @property {Number} position\n     */\n    this.position = -1;\n    this.replace({}, document.title, location.pathname);\n    var self = this;\n    if (_standardsMode) {\n      /**\n       * Auto-generated callback executed when a history event occurs\n       * @property {Function} onPopState\n       */\n       var self = this;\n      this.onPopState = function(e) {\n        if (e.state) {\n          _pushCount--;\n          var previousId = _currentId;\n          _currentId = e.state.id;\n          self.trigger('popstate', {\n            state: e.state.state,\n            title: e.state.title,\n            url: e.state.url,\n            id: e.state.id,\n            direction: _currentId > previousId ? 'forward' : 'back'\n          });\n        }\n      };\n      window.addEventListener('popstate', this.onPopState, false);\n    } else {\n      this.onPopState = function() {\n        var hash = location.hash,\n            code,\n            record,\n            item,\n            previousCode,\n            i = -1;\n        if (hash) {\n          hash = hash.replace(/^#/, '');\n        }\n        if (hash !== _lastHash) {\n          previousCode = _lastHash.split('#@')[1];\n          _lastHash = hash;\n          if (hash) {\n            _pushCount--;\n            code = hash.split('#@')[1];\n            while (!!(item = self.sequence[++i])) {\n              if (item.id === parseInt(code, 10)) {\n                record = item;\n                self.position = i;\n                break;\n              }\n            }\n            if (record) {\n              location.hash = record.url + '#@' + record.id;\n              document.title = record.title;\n              self.trigger('popstate', {\n                state: record.state,\n                title: record.title,\n                url: record.url,\n                id: record.id,\n                direction: record.id > parseInt(previousCode, 10) ? 'forward' : 'back'\n              });\n            }\n          }\n        }\n      };\n      if (window.attachEvent) {\n        window.attachEvent('onhashchange', this.onPopState);\n      } else {\n        window.addEventListener('hashchange', this.onPopState, false);\n      }\n    }\n  }, {\n    /**\n     * Retrieve the current history record\n     * @method current\n     *\n     * @return {Object}  The current history record\n     */\n    current: function() {\n      return this.sequence[this.position] || null;\n    },\n    /**\n     * Determines whether or not there are history states\n     * @method hasHistory\n     *\n     * @returns {Boolean} True when there is a history state\n     */\n    hasHistory: function() {\n      return _pushCount > 0;\n    },\n    /**\n     * Adds a record to the history\n     * @method push\n     *\n     * @param {Object} state  A data object associated with the page state\n     * @param {String} title  The title of the page state\n     * @param {String} url  The URL of the page state\n     */\n    push: function(state, title, url) {\n      _pushCount++;\n      if (_hasPushed) {\n        document.title = title;\n        _currentId = uuid('history');\n        if (_standardsMode) {\n          history.pushState({state: state, title: title, url: url, id: _currentId}, title, url);\n        } else {\n          _insertState(this, ++this.position, _currentId, state, title, url);\n        }\n      } else {\n        this.replace(state, title, url);\n      }\n    },\n    /**\n     * Replaces the current record in the history\n     * @method replace\n     *\n     * @param {Object} state  A data object associated with the page state\n     * @param {String} title  The title of the page state\n     * @param {String} url  The URL of the page state\n     */\n    replace: function(state, title, url) {\n      _hasPushed = true;\n      document.title = title;\n      if (_standardsMode) {\n        history.replaceState({state: state, title: title, url: url, id: _currentId}, title, url);\n      } else {\n        if (this.position < 0) {\n          this.position = 0;\n        }\n        _insertState(this, this.position, typeof _currentId !== 'undefined' ? _currentId : uuid('history'), state, title, url);\n      }\n    },\n    /**\n     * Unbind the history object and ready it for garbage collection\n     * @method dispose\n     */\n    dispose: function() {\n      if (this.onPopState) {\n        if (_standardsMode) {\n          window.removeEventListener('popstate', this.onPopState, false);\n        } else if (window.detachEvent) {\n          window.detachEvent('onhashchange', this.onPopState);\n        } else {\n          window.removeEventListener('hashchange', this.onPopState, false);\n        }\n      }\n      EventDispatcher.prototype.dispose.call(this);\n    }\n  });\n  /**\n   * Initialize a singleton history abstraction layer\n   * @method init\n   * @static\n   *\n   * @return {Lavaca.mvc.History}  The history instance\n   */\n   /**\n   * Initialize a singleton history abstraction layer\n   * @method init\n   * @static\n   *\n   * @param {Boolean} useHash  When true, use the location hash to manage history state instead of HTML5 history\n   * @return {Lavaca.mvc.History}  The history instance\n   */\n  History.init = function(useHash) {\n    if (!_hist) {\n      if (useHash) {\n        History.overrideStandardsMode();\n      }\n      _hist = new History();\n    }\n    return _hist;\n  };\n  /**\n   * Adds a record to the history\n   * @method push\n   * @static\n   *\n   * @param {Object} state  A data object associated with the page state\n   * @param {String} title  The title of the page state\n   * @param {String} url  The URL of the page state\n   */\n  History.push = function() {\n    History.init().push.apply(_hist, arguments);\n  };\n  /**\n   * Replaces the current record in the history\n   * @method replace\n   * @static\n   *\n   * @param {Object} state  A data object associated with the page state\n   * @param {String} title  The title of the page state\n   * @param {String} url  The URL of the page state\n   */\n  History.replace = function() {\n    History.init().replace.apply(_hist, arguments);\n  };\n  /**\n   * Goes to the previous history state\n   * @method back\n   * @static\n   */\n  History.back = function() {\n    history.back();\n  };\n  /**\n   * Goes to the next history state\n   * @method forward\n   * @static\n   */\n  History.forward = function() {\n    history.forward();\n  };\n  /**\n   * Unbind the history object and ready it for garbage collection\n   * @method dispose\n   * @static\n   */\n  History.dispose = function() {\n    if (_hist) {\n      _hist.dispose();\n      _hist = null;\n    }\n  };\n  /**\n   * Binds an event handler to the singleton history\n   * @method on\n   * @static\n   *\n   * @param {String} type  The type of event\n   * @param {Function} callback  The function to execute when the event occurs\n   * @return {Lavaca.mvc.History}  The history object (for chaining)\n   */\n  History.on = function() {\n    return History.init().on.apply(_hist, arguments);\n  };\n  /**\n   * Unbinds an event handler from the singleton history\n   * @method off\n   * @static\n   *\n   * @param {String} type  The type of event\n   * @param {Function} callback  The function to stop executing when the\n   *    event occurs\n   * @return {Lavaca.mvc.History}  The history object (for chaining)\n   */\n  History.off = function() {\n    return History.init().off.apply(_hist, arguments);\n  };\n  /**\n   * Sets Histroy to hash mode\n   * @method overrideStandardsMode\n   * @static\n   */\n  History.overrideStandardsMode = function() {\n    _standardsMode = false;\n  };\n\n  /**\n   * Stores the page transition animations so that if you route back, it will animate correctly\n   * @property {Array} animationBreadcrumb\n   */\n  History.animationBreadcrumb = [];\n\n  /**\n   * Flag to notify when history back is being called\n   * @property {Boolean} isRoutingBack\n   */\n  History.isRoutingBack = false;\n\n  return History;\n\n",
    "js/libs/lavaca.js[327015:328307]": "\n\n  var Disposable = require('lavaca/util/Disposable');\n\n  function _notImplemented() {\n    throw 'Not implemented';\n  }\n\n  /**\n   * An object for manage local storage\n   * @class lavaca.storage.Store\n   * @extends lavaca.util.Disposable\n   */\n  var Store = Disposable.extend(function(id) {\n    /**\n     * The ID of the store\n     * @property {String} id\n     */\n    this.id = id;\n  }, {\n    /**\n     * Retrieves an object from storage, given its ID\n     * @method get\n     *\n     * @param {String} id  The ID of the stored object\n     * @return {Object}  The stored object\n     */\n    get: function() {\n      _notImplemented();\n    },\n    /**\n     * Stores an object locally\n     * @method set\n     *\n     * @param {String} id  The ID of the object to store\n     * @param {Object} value  The value to store\n     */\n    set: function() {\n      _notImplemented();\n    },\n    /**\n     * Removes an object from storage\n     * @method remove\n     *\n     * @param {String} id  The ID of the object to remove from storage\n     */\n    remove: function() {\n      _notImplemented();\n    },\n    /**\n     * Retrieves all items in this store\n     * @method all\n     *\n     * @return {Array}  A list of stored objects\n     */\n    all: function() {\n      _notImplemented();\n    }\n  });\n\n  return Store;\n\n",
    "js/libs/lavaca.js[328904:330770]": "\n  var escape = window.escape;\n  var unescape = window.unescape;\n  var docCookies = {\n    getItem: function (sKey) {\n      return unescape(document.cookie.replace(new RegExp(\"(?:(?:^|.*;\\\\s*)\" + escape(sKey).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*((?:[^;](?!;))*[^;]?).*)|.*\"), \"$1\")) || null;\n    },\n    setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {\n      if (!sKey || /^(?:expires|max\\-age|path|domain|secure)$/i.test(sKey)) { return false; }\n      var sExpires = \"\";\n      if (vEnd) {\n        switch (vEnd.constructor) {\n          case Number:\n            sExpires = vEnd === Infinity ? \"; expires=Fri, 31 Dec 9999 23:59:59 GMT\" : \"; max-age=\" + vEnd;\n            break;\n          case String:\n            sExpires = \"; expires=\" + vEnd;\n            break;\n          case Date:\n            sExpires = \"; expires=\" + vEnd.toGMTString();\n            break;\n        }\n      }\n      document.cookie = escape(sKey) + \"=\" + escape(sValue) + sExpires + (sDomain ? \"; domain=\" + sDomain : \"\") + (sPath ? \"; path=\" + sPath : \"\") + (bSecure ? \"; secure\" : \"\");\n      return true;\n    },\n    removeItem: function (sKey, sPath) {\n      if (!sKey || !this.hasItem(sKey)) { return false; }\n      document.cookie = escape(sKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (sPath ? \"; path=\" + sPath : \"\");\n      return true;\n    },\n    hasItem: function (sKey) {\n      return (new RegExp(\"(?:^|;\\\\s*)\" + escape(sKey).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(document.cookie);\n    },\n    keys: /* optional method: you can safely remove it! */ function () {\n      var aKeys = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n      for (var nIdx = 0; nIdx < aKeys.length; nIdx++) { aKeys[nIdx] = unescape(aKeys[nIdx]); }\n      return aKeys;\n    }\n  };\n  return docCookies;\n",
    "js/libs/lavaca.js[330886:333622]": "\n\n  var Store = require('./Store'),\n      docCookies = require('docCookies'),\n      ArrayUtils = require('lavaca/util/ArrayUtils');\n\n  var _isLocalStorageSupported = (function(localStorage) {\n    var testKey = 'qeTest';\n    if (!localStorage) {\n      return false;\n    }\n    try {\n      localStorage.setItem(testKey, '1');\n      localStorage.removeItem(testKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }(window.localStorage));\n\n  var _storage = _isLocalStorageSupported ? localStorage : docCookies;\n\n  function _saveManifest(store) {\n    _storage.setItem(store.id + '@manifest', JSON.stringify(store.manifest));\n  }\n\n  /**\n   * An object for manage local storage\n   * @class lavaca.storage.LocalStore\n   * @extends lavaca.storage.Store\n\n   */\n  var LocalStore = Store.extend(function(id) {\n    Store.call(this, id);\n     /**\n     * A list of keys found in the store\n     * @field {Array} manifest\n     */\n    this.manifest = JSON.parse(_storage.getItem(this.id + '@manifest') || '[]');\n  }, {\n    /**\n     * Generates a storage key\n     * @method key\n     *\n     * @param {String} id  The ID of the item for which to generate a key\n     * @return {String}  The key\n     */\n    key: function(id) {\n      return this.id + ':' + id;\n    },\n    /**\n     * Retrieves an object from storage, given its ID\n     * @method get\n     *\n     * @param {String} id  The ID of the stored object\n     * @return {Object}  The stored object\n     */\n    get: function(id) {\n      var str = _storage.getItem(this.key(id));\n      var obj;\n      if (!!str) {\n        try {\n          obj = JSON.parse(str);\n          return obj;\n        } catch(e) {\n          return str;\n        }\n      }\n      return null;\n    },\n    /**\n     * Stores an object locally\n     * @method set\n     *\n     * @param {String} id  The ID of the object to store\n     * @param {Object} value  The value to store\n     */\n    set: function(id, value) {\n      _storage.setItem(this.key(id), JSON.stringify(value));\n      ArrayUtils.pushIfNotExists(this.manifest, id);\n      _saveManifest(this);\n    },\n    /**\n     * Removes an object from storage\n     * @method remove\n     *\n     * @param {String} id  The ID of the object to remove from storage\n     */\n    remove: function(id) {\n      _storage.removeItem(this.key(id));\n      ArrayUtils.remove(this.manifest, id);\n      _saveManifest(this);\n    },\n    /**\n     * Retrieves all items in this store\n     * @method all\n     *\n     * @return {Array}  A list of stored objects\n     */\n    all: function() {\n      var result = [],\n          i = -1,\n          id;\n      while (!!(id = this.manifest[++i])) {\n        result.push(this.get(id));\n      }\n      return result;\n    }\n  });\n\n  return LocalStore;\n\n",
    "js/libs/lavaca.js[336455:337060]": "\n      var key = dust.helpers.tap(params.key, chunk, context),\n          locale = dust.helpers.tap(params.locale, chunk, context),\n          translation = Translation.get(key, locale),\n          args = [translation],\n          i = -1,\n          arg;\n      if(!translation) {\n        return bodies.block ? chunk.render(bodies.block, context) : chunk;\n      }\n      arg = params['p' + (++i)];\n      while (typeof arg !== 'undefined') {\n        args.push(dust.helpers.tap(arg, chunk, context));\n        arg = params['p' + (++i)];\n      }\n      return chunk.write(StringUtils.format.apply(this, args));\n    ",
    "js/libs/lavaca.js[337894:338303]": "\n      var name = dust.helpers.tap(params.name, chunk, context),\n          result;\n\n      // Note that this only works because\n      // dust renders are synchronous so\n      // the .then() is called before this\n      // helper function returns\n      Template\n        .render(name, context.stack.head)\n        .then(function(html) {\n          result = html;\n        });\n      return chunk.write(result);\n    ",
    "js/libs/lavaca.js[340081:341138]": "\n      var key = dust.helpers.tap(params.key, chunk, context),\n          environment = dust.helpers.tap(params.environment, chunk, context),\n          value = environment ? Config.get(environment, key) : Config.get(key),\n          args = [value],\n          i = -1,\n          currentEnvironment, arg;\n      if(params.only || params.not) {\n        currentEnvironment = Config.currentEnvironment();\n        if((params.only && currentEnvironment === params.only) || (params.not && currentEnvironment !== params.not)) {\n          return bodies.block ? chunk.render(bodies.block, context) : chunk;\n        } else {\n          return bodies['else'] ? chunk.render(bodies['else'], context) : chunk;\n        }\n      }\n      if(!value) {\n        return bodies.block ? chunk.render(bodies.block, context) : chunk;\n      }\n      arg = params['p' + (++i)];\n      while (typeof arg !== 'undefined') {\n        args.push(dust.helpers.tap(arg, chunk, context));\n        arg = params['p' + (++i)];\n      }\n      return chunk.write(StringUtils.format.apply(this, args));\n    ",
    "js/libs/lavaca.js[341232:341343]": "\n      Template.prototype.compile.call(this);\n      dust.loadSource(dust.compile(this.code, this.name));\n    ",
    "js/libs/lavaca.js[342113:342201]": "\n      delete dust.cache[this.name];\n      Template.prototype.dispose.call(this);\n    ",
    "js/libs/lavaca.js[342538:343345]": "\n\n  var $ = require('$'),\n      EventDispatcher = require('lavaca/events/EventDispatcher'),\n      uuid = require('lavaca/util/uuid');\n\n  /**\n   * Base type for all UI elements\n   * @class lavaca.ui.Widget\n   * @extends lavaca.events.EventDispatcher\n   *\n   * @constructor\n   *\n   * @param {jQuery} el  The DOM element that is the root of the widget\n   */\n  var Widget = EventDispatcher.extend(function(el) {\n    EventDispatcher.call(this);\n    /**\n     * The DOM element that is the root of the widget\n     * @property {jQuery} el\n     * @default null\n     */\n    this.el = el = $(el);\n    var id = el.attr('id');\n    if (!id) {\n      id = 'widget-' + uuid();\n    }\n    /**\n     * The el's ID\n     * @property {String} id\n     * @default (Autogenerated)\n     */\n    this.id = id;\n  });\n\n  return Widget;\n\n",
    "js/libs/lavaca.js[343448:353770]": "\n\n  var $ = require('$'),\n      Widget = require('lavaca/ui/Widget'),\n      Promise = require('lavaca/util/Promise');\n\n  function _required(value) {\n    return value ? null : 'error_required';\n  }\n\n  function _pattern(value, input) {\n    if (value) {\n      var pattern = new RegExp(input.attr('pattern'));\n      if (!pattern.test(value)) {\n        return 'error_pattern';\n      }\n    }\n    return null;\n  }\n\n  function _email(value) {\n    if (value && !/^\\w+@\\w+(\\.\\w+)*\\.\\w+$/.test(value)) {\n      return 'error_email';\n    }\n    return null;\n  }\n\n  function _tel(value) {\n    if (value && !/^\\d?(\\d{3})?\\d{7}$/.test(value.replace(/\\D/g, ''))) {\n      return 'error_email';\n    }\n    return null;\n  }\n\n  function _number(value) {\n    if (value && !/^\\d+(\\.\\d+)?$/.test(value)) {\n      return 'error_number';\n    }\n    return null;\n  }\n\n  function _url(value) {\n    if (value && !/^https?:\\/\\/\\w+(\\.\\w+)*\\.\\w(:\\d+)?\\/\\S+$/.test(value)) {\n      return 'error_url';\n    }\n    return null;\n  }\n\n  /**\n   * Basic form type\n   * @class lavaca.ui.Form\n   * @extends lavaca.ui.Widget\n   *\n   * @constructor\n   * @param {jQuery} el  The DOM element that is the root of the widget\n   */\n  var Form = Widget.extend(function() {\n    Widget.apply(this, arguments);\n    var self = this;\n    this.pendingSync = {};\n    this._onChangeInput = function(e) {\n      self.onChangeInput(e);\n    };\n    this._onSubmit = function(e) {\n      self.onSubmit(e);\n    };\n    this.el.on('submit', this._onSubmit);\n    this.addRule(this.defaultRules());\n  }, {\n    /**\n     * Event handler for when the form is submitted\n     * @method onSubmit\n     *\n     * @param {Event} e  The submit event\n     */\n    onSubmit: function(e) {\n      e.preventDefault();\n      this.validate()\n        .success(this.onSubmitSuccess)\n        .error(this.onSubmitError);\n    },\n    /**\n     * Event handler for when the user attempts to submit a valid form\n     * @method onSubmitSuccess\n     *\n     * @param {Object} values  Key-value map of the form's input names and values\n     */\n    onSubmitSuccess: function() {\n      // Placeholder\n    },\n    /**\n     * Event handler for when the user attempts to submit an invalid form\n     * @method onSubmitError\n     *\n     * @param {Object} invalidInputs  A key-value map of all invalid inputs\n     */\n    onSubmitError: function() {\n      // Placeholder\n    },\n    /**\n     * Event handler for when an input on the form changes\n     * @method onChangeInput\n     *\n     * @param {Event} e  The change event\n     */\n    onChangeInput: function(e) {\n      if (this.model) {\n        var input = $(e.target),\n            name = input.attr('name'),\n            value = input.val();\n        this.pendingSync[name] = true;\n        this.model.set(name, value);\n        this.pendingSync[name] = false;\n      }\n    },\n    /**\n     * Event handler for when an attribute on the bound model changes\n     * @method onChangeModel\n     *\n     * @param {Event} e  The change event\n     */\n    onChangeModel: function(e) {\n      if (!this.pendingSync[e.attribute]) {\n        this.set(e.attribute, e.value);\n      }\n    },\n    /**\n     * Binds this form to a model, forcing the two to stay in sync\n     * @method bind\n     *\n     * @param {Lavaca.mvc.Model} model  The model being bound\n     */\n    bind: function(model) {\n      this.unbind();\n      this.model = model;\n      model.on('change', this.onChangeModel, this);\n      this.el.on('change', this._onChangeInput);\n    },\n    /**\n     * Unbinds this form from its model\n     * @method unbind\n     */\n    unbind: function() {\n      if (this.model) {\n        this.el.off('change', this._onChangeInput);\n        this.model.off('change', this.onchangeModel, this);\n        this.model = null;\n      }\n    },\n    /**\n     * Retrieve an input from the form with a given name\n     * @method input\n     *\n     * @param {String} name  The name of the input\n     * @return {jQuery}  The input\n     */\n    input: function(name) {\n      return this.el.find('input, select, textarea').filter('[name=\"' + name + '\"]');\n    },\n    /**\n     * Gets the value of an input on the form\n     * @method get\n     *\n     * @param {String} name  The name of the input\n     * @return {String}  The value of the input\n     */\n    get: function(name) {\n      return this.input(name).val();\n    },\n    /**\n     * Sets an input on the form's value\n     * @method set\n     *\n     * @param {String} name  The name of the input\n     * @param {Object} value  The new value of the input\n     */\n    set: function(name, value) {\n      this.input(name).val(value || null);\n    },\n    /**\n     * The default validation rules for the form\n     * @method defaultRules\n     *\n     * @return {Object}  The form's default rules1\n     */\n    defaultRules: function() {\n      return {\n        '[required]': _required,\n        '[pattern]': _pattern,\n        '[type=email]': _email,\n        '[type=tel]': _tel,\n        '[type=number]': _number,\n        '[type=url]': _url\n      };\n    },\n    /**\n     * Adds multiple validation rules to this form\n     * @method addRule\n     *\n     * @param {Object} map  A hash of selectors and callbacks to add as rules\n     */\n    /**\n     * Adds multiple validation rules to this form\n     * @method addRule\n     * @param {String} selector  A jQuery selector associated with the rule\n     * @param {Function} callback  A function that tests the value of inputs matching the\n     *   selector in the form callback(value, input, form) and\n     *   return a string message if validation fails\n     */\n    addRule: function(selector, callback) {\n      if (!this.rules) {\n        this.rules = [];\n      }\n      if (typeof selector === 'object') {\n        for (var n in selector) {\n          this.addRule(n, selector[n]);\n        }\n      } else {\n        this.rules.push({selector: selector, callback: callback});\n      }\n    },\n    /**\n     * Collects all input values on the form\n     * @method values\n     *\n     * @return {Object}  A hash of input names and their values\n     */\n    values: function() {\n      var inputs = this.el.find('input, select, textarea'),\n          result = {},\n          i = -1,\n          input,\n          name,\n          current,\n          value,\n          type;\n      while (!!(input = inputs[++i])) {\n        input = $(input);\n        type = input.attr('type');\n        if ((type === 'radio' || type === 'checkbox') && !input[0].checked) {\n          continue;\n        }\n        name = input.attr('name');\n        current = result[name];\n        value = input.val();\n        if (current instanceof Array) {\n          current.push(value);\n        } else if (current !== undefined) {\n          result[name] = [current, value];\n        } else {\n          result[name] = value;\n        }\n      }\n      return result;\n    },\n    /**\n     * Checks the entire form to see if it's in a valid state\n     * @method validate\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Checks the entire form to see if it's in a valid state\n     * @method validate\n     * @param {Function} succcess  A callback to execute when the form is valid\n     * @param {Function} error  A callback to execute when the form is invalid\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Checks the entire form to see if it's in a valid state\n     * @method validate\n     * @param {jQuery} input  An input to check\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    /**\n     * Checks the entire form to see if it's in a valid state\n     * @method validate\n     * @param {Function} succcess  A callback to execute when the input is valid\n     * @param {Function} error  A callback to execute when the input is invalid\n     * @param {jQuery} input  An input to check\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    validate: function(success, error, input) {\n      if (success && typeof success !== 'function') {\n        input = success;\n        success = null;\n      }\n      if (input) {\n        input = $(input);\n      }\n      var result = null,\n          promise = new Promise(this),\n          i = -1,\n          j,\n          rule,\n          inputs,\n          ip,\n          message,\n          name,\n          label,\n          id,\n          value;\n      while (!!(rule = this.rules[++i])) {\n        if (input) {\n          inputs = input.filter(rule.selector);\n        } else {\n          inputs = this.el.find(rule.selector);\n        }\n        j = -1;\n        while (!!(ip = inputs[++j])) {\n          ip = $(ip);\n          value = ip.val();\n          message = rule.callback.call(this, value, ip, this);\n          if (message) {\n            name = ip.attr('name');\n            if (!result) {\n              result = {};\n            }\n            if (!result[name]) {\n              id = ip.attr('id');\n              label = null;\n              if (id) {\n                label = this.el.find('label[for=\"' + id + '\"]').text();\n              }\n              result[name] = {\n                id: id,\n                name: name,\n                label: label,\n                el: ip,\n                value: value,\n                messages: []\n              };\n            }\n            result[name].messages.push(message);\n          }\n        }\n      }\n      if (result) {\n        promise.reject(result);\n      } else {\n        promise.resolve(this.values());\n      }\n      return promise\n        .error(function(inputs) {\n          this.trigger('invalid', {inputs: inputs});\n        })\n        .success(function(values) {\n          this.trigger('valid', values);\n        })\n        .success(success)\n        .error(error);\n    },\n    /**\n     * Ready the form for garbage collection\n     * @method dispose\n     */\n    dispose: function() {\n      this.unbind();\n      Widget.prototype.dispose.call(this);\n    }\n  });\n  /**\n   * Extends the form with new submit handlers\n   * @method withSubmit\n   * @static\n   *\n   * @param {Function} success  The success handler\n   * @param {Function} error  The error handler\n   * @return {Function}  A new [@Lavaca.ui.Form]-derived type\n   */\n  Form.withSubmit = function(success, error) {\n    return Form.extend({\n      onSubmitSuccess: function(values) {\n        success.call(this, values);\n      },\n      onSubmitError: function(inputs) {\n        error.call(this, inputs);\n      }\n    });\n  };\n\n  return Form;\n\n",
    "js/libs/lavaca.js[353885:354692]": "\n\n  var $ = require('$'),\n      EventDispatcher = require('lavaca/events/EventDispatcher'),\n      uuid = require('lavaca/util/uuid');\n\n  /**\n   * Base type for all UI elements\n   * @class lavaca.ui.Widget\n   * @extends lavaca.events.EventDispatcher\n   *\n   * @constructor\n   *\n   * @param {jQuery} el  The DOM element that is the root of the widget\n   */\n  var Widget = EventDispatcher.extend(function(el) {\n    EventDispatcher.call(this);\n    /**\n     * The DOM element that is the root of the widget\n     * @property {jQuery} el\n     * @default null\n     */\n    this.el = el = $(el);\n    var id = el.attr('id');\n    if (!id) {\n      id = 'widget-' + uuid();\n    }\n    /**\n     * The el's ID\n     * @property {String} id\n     * @default (Autogenerated)\n     */\n    this.id = id;\n  });\n\n  return Widget;\n\n",
    "js/libs/lavaca.js[354777:356364]": "\n\n  var $ = require('$'),\n      Widget = require('./Widget');\n\n  /**\n   * Type that shows/hides a loading indicator\n   * @class lavaca.ui.LoadingIndicator\n   * @extends lavaca.ui.Widget\n   *\n   * @constructor\n   * @param {jQuery} el  The DOM element that is the root of the widget\n   */\n  var LoadingIndicator = Widget.extend({\n    /**\n     * Class name applied to the root\n     * @property {String} className\n     * @default 'loading'\n     */\n    className: 'loading',\n    /**\n     * Activates the loading indicator\n     * @method show\n     */\n    show: function() {\n      this.el.addClass(this.className);\n    },\n    /**\n     * Deactivates the loading indicator\n     * @method hide\n     */\n    hide: function() {\n      this.el.removeClass(this.className);\n    }\n  });\n  /**\n   * Creates a loading indicator and binds it to the document's AJAX events\n   * @method init\n   * @static\n   */\n   /** Creates a loading indicator and binds it to the document's AJAX events\n   * @method init\n   * @static\n   * @param {Function} TLoadingIndicator  The type of loading indicator to create (should derive from [[Lavaca.ui.LoadingIndicator]])\n   */\n  LoadingIndicator.init = function(TLoadingIndicator) {\n    TLoadingIndicator = TLoadingIndicator || LoadingIndicator;\n    var indicator = new TLoadingIndicator(document.body);\n    function show() {\n      indicator.show();\n    }\n    function hide() {\n      indicator.hide();\n    }\n    $(document)\n      .on('ajaxStart', show)\n      .on('ajaxStop', hide)\n      .on('ajaxError', hide);\n    return indicator;\n  };\n\n  return LoadingIndicator.init();\n\n",
    "js/libs/lavaca.js[356465:360165]": "\n\n  var Cache = require('lavaca/util/Cache'),\n      Map = require('lavaca/util/Map');\n\n  var _cache = new Cache(),\n      _types = [];\n\n  /**\n   * Abstract type for templates\n   * @class lavaca.ui.Template\n   * @extends lavaca.util.Map\n   */\n  var Template = Map.extend({\n    /**\n     * Compiles the template\n     * @method compile\n     */\n    compile: function() {\n      // Do nothing\n    },\n    /**\n     * Renders the template to a string\n     * @method render\n     *\n     * @param {Object} model  The data model to provide to the template\n     * @return {Lavaca.util.Promise}  A promise\n     */\n    render: function() {\n      throw 'Abstract';\n    },\n    /**\n     * Parses server data to include in this lookup\n     * @method process\n     *\n     * @param {String} text  The server data string\n     */\n    process: function(text) {\n      this.code = text;\n    }\n  });\n  /**\n   * Finds the template with a given name\n   * @method get\n   * @static\n   *\n   * @param {String} name  The name of the template\n   * @return {Lavaca.ui.Template}  The template (or null if no such template exists)\n   */\n  Template.get = function(name) {\n    return _cache.get(name);\n  };\n  /**\n   * Scans the document for all templates with registered types and\n   *   prepares template objects from them\n   * @method init\n   * @static\n   */\n   /**\n   *\n   * Scans the document for all templates with registered types and\n   *   prepares template objects from them\n   * @method init\n   * @static\n   * @param {jQuery} scope  The element to which to limit the scan\n   */\n  Template.init = function(scope) {\n    var i = -1,\n        type, templates, templateName, template;\n\n    while (!!(type = _types[++i])) {\n      var construct = function(name, src, code) {\n        return new type.js(name, src, code);\n      };\n\n      // Load pre-compiled templates\n      if (typeof type.js.getCompiledTemplates === \"function\") {\n        templates = type.js.getCompiledTemplates();\n        for (templateName in templates) {\n          template = construct(templateName, null, templates[templateName]);\n          template.compiled = true;\n          _cache.set(templateName, template);\n        }\n      }\n\n      // Load un-compiled templates\n      if (type.mime) {\n        Map.init(_cache, type.mime, construct, scope);\n      }\n    }\n  };\n  /**\n   * Disposes of all templates\n   * @method dispose\n   * @static\n   */\n  Template.dispose = function() {\n    Map.dispose(_cache);\n  };\n  /**\n   * Finds the named template and renders it to a string\n   * @method render\n   * @static\n   *\n   * @param {String} name  The name of the template\n   * @param {Object} model  The data model to provide to the template\n   * @return {Lavaca.util.Promise}  A promise\n   */\n  Template.render = function(name, model) {\n    var template = Template.get(name);\n    if (!template) {\n      throw 'No template named \"' + name + '\"';\n    } else {\n      return template.render(model);\n    }\n  };\n  /**\n   * Registers a type of template to look for on intilization.\n   * @method register\n   * @static\n   * @param {String} mimeType  The mime-type associated with the template\n   * @param {Function} TTemplate  The JavaScript type used for the template (should derive from [[Lavaca.ui.Template]])\n   */\n   /**\n   * Registers a type of template to look for on intilization.\n   * @method register\n   * @static\n   * @param {Function} TTemplate  The JavaScript type used for the template (should derive from [[Lavaca.ui.Template]])\n   */\n  Template.register = function(mimeType, TTemplate) {\n    if (typeof mimeType === \"function\") {\n      TTemplate = mimeType;\n      mimeType = null;\n    }\n    _types[_types.length] = {mime: mimeType, js: TTemplate};\n  };\n\n  return Template;\n\n",
    "js/libs/lavaca.js[360215:362503]": "\n\n  /**\n   * Utility class for working with arrays\n   * @class lavaca.util.ArrayUtils\n   */\n  var ArrayUtils = {};\n\n  /**\n   * Gets the first index of an item in an array\n   * @method indexOf\n   * @static\n   *\n   * @param {Array} a  The array\n   * @param {Object} o  The object to look for\n   * @return {Number}  The first index of the object, or -1 if not found\n   */\n  ArrayUtils.indexOf = function(a, o) {\n    if (!a) {\n      return -1;\n    } else if (a.indexOf) {\n      return a.indexOf(o);\n    } else {\n      for (var i = 0, j = a.length; i < j; i++) {\n        if (a[i] === o) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  };\n\n  /**\n   * Determines whether an array contains an object\n   * @method contains\n   * @static\n   *\n   * @param {Array} a  The array\n   * @param {Object} o  The object to look for\n   * @return {Boolean}  True when the array contains the object, false otherwise\n   */\n  ArrayUtils.contains = function(a, o) {\n    return ArrayUtils.indexOf(a, o) > -1;\n  };\n\n  /**\n   * Removes the first instance of an item from an array, if it exists\n   * @method remove\n   * @static\n   *\n   * @param {Array} a  The array\n   * @param {Object} o  The object to remove\n   * @return {Number}  The former index of the item (or -1 if the item was not\n   *   in the array)\n   */\n  ArrayUtils.remove = function(a, o) {\n    var index = ArrayUtils.indexOf(a, o);\n    if (index > -1) {\n      a.splice(index, 1);\n    }\n    return index;\n  };\n\n  /**\n   * Adds an item to the end of an array, if it was not already in the array\n   * @method pushIfNotExists\n   * @static\n   *\n   * @param {Array} a  The array\n   * @param {Object} o  The object to add to the array\n   * @return {Number}  The index of the item in the array\n   */\n  ArrayUtils.pushIfNotExists = function(a, o) {\n    var index = ArrayUtils.indexOf(a, o);\n    if (index === -1) {\n      a[index = a.length] = o;\n    }\n    return index;\n  };\n  /**\n   * Determines if object is an array\n   * @method isArray\n   * @static\n   *\n   * @param {Object} a  Any value of any type\n   * @return {Boolean}  True if a is a true array\n   */\n  ArrayUtils.isArray = function(a) {\n    return Array.isArray === 'function' ? Array.isArray(a) : Object.prototype.toString.call(a) === '[object Array]';\n  };\n\n  return ArrayUtils;\n\n",
    "js/libs/lavaca.js[362608:367016]": "\n\n  var Disposable = require('lavaca/util/Disposable'),\n      uuid = require('lavaca/util/uuid');\n\n  /**\n   * Object for storing data\n   * @class lavaca.util.Cache\n   * @extends lavaca.util.Disposable\n   */\n  var Cache = Disposable.extend({\n    /**\n     *\n     * Retrieves an item from the cache\n     * @method get\n     * @param {String} id  The key under which the item is stored\n     * @return {Object}  The stored item (or null if no item is stored)\n     */\n     /**\n     * Retrieves an item from the cache\n     * @method get\n     * @param {String} id  The key under which the item is stored\n     * @param {Object} def  A default value that will be added, if there is no item stored\n     * @return {Object}  The stored item (or null if no item is stored and no default)\n     */\n    get: function(id, def) {\n      var result = this['@' + id];\n      if (result === undefined && def !== undefined) {\n        result = this['@' + id] = def;\n      }\n      return result === undefined ? null : result;\n    },\n    /**\n     * Assigns an item to a key in the cache\n     * @method set\n     *\n     * @param {String} id  The key under which the item will be stored\n     * @param {Object} value  The object to store in the cache\n     */\n    set: function(id, value) {\n      this['@' + id] = value;\n    },\n    /**\n     * Adds an item to the cache\n     * @method add\n     *\n     * @param {Object} value  The object to store in the cache\n     * @return {String}  The auto-generated ID under which the value was stored\n     */\n    add: function(value) {\n      var id = uuid();\n      this.set(id, value);\n      return id;\n    },\n    /**\n     * Removes an item from the cache (if it exists)\n     * @method remove\n     *\n     * @param {String} id  The key under which the item is stored\n     */\n    remove: function(id) {\n      delete this['@' + id];\n    },\n    /**\n     * Executes a callback for each cached item. To stop iteration immediately,\n     * return false from the callback.\n     * @method each\n     * @param {Function} callback  A function to execute for each item, callback(key, item)\n     */\n     /**\n     * Executes a callback for each cached item. To stop iteration immediately,\n     * return false from the callback.\n     * @method each\n     * @param {Function} callback  A function to execute for each item, callback(key, item)\n     * @param {Object} thisp  The context of the callback\n     */\n    each: function(cb, thisp) {\n      var prop, returned;\n      for (prop in this) {\n        if (this.hasOwnProperty(prop) && prop.indexOf('@') === 0) {\n          returned = cb.call(thisp || this, prop.slice(1), this[prop]);\n          if (returned === false) {\n            break;\n          }\n        }\n      }\n    },\n    /**\n     * Serializes the cache to a hash\n     * @method toObject\n     *\n     * @return {Object}  The resulting key-value hash\n     */\n    toObject: function() {\n      var result = {};\n      this.each(function(prop, value) {\n        result[prop] = (value && typeof value.toObject === 'function') ? value.toObject() : value;\n      });\n      return result;\n    },\n    /**\n     * Serializes the cache to JSON\n     * @method toJSON\n     *\n     * @return {String}  The JSON string\n     */\n    toJSON: function() {\n      return JSON.stringify(this.toObject());\n    },\n     /**\n     * Serializes the cache to an array\n     * @method toArray\n     *\n     * @return {Object}  The resulting array with elements being index based and keys stored in an array on the 'ids' property\n     */\n    toArray: function() {\n      var results = [];\n      results['ids'] = [];\n      this.each(function(prop, value) {\n        results.push(typeof value.toObject === 'function' ? value.toObject() : value);\n        results['ids'].push(prop);\n      });\n      return results;\n    },\n\n    /**\n     * removes all items from the cache\n     * @method clear\n     */\n    clear: function() {\n       this.each(function(key, item) {\n         this.remove(key);\n       }, this);\n    },\n\n    /**\n     * returns number of items in cache\n     * @method count\n     */\n    count: function() {\n      var count = 0;\n      this.each(function(key, item) {\n        count++;\n      }, this);\n      return count;\n    },\n\n    /**\n     * Clears all items from the cache on dispose\n     * @method dispose\n     */\n    dispose: function() {\n      this.clear();\n      Disposable.prototype.dispose.apply(this, arguments);\n    }\n  });\n\n  return Cache;\n\n",
    "js/libs/lavaca.js[367062:369173]": "\n  /**\n   * Establishes inheritance between types. After a type is extended, it receives its own static\n   * convenience method, extend(TSub, overrides).\n   * @class lavaca.util.extend\n   */\n   /**\n   * Establishes inheritance between types. After a type is extended, it receives its own static\n   * convenience method, extend(TSub, overrides).\n   * @method extend\n   * @static\n   *\n   */\n   /**\n   * Establishes inheritance between types. After a type is extended, it receives its own static\n   * convenience method, extend(TSub, overrides).\n   * @method extend\n   * @static\n   * @param {Function} TSub  The child type which will inherit from superType\n   * @param {Object} overrides  A hash of key-value pairs that will be added to the subType\n   * @return {Function}  The subtype\n   *\n   */\n   /**\n   * Establishes inheritance between types. After a type is extended, it receives its own static\n   * convenience method, extend(TSub, overrides).\n   * @method extend\n   * @static\n   * @param {Function} TSuper  The base type to extend\n   * @param {Function} TSub  The child type which will inherit from superType\n   * @param {Object} overrides  A hash of key-value pairs that will be added to the subType\n   * @return {Function}  The subtype\n   */\n  var extend = function(TSuper, TSub, overrides) {\n    if (typeof TSuper === 'object') {\n      overrides = TSuper;\n      TSuper = Object;\n      TSub = function() {\n        // Empty\n      };\n    } else if (typeof TSub === 'object') {\n      overrides = TSub;\n      TSub = TSuper;\n      TSuper = Object;\n    }\n    function ctor() {\n      // Empty\n    }\n    ctor.prototype = TSuper.prototype;\n    TSub.prototype = new ctor;\n    TSub.prototype.constructor = TSub;\n    if (overrides) {\n      for (var name in overrides) {\n        TSub.prototype[name] = overrides[name];\n      }\n    }\n    TSub.extend = function(T, overrides) {\n      if (typeof T === 'object') {\n        overrides = T;\n        T = function() {\n          TSub.apply(this, arguments);\n        };\n      }\n      extend(TSub, T, overrides);\n      return T;\n    };\n    return TSub;\n  };\n\n  return extend;\n\n",
    "js/libs/lavaca.js[369250:370249]": "\n\n  var extend = require('./extend');\n\n  function _disposeOf(obj) {\n    var n,\n        o,\n        i;\n    for (n in obj) {\n      if (obj.hasOwnProperty(n)) {\n        o = obj[n];\n          if (o) {\n            if (typeof o === 'object' && typeof o.dispose === 'function') {\n              o.dispose();\n            } else if (o instanceof Array) {\n              for (i = o.length - 1; i > -1; i--) {\n                  if (o[i] && typeof o[i].dispose === 'function') {\n                    o[i].dispose();\n                  } else {\n                    _disposeOf(o[i]);\n                  }\n                }\n            }\n          }\n        }\n    }\n  }\n\n  /**\n   * Abstract type for types that need to ready themselves for GC\n   * @class lavaca.util.Disposable\n   * @constructor\n   *\n   */\n  var Disposable = extend({\n    /**\n     * Readies the object to be garbage collected\n     * @method dispose\n     *\n     */\n    dispose: function() {\n        _disposeOf(this);\n    }\n  });\n\n  return Disposable;\n\n",
    "js/libs/lavaca.js[370362:375803]": "\n\n  var $ = require('$'),\n      Cache = require('./Cache'),\n      Disposable = require('./Disposable'),\n      Connectivity = require('lavaca/net/Connectivity');\n\n  function _absolute(url) {\n    if (url && url.indexOf('http') !== 0) {\n      if (url.charAt(0) === '/') {\n        url = location.protocol + '//'\n          + location.hostname\n          + (location.port ? ':' + location.port : '')\n          + (url.indexOf('/') === 0 ? url : '/' + url);\n      } else {\n        url = location.toString().split('#')[0].split('?')[0].replace(/\\w+\\.\\w+$/, '') + url;\n      }\n    }\n    return url;\n  }\n\n  /**\n   * Abstract type for lookup tables\n   * @class lavaca.util.Map\n   * @extends lavaca.util.Disposable\n   *\n   * @constructor\n   * @param {String} name  The name of the map\n   * @param {String} src  The URL of the map's data (or null if code is supplied)\n   * @param {String} code  The raw string data for the map (or null if src is supplied)\n   */\n  var Map = Disposable.extend(function(name, src, code) {\n    Disposable.call(this);\n    /**\n     * Whether or not the map has loaded\n     * @property {Boolean} hasLoaded\n     * @default false\n     */\n    this.hasLoaded = false;\n    /**\n     * The name of the map\n     * @property {String} name\n     * @default null\n     */\n    this.name = name;\n    /**\n     * The source URL for the map\n     * @property {String} src\n     * @default null\n     */\n    this.src = _absolute(src);\n    /**\n     * The raw string data for the map\n     * @property {String} code\n     * @default null\n     */\n    this.code = code;\n    /**\n     * The cache in which this map stores data\n     * @property {Lavaca.util.Cache} cache\n     * @default new Lavaca.util.Cache()\n     */\n    this.cache = new Cache();\n  }, {\n    /**\n     * Determines whether or not this is the desired lookup\n     * @method is\n     *\n     * @param {String} name  The name of the lookup\n     * @return {Boolean}  True if this is the lookup\n     */\n    is: function(name) {\n      return this.name === name;\n    },\n    /**\n     * Gets the value stored under a code\n     * @method get\n     *\n     * @param {String} code  The code\n     * @return {Object}  The value (or null)\n     */\n    get: function(code) {\n      if (!this.hasLoaded) {\n        if (this.code) {\n          this.add(this.code);\n        } else if (this.src) {\n          this.load(this.src);\n        }\n        this.hasLoaded = true;\n      }\n      return this.cache.get(code);\n    },\n    /**\n     * Adds parameters to this map\n     * @method add\n     *\n     * @param {Object} data  The parameters to add\n     */\n    add: function(data) {\n      for (var n in data) {\n        this.cache.set(n, data[n]);\n      }\n    },\n    /**\n     * Processes server data to include in this lookup\n     * @method process\n     *\n     * @param {String} text  The server data string\n     */\n    process: function(text) {\n      this.add(typeof text === 'string' ? JSON.parse(text) : text);\n    },\n    /**\n     * Adds JSON data to this map (synchronous)\n     * @method load\n     *\n     * @param {String} url  The URL of the data\n     */\n    load: function(url) {\n      var self = this;\n      Connectivity.ajax({\n        async: false,\n        url: url,\n        success: function(resp) {\n          self.process(resp);\n        }\n      });\n    }\n  });\n  /**\n   * Sets the application's default config\n   * @method setDefault\n   * @static\n   *\n   * @param {Lavaca.util.Cache} cache  The map cache\n   * @param {String} name  The name of the config\n   */\n  Map.setDefault = function(cache, name) {\n    var map = name;\n    if (typeof map === 'string') {\n      map = cache.get(name);\n    }\n    cache.set('default', map);\n  };\n  /**\n   * Finds the most appropriate value for a code\n   * @method get\n   * @static\n   *\n   * @param {Lavaca.util.Cache} cache  The maps cache\n   * @param {String} name  The name of the map\n   * @param {String} code  The name of the parameter\n   * @param {String} defaultName  The name of the default map\n   * @return {Object}  The value of the parameter\n   */\n  Map.get = function(cache, name, code, defaultName) {\n    if (!code) {\n      code = name;\n      name = defaultName;\n    }\n    if (name) {\n      var map = cache.get(name);\n      if (map) {\n        return map.get(code);\n      }\n    }\n    return null;\n  };\n  /**\n   * Scans the document for all maps and prepares them\n   * @method init\n   * @static\n   *\n   * @param {Lavaca.util.Cache} cache  The map cache\n   * @param {String} mimeType  The MIME type of the scripts\n   * @param {Function} construct  A function that returns a new map, in\n   *   the form construct(name, src, code)\n   * @param {jQuery} scope  The element to which to limit the scan\n   */\n  Map.init = function(cache, mimeType, construct, scope) {\n    $(scope || document.documentElement)\n      .find('script[type=\"' + mimeType + '\"]')\n      .each(function() {\n        var item = $(this),\n            src = item.attr('data-src'),\n            name = item.attr('data-name'),\n            isDefault = typeof item.attr('data-default') === 'string',\n            code = item.text(),\n            map;\n        map = construct(name, src, code);\n        cache.set(map.name, map);\n        if (isDefault) {\n          Map.setDefault(cache, name);\n        }\n      });\n  };\n  /**\n   * Disposes of all maps\n   * @method dispose\n   * @static\n   *\n   * @param {Lavaca.util.Cache} cache  The map cache\n   */\n  Map.dispose = function(cache) {\n    cache.dispose();\n  };\n\n  return Map;\n\n",
    "js/libs/lavaca.js[375883:377873]": "\n\n  var Cache = require('./Cache'),\n      Map = require('./Map');\n\n  var _cache = new Cache();\n\n  function _construct(name, src, code) {\n    if (code) {\n      code = JSON.parse(code);\n    }\n    return new Config(name, src, code);\n  }\n\n  /**\n   * Configuration management type\n   * @class lavaca.util.Config\n   * @extends lavaca.util.Map\n   */\n  var Config = Map.extend({\n    // Empty (no overrides)\n  });\n  /**\n   * Sets the application's default config\n   * @method setDefault\n   * @static\n   *\n   * @param {String} name  The name of the default config\n   */\n  Config.setDefault = function(name) {\n    Map.setDefault(_cache, name);\n  };\n  /**\n   * Gets the application's current config environment name\n   * @method currentEnvironment\n   * @static\n   *\n   * @return {String} The name of the current environment\n   */\n  Config.currentEnvironment = function() {\n    return _cache.get('default').name;\n  };\n  /**\n   * Retrieves a value from the configuration\n   * @method get\n   * @static\n   * @param {String} code  The name of the parameter\n   * @return {Object}  The value of the parameter\n   */\n   /**\n   * Retrieves a value from the configuration\n   * @method get\n   * @static\n   * @param {String} name  The name of the config\n   * @param {String} code  The name of the parameter\n   * @return {Object}  The value of the parameter\n   */\n  Config.get = function(name, code) {\n    return Map.get(_cache, name, code, 'default');\n  };\n  /**\n   * Scans the document for all translations and prepares them\n   * @method init\n   * @static\n   */\n   /**\n   * Scans the document for all translations and prepares them\n   * @method init\n   * @static\n   * @param {jQuery} scope  The element to which to limit the scan\n   */\n  Config.init = function(scope) {\n    Map.init(_cache, 'text/x-config', _construct, scope);\n  };\n  /**\n   * Disposes of all translations\n   * @method dispose\n   * @static\n   */\n  Config.dispose = function() {\n    Map.dispose(_cache);\n  };\n\n  Config.init();\n\n  return Config;\n\n",
    "js/libs/lavaca.js[377958:382570]": "\n\n  var Cache = require('./Cache'),\n      Map = require('./Map');\n\n  var _cache = new Cache();\n\n  function _construct(name, src, code) {\n    if (code) {\n      code = JSON.parse(code);\n    }\n    var map = new Translation(name, src, code);\n    if (!_cache.get(map.language)) {\n      _cache.set(map.language, map);\n    }\n    return map;\n  }\n\n  /**\n   * Translation dictionary\n   * @class lavaca.util.Translation\n   * @extends lavaca.util.Map\n   *\n   * @constructor\n   * @param {String} name  The name of the map\n   * @param {String} src  The URL of the map's data (or null if code is supplied)\n   * @param {String} code  The raw string data for the map (or null if src is supplied)\n   */\n  var Translation = Map.extend(function(name) {\n    Map.apply(this, arguments);\n    var locale = name.toLowerCase().split('_');\n    /**\n     * The ISO 639-2 code for the translation's language\n     * @property {String} language\n     * @default null\n     */\n    this.language = locale[0];\n    /**\n     * The ISO 3166-1 code for the translation's country\n     * @property {String} country\n     * @default ''\n     */\n    this.country = locale[1] || '';\n    /**\n     * The locale of this translation (either lang or lang_COUNTRY)\n     * @property {String} locale\n     * @default null\n     */\n    this.locale = this.country\n      ? this.language + '_' + this.country\n      : this.language;\n  }, {\n    /**\n     * Determines whether or not this translation works for a locale\n     * @method is\n     * @param {String} language  The locale's language\n     * @return {Boolean}  True if this translation applies\n     */\n    /**\n     * Determines whether or not this translation works for a locale\n     * @method is\n     * @param {String} language  The locale's language\n     * @param {String} country   (Optional) The locale's country\n     * @return {Boolean}  True if this translation applies\n     */\n    is: function(language, country) {\n      return language === this.language\n        && (!country || !this.country || country === this.country);\n    }\n  });\n  /**\n   * Sets the application's default locale\n   * @method setDefault\n   * @static\n   *\n   * @param {String} locale  A locale string (ie, \"en\", \"en_US\", or \"es_MX\")\n   */\n  Translation.setDefault = function(locale) {\n    _cache.remove('default');\n    Map.setDefault(_cache, Translation.forLocale(locale));\n  };\n  /**\n   * Finds the most appropriate translation for a given locale\n   * @method forLocale\n   * @static\n   *\n   * @param {String} locale  The locale\n   * @return {Lavaca.util.Translation}  The translation\n   */\n  Translation.forLocale = function(locale) {\n    locale = (locale || 'default').toLowerCase();\n    return _cache.get(locale)\n      || _cache.get(locale.split('_')[0])\n      || _cache.get('default');\n  };\n  /**\n   * Finds the most appropriate translation of a message for the default locale\n   * @method get\n   * @static\n   * @param {String} code  The code under which the message is stored\n   * @return {Lavaca.util.Translation}  The translation\n   */\n  /**\n   * Finds the most appropriate translation of a message for the default locale\n   * @method get\n   * @static\n   * @param {String} locale  The locale\n   * @param {String} code  The code under which the message is stored\n   * @return {Lavaca.util.Translation}  The translation\n   */\n  Translation.get = function(locale, code) {\n    if (!code) {\n      code = locale;\n      locale = 'default';\n    }\n    var translation = Translation.forLocale(locale),\n        result = null;\n    if (translation) {\n      result = translation.get(code);\n    }\n    if (result === null) {\n      translation = Translation.forLocale(locale.split('_')[0]);\n      if (translation) {\n        result = translation.get(code);\n      }\n    }\n    if (result === null) {\n      translation = Translation.forLocale('default');\n      if (translation) {\n        result = translation.get(code);\n      }\n    }\n    return result;\n  };\n  /**\n   * Scans the document for all translations and prepares them\n   * @method init\n   * @static\n   * @param {String} locale  The default locale\n   */\n  /**\n   * Scans the document for all translations and prepares them\n   * @method init\n   * @static\n   * @param {String} locale  The default locale\n   * @param {jQuery} scope  The element to which to limit the scan\n   */\n  Translation.init = function(locale, scope) {\n    Map.init(_cache, 'text/x-translation', _construct, scope);\n    Translation.setDefault(locale);\n  };\n  /**\n   * Disposes of all translations\n   * @method dispose\n   * @static\n   */\n  Translation.dispose = function() {\n    Map.dispose(_cache);\n  };\n\n  return Translation;\n\n",
    "js/libs/lavaca.js[382651:398604]": "\n\n  var Translation = require('./Translation');\n\n  /**\n   * Utility class for working with dates\n   * @class lavaca.util.DateUtils\n   */\n  var DateUtils = {};\n\n  function _int(input) {\n    return parseInt(input, 10);\n  }\n\n  function _indexOfCode(input, array) {\n    input = input.toLowerCase();\n    var i = -1,\n        code;\n    while (!!(code = array[++i])) {\n      if (input === code.toLowerCase() || input === _translate(code).toLowerCase()) {\n        return i - 1;\n      }\n    }\n    throw 'Invalid code \"' + code + '\"';\n  }\n\n  function _pad(n, digits, c) {\n    var sign = n < 0 ? '-' : '';\n    c = c || '0';\n    n = Math.abs(n).toString();\n    while (digits - n.length > 0) {\n      n = c + n;\n    }\n    return sign + n;\n  }\n\n  function _translate(s) {\n    return Translation.get(s);\n  }\n\n  /**\n   * The time of day abbreviation. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.\n   * @property {Array} timeOfDayDesignatorAbbr\n   * @static\n   * @default [\"A\", \"P\"]*/\n  DateUtils.timeOfDayDesignatorAbbr = [\n    'A',\n    'P'\n  ];\n\n  /**\n   * The time of day. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.\n   * @property {Array} timeOfDayDesignator\n   * @static\n   * @default [\"AM\", \"PM\"]\n   */\n  DateUtils.timeOfDayDesignator = [\n    'AM',\n    'PM'\n  ];\n\n  /**\n   * The abbreviated days of the week. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.\n   * @property {Array} daysOfWeekAbbr\n   * @static\n   * @default [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"]\n   * */\n  DateUtils.daysOfWeekAbbr = [\n    'Sun',\n    'Mon',\n    'Tue',\n    'Wed',\n    'Thu',\n    'Fri',\n    'Sat'\n  ];\n\n  /**\n   * The days of the week. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.\n   * @property {Array} daysOfWeek\n   * @static\n   * @default [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n   */\n  DateUtils.daysOfWeek = [\n    'Sunday',\n    'Monday',\n    'Tuesday',\n    'Wednesday',\n    'Thursday',\n    'Friday',\n    'Saturday'\n  ];\n\n  /**\n   * The abbreviated months. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.\n   * @property {Array} monthsAbbr\n   * @static\n   * @default [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n   */\n  DateUtils.monthsAbbr = [\n    'Jan',\n    'Feb',\n    'Mar',\n    'Apr',\n    'May',\n    'Jun',\n    'Jul',\n    'Aug',\n    'Sep',\n    'Oct',\n    'Nov',\n    'Dec'\n  ];\n\n  /**\n   * The months. You can supply [[Lavaca.util.Translation]] values using these names as keys to translate.\n   * @property {Array} months\n   * @static\n   * @default [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\n   */\n  DateUtils.months = [\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December'\n  ];\n\n  /**\n   * Object containing the functions used by each date format code. Default format codes are:\n   *\n   * <dl>\n   * <dt>d</dt> <dd>Day of month (1 - 31)</dd>\n   * <dt>dd</dt> <dd>Padded day of month (01 - 31)</dd>\n   * <dt>ddd</dt> <dd>Abbreviated day of week (Sun - Sat)</dd>\n   * <dt>ddd</dt> <dd>Full day of week (Sunday - Saturday)</dd>\n   * <dt>f</dt> <dd>Tenth of a second</dd>\n   * <dt>ff</dt> <dd>Hundreth of a second</dd>\n   * <dt>fff</dt> <dd>Milliseconds</dd>\n   * <dt>h</dt> <dd>Twelve-hour clock hour (1 - 12)</dd>\n   * <dt>hh</dt> <dd>Padded twelve-hour clock hour (01 - 12)</dd>\n   * <dt>H</dt> <dd>Twenty-four hour clock hour (0 - 23)</dd>\n   * <dt>HH</dt> <dd>Padded twenty-four hour clock hour (00 - 23)</dd>\n   * <dt>m</dt> <dd>Minute (0 - 59)</dd>\n   * <dt>mm</dt> <dd>Padded minute (00 - 59)</dd>\n   * <dt>M</dt> <dd>Month (1 - 12)</dd>\n   * <dt>MM</dt> <dd>Padded month (01 - 12)</dd>\n   * <dt>MMM</dt> <dd>Abbreviated month (Jan - Dec)</dd>\n   * <dt>MMMM</dt> <dd>Full month (January - December)</dd>\n   * <dt>s</dt> <dd>Second (0 - 59)</dd>\n   * <dt>ss</dt> <dd>Padded second (00 - 59)</dd>\n   * <dt>t</dt> <dd>Abbreviated AM/PM designator (A or P)</dd>\n   * <dt>tt</dt> <dd>Full AM/PM designator (AM or PM)</dd>\n   * <dt>y</dt> <dd>Short year (0 - 99)</dd>\n   * <dt>yy</dt> <dd>Padded short year (00 - 99)</dd>\n   * <dt>yyy</dt> <dd>Full year padded to at least 3 digits (000+)</dd>\n   * <dt>yyyy</dt> <dd>Full year padded to at least 4 digits (0000+)</dd>\n   * <dt>z</dt> <dd>Hours offset from UTC (-12, 0, 12)</dd>\n   * <dt>zz</dt> <dd>Padded hours offset from UTC (-12, 00, 12)</dd>\n   * <dt>zzz</dt> <dd>Padded hours and minute offset from UTC (-12:00, 00:00, 12:00)</dd>\n   * </dl>\n   *\n   * To add a custom format code, assign this property an object containing an <code>i</code> function (responsible for parsing)\n   * and an <code>o</code> function (responsible for stringifying). The <code>i</code> function\n   * should assign to one of the following properties of its second argument: date, month, year,\n   * hour, minute, second, ms, or offset. Example: <code>Lavaca.util.DateUtils.fn.QQQ = {i: function(input, dateObj, mappedObj) { dateObj.date = parseInt(input, 10); }, o: function(date, utc) { return (utc ? date.getUTCDate() : date.getDate()).toString(); }};</code>\n   *\n   * @property {Object} fn\n   * @static\n   */\n  DateUtils.fn = {\n    d: {\n      exp: '\\\\d{1,2}',\n      i: function(input, dateObj) {\n        dateObj.date = _int(input);\n      },\n      o: function(date, utc) {\n        return (utc ? date.getUTCDate() : date.getDate()).toString();\n      }\n    },\n    dd: {\n      exp: '\\\\d{2}',\n      i: function(input, dateObj) {\n        dateObj.date = _int(input);\n      },\n      o: function(date, utc) {\n        return _pad(DateUtils.fn.d.o(date, utc), 2);\n      }\n    },\n    ddd: {\n      exp: '[a-z]{3}',\n      i: function() {\n        // Do nothing\n      },\n      o: function(date, utc) {\n        return _translate(DateUtils.daysOfWeekAbbr[utc ? date.getUTCDay() : date.getDay()]);\n      }\n    },\n    dddd: {\n      exp: '[a-z]+',\n      i: function() {\n        // Do nothing\n      },\n      o: function(date, utc) {\n        return _translate(DateUtils.daysOfWeek[utc ? date.getUTCDay() : date.getDay()]);\n      }\n    },\n    f: {\n      exp: '\\\\d',\n      i: function(input, dateObj) {\n        dateObj.ms = _int(input) * 100;\n      },\n      o: function(date, utc, divisor) {\n        divisor = divisor || 100;\n        return _pad(Math.floor((utc ? date.getUTCMilliseconds() : date.getMilliseconds()) / divisor), 3 - divisor.toString().length);\n      }\n    },\n    ff: {\n      exp: '\\\\d{2}',\n      i: function(input, dateObj) {\n        dateObj.ms = _int(input) * 10;\n      },\n      o: function(date, utc) {\n        return _pad(DateUtils.fn.f.o(date, utc, 10), 2);\n      }\n    },\n    fff: {\n      exp: '\\\\d{3}',\n      i: function(input, dateObj) {\n        dateObj.ms = _int(input, 10);\n      },\n      o: function(date, utc) {\n        return _pad(DateUtils.fn.f.o(date, utc, 1), 3);\n      }\n    },\n    h: {\n      exp: '1?\\\\d',\n      i: function(input, dateObj, mappedObj) {\n        var h = _int(input) - 1,\n            tod = (mappedObj.t || mappedObj.tt || 'A').indexOf('A') === 0 ? 0 : 12;\n        dateObj.hour = h + tod;\n      },\n      o: function(date, utc) {\n        return ((utc ? date.getUTCHours() : date.getHours()) % 12 + 1).toString();\n      }\n    },\n    hh: {\n      exp: '[0-1]\\\\d',\n      i: function(input, dateObj, mappedObj) {\n        DateUtils.fn.h.i(input, dateObj, mappedObj);\n      },\n      o: function(date, utc) {\n        return _pad(DateUtils.fn.h.o(date, utc), 2);\n      }\n    },\n    H: {\n      exp: '[0-2]?\\\\d',\n      i: function(input, dateObj) {\n        dateObj.hour = _int(input);\n      },\n      o: function(date, utc) {\n        return (utc ? date.getUTCHours() : date.getHours()).toString();\n      }\n    },\n    HH: {\n      exp: '[0-2]\\\\d',\n      i: function(input, dateObj) {\n        dateObj.hour = _int(input);\n      },\n      o: function (date, utc) {\n        return _pad(DateUtils.fn.H.o(date, utc), 2);\n      }\n    },\n    m: {\n      exp: '[1-5]?\\\\d',\n      i: function(input, dateObj) {\n        dateObj.minute = _int(input);\n      },\n      o: function(date, utc) {\n        return (utc ? date.getUTCMinutes() : date.getMinutes()).toString();\n      }\n    },\n    mm: {\n      exp: '[0-5]\\\\d',\n      i: function(input, dateObj, mappedObj) {\n        DateUtils.fn.m.i(input, dateObj, mappedObj);\n      },\n      o: function(date, utc) {\n        return _pad(DateUtils.fn.m.o(date, utc), 2);\n      }\n    },\n    M: {\n      exp: '1?\\\\d',\n      i: function(input, dateObj) {\n        dateObj.month = _int(input) - 1;\n      },\n      o: function(date, utc) {\n        return ((utc ? date.getUTCMonth() : date.getMonth()) + 1).toString();\n      }\n    },\n    MM: {\n      exp: '[0-1]\\\\d',\n      i: function(input, dateObj, mappedObj) {\n        DateUtils.fn.M.i(input, dateObj, mappedObj);\n      },\n      o: function(date, utc) {\n        return _pad(DateUtils.fn.M.o(date, utc), 2);\n      }\n    },\n    MMM: {\n      exp: '[a-z]{3}',\n      i: function(input, dateObj) {\n        dateObj.month = _indexOfCode(input, DateUtils.monthsAbbr);\n      },\n      o: function(date, utc) {\n        return _translate(DateUtils.monthsAbbr[utc ? date.getUTCMonth() : date.getMonth()]);\n      }\n    },\n    MMMM: {\n      exp: '[a-z]+',\n      i: function(input, dateObj) {\n        dateObj.month = _indexOfCode(input, DateUtils.months);\n      },\n      o: function(date, utc) {\n        return _translate(DateUtils.months[utc ? date.getUTCMonth() : date.getMonth()]);\n      }\n    },\n    s: {\n      exp: '[1-5]?\\\\d',\n      i: function(input, dateObj) {\n        dateObj.second = _int(input);\n      },\n      o: function(date, utc) {\n        return (utc ? date.getUTCSeconds() : date.getSeconds()).toString();\n      }\n    },\n    ss: {\n      exp: '[0-5]\\\\d',\n      i: function(input, dateObj, mappedObj) {\n        DateUtils.fn.s.i(input, dateObj, mappedObj);\n      },\n      o: function(date, utc) {\n        return _pad(DateUtils.fn.s.o(date, utc), 2);\n      }\n    },\n    t: {\n      exp: '[a-z]',\n      i: function() {\n        // Do nothing\n      },\n      o: function(date, utc) {\n        return _translate(DateUtils.timeOfDayDesignatorAbbr[Math.floor((utc ? date.getUTCHours() : date.getHours()) / 12)]);\n      }\n    },\n    tt: {\n      exp: '[a-z]+',\n      i: function() {\n        // Do nothing\n      },\n      o: function(date, utc) {\n        return _translate(DateUtils.timeOfDayDesignator[Math.floor((utc ? date.getUTCHours() : date.getHours()) / 12)]);\n      }\n    },\n    y: {\n      exp: '\\\\d?\\\\d',\n      i: function(input, dateObj) {\n        dateObj.year = (new Date()).getFullYear() % 100 + _int(input);\n      },\n      o: function(date, utc) {\n        return ((utc ? date.getUTCFullYear() : date.getFullYear()) % 100).toString();\n      }\n    },\n    yy: {\n      exp: '\\\\d{2}',\n      i: function(input, dateObj, mappedObj) {\n        DateUtils.fn.y.i(input, dateObj, mappedObj);\n      },\n      o: function(date, utc) {\n        return _pad(DateUtils.fn.y.o(date, utc), 2);\n      }\n    },\n    yyy: {\n      exp: '\\\\d*\\\\d{3}',\n      i: function(input, dateObj) {\n        dateObj.year = _int(input);\n      },\n      o: function(date, utc) {\n        return _pad(utc ? date.getUTCFullYear() : date.getFullYear(), 3);\n      }\n    },\n    yyyy: {\n      exp: '\\\\d*\\\\d{4}',\n      i: function(input, dateObj, mappedObj) {\n        DateUtils.fn.yyy.i(input, dateObj, mappedObj);\n      },\n      o: function(date, utc) {\n        return _pad(utc ? date.getUTCFullYear() : date.getFullYear(), 4);\n      }\n    },\n    z: {\n      exp: '[-+]?1?\\\\d',\n      i: function(input, dateObj) {\n        dateObj.offset = _int(input) * 60;\n      },\n      o: function(date, padding) {\n        var off = date.getTimezoneOffset(),\n            offH = Math.floor(Math.abs(off / 60));\n        return (off < 0 ? '-' : '+') + _pad(offH, padding);\n      }\n    },\n    zz: {\n      exp: '[-+]?[0-1]\\\\d',\n      i: function(input, dateObj, mappedObj) {\n        DateUtils.fn.z.i(input, dateObj, mappedObj);\n      },\n      o: function(date) {\n        return DateUtils.fn.z.o(date, 2);\n      }\n    },\n    zzz: {\n      exp: '[-+]?[0-1]\\\\d:\\\\d{2}',\n      i: function(input, dateObj) {\n        var parts = input.split(':');\n        dateObj.offset = _int(parts[0]) * 60 + _int(parts[1]);\n      },\n      o: function(date) {\n        var z = date.getTimezoneOffset(),\n            sign = z > 0 ? '-' : '+',\n            m = z % 60,\n            h = Math.abs((z - m) / 60);\n        return sign + _pad(h, 2) + ':' + _pad(Math.abs(m), 2);\n      }\n    }\n  };\n\n  function _parseFormat(f) {\n    var actors = [],\n        buffer = '',\n        i = -1,\n        bufferChar,\n        c;\n    while (!!(c = f.charAt(++i))) {\n      bufferChar = buffer.charAt(0);\n      if (bufferChar === c || bufferChar === '\"' || bufferChar === '\\'') {\n        buffer += c;\n        if ((bufferChar === '\"' && c === '\"') || (bufferChar === '\\'' && c === '\\'')) {\n          actors.push(buffer);\n          buffer = '';\n        }\n      } else {\n        if (buffer) {\n          actors.push(buffer);\n        }\n        buffer = c;\n      }\n    }\n    if (buffer) {\n      actors.push(buffer);\n    }\n    return actors;\n  }\n\n  function _actorsToRegex(actors) {\n    var s = ['^'],\n        i = -1,\n        actor,\n        handler;\n    while (!!(actor = actors[++i])) {\n      handler = DateUtils.fn[actor];\n      if (handler) {\n        s.push('(', handler.exp, ')');\n      } else {\n        s.push('(', actor.replace(/(^\")|(^')|('$)|(\"$)/g, '').replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&'), ')');\n      }\n    }\n    s.push('$');\n    return new RegExp(s.join(''));\n  }\n\n  /**\n   * @method parse\n   * @static\n   * Converts a string to a date\n   *\n   * @param {String} s  The date string\n   * @param {String} f  The format of the date string\n   * @return {Date}  The parsed date\n   */\n  DateUtils.parse = function(s, f) {\n    var actors = _parseFormat(f),\n        exp = _actorsToRegex(actors),\n        dateObj = {year: 0, month: 0, date: 1, hour: 0, minute: 0, second: 0, ms: 0, offset: 0},\n        mappedObj = {},\n        i = -1,\n        actor,\n        match,\n        handler;\n    if (exp.test(s)) {\n      match = exp.exec(s);\n      while (!!(actor = actors[++i])) {\n        mappedObj[actor] = match[i + 1];\n      }\n    }\n    for (actor in mappedObj) {\n      handler = DateUtils.fn[actor];\n      if (handler) {\n        handler.i(mappedObj[actor], dateObj, mappedObj);\n      }\n    }\n    return new Date(\n        DateUtils.monthsAbbr[dateObj.month]\n      + ' '\n      + _pad(dateObj.date, 2)\n      + ' '\n      + _pad(dateObj.year, 4)\n      + ' '\n      + _pad(dateObj.hour, 2)\n      + ':'\n      + _pad(dateObj.minute, 2)\n      + ':'\n      + _pad(dateObj.second, 2)\n      + (dateObj.ms > 0 ? '.' + _pad(dateObj.ms, 3) : '')\n      + (dateObj.offset >= 0 ? '+' : '-')\n      + _pad(Math.floor(Math.abs(dateObj.offset / 60)), 2)\n      + _pad(Math.abs(dateObj.offset % 60), 2));\n  };\n\n  /**\n   * Converts a date to a string\n   * @method stringify\n   * @static\n   * @param {Date} d  The date\n   * @param {String} f  The string format of the date\n   * @return {String}  The stringified date\n   */\n   /**\n   * Converts a date to a string\n   * @method stringify\n   * @static\n   * @param {Date} d  The date\n   * @param {String} f  The string format of the date\n   * @param {Boolean} utc  When true, use the UTC date to generate the string\n   * @return {String}  The stringified date\n   */\n  DateUtils.stringify = function(d, f, utc) {\n    var actors = _parseFormat(f),\n        i = -1,\n        s = [],\n        actor,\n        handler;\n    while (!!(actor = actors[++i])) {\n      handler = DateUtils.fn[actor];\n      if (handler) {\n        s.push(handler.o(d, utc));\n      } else {\n        s.push(actor.replace(/(^\")|(^')|('$)|(\"$)/g, ''));\n      }\n    }\n    return s.join('');\n  };\n\n  return DateUtils;\n\n",
    "js/libs/lavaca.js[398678:405375]": "\n\n  var extend = require('./extend');\n\n  /**\n   * Utility type for asynchronous programming\n   * @class lavaca.util.Promise\n   *\n   * @constructor\n   *\n   * @param {Object} thisp  What the \"this\" keyword resolves to in callbacks\n   */\n  var Promise = extend(function(thisp) {\n    /**\n     * What the \"this\" keyword resolves to in callbacks\n     * @property {Object} thisp\n     * @default null\n     */\n    this.thisp = thisp;\n    /**\n     * Pending handlers for the success event\n     * @property {Array} resolvedQueue\n     * @default []\n     */\n    this.resolvedQueue = [];\n    /**\n     * Pending handlers for the error event\n     * @property {Array} rejectedQueue\n     * @default []\n     */\n    this.rejectedQueue = [];\n  }, {\n    /**\n     * Flag indicating that the promise completed successfully\n     * @property {Boolean} succeeded\n     * @default false\n     */\n    succeeded: false,\n    /**\n     * Flag indicating that the promise failed to complete\n     * @property {Boolean} failed\n     * @default false\n     */\n    failed: false,\n    /**\n     * Queues a callback to be executed when the promise succeeds\n     * @method success\n     *\n     * @param {Function} callback  The callback to execute\n     * @return {Lavaca.util.Promise}  This promise (for chaining)\n     */\n    success: function(callback) {\n      if (callback) {\n        if (this.succeeded) {\n          callback.apply(this.thisp, this.resolveArgs);\n        } else {\n          this.resolvedQueue.push(callback);\n        }\n      }\n      return this;\n    },\n    /**\n     * Queues a callback to be executed when the promise fails\n     * @method error\n     *\n     * @param {Function} callback  The callback to execute\n     * @return {Lavaca.util.Promise}  This promise (for chaining)\n     */\n    error: function(callback) {\n      if (callback) {\n        if (this.failed) {\n          callback.apply(this.thisp, this.rejectArgs);\n        } else {\n          this.rejectedQueue.push(callback);\n        }\n      }\n      return this;\n    },\n    /**\n     * Queues a callback to be executed when the promise is either rejected or resolved\n     * @method always\n     *\n     * @param {Function} callback  The callback to execute\n     * @return {Lavaca.util.Promise}  This promise (for chaining)\n     */\n    always: function(callback) {\n      return this.then(callback, callback);\n    },\n    /**\n     * Queues up callbacks after the promise is completed\n     * @method then\n     *\n     * @param {Function} resolved  A callback to execute when the operation succeeds\n     * @param {Function} rejected  A callback to execute when the operation fails\n     * @return {Lavaca.util.Promise}  This promise (for chaining)\n     */\n    then: function(resolved, rejected) {\n      return this\n        .success(resolved)\n        .error(rejected);\n    },\n    /**\n     * Resolves the promise successfully\n     * @method resolve\n     *\n     * @params {Object} value  Values to pass to the queued success callbacks\n     * @return {Lavaca.util.Promise}  This promise (for chaining)\n     */\n    resolve: function(/* value1, value2, valueN */) {\n      if (!this.succeeded && !this.failed) {\n        this.succeeded = true;\n        this.resolveArgs = [].slice.call(arguments, 0);\n        var i = -1,\n            callback;\n        while (!!(callback = this.resolvedQueue[++i])) {\n          callback.apply(this.thisp, this.resolveArgs);\n        }\n      }\n      return this;\n    },\n    /**\n     * Resolves the promise as a failure\n     * @method reject\n     *\n     * @params {String} err  Failure messages\n     * @return {Lavaca.util.Promise}  This promise (for chaining)\n     */\n    reject: function(/* err1, err2, errN */) {\n      if (!this.succeeded && !this.failed) {\n        this.failed = true;\n        this.rejectArgs = [].slice.call(arguments, 0);\n        var i = -1,\n            callback;\n        while (!!(callback = this.rejectedQueue[++i])) {\n          callback.apply(this.thisp, this.rejectArgs);\n        }\n      }\n      return this;\n    },\n    /**\n     * Queues this promise to be resolved only after several other promises\n     *   have been successfully resolved, or immediately rejected when one\n     *   of those promises is rejected\n     * @method when\n     *\n     * @params {Lavaca.util.Promise}  promise  One or more other promises\n     * @return {Lavaca.util.Promise}  This promise (for chaining)\n     */\n    when: function(/* promise1, promise2, promiseN */) {\n      var self = this,\n          values = [],\n          i = -1,\n          pendingPromiseCount = arguments.length,\n          promise;\n      while (!!(promise = arguments[++i])) {\n        (function(index) {\n          promise\n            .success(function(v) {\n              values[index] = v;\n              if (--pendingPromiseCount < 1) {\n                self.resolve.apply(self, values);\n              }\n            })\n            .error(function() {\n              self.reject.apply(self, arguments);\n            });\n        })(i);\n      }\n      promise = null;\n      return this;\n    },\n    /**\n     * Produces a callback that resolves the promise with any number of arguments\n     * @method resolver\n     * @return {Function}  The callback\n     */\n    resolver: function() {\n      var self = this;\n      return function() {\n        self.resolve.apply(self, arguments);\n      };\n    },\n    /**\n     * Produces a callback that rejects the promise with any number of arguments\n     * @method rejector\n     *\n     * @return {Function}  The callback\n     */\n    rejector: function() {\n      var self = this;\n      return function() {\n        self.reject.apply(self, arguments);\n      };\n    }\n  });\n  /**\n   *\n   * Creates a promise to be resolved only after several other promises\n   *   have been successfully resolved, or immediately rejected when one\n   *   of those promises is rejected\n   * @method when\n   * @static\n   * @params {Lavaca.util.Promise}  promise  One or more other promises\n   * @return {Lavaca.util.Promise}  The new promise\n   */\n   /**\n   * Creates a promise to be resolved only after several other promises\n   *   have been successfully resolved, or immediately rejected when one\n   *   of those promises is rejected\n   * @method when\n   * @static\n   * @param {Object} thisp  The execution context of the promise\n   * @params {Lavaca.util.Promise}  promise  One or more other promises\n   * @return {Lavaca.util.Promise}  The new promise\n   */\n  Promise.when = function(thisp/*, promise1, promise2, promiseN */) {\n    var thispIsPromise = thisp instanceof Promise,\n        promise = new Promise(thispIsPromise ? window : thisp),\n        args = [].slice.call(arguments, thispIsPromise ? 0 : 1);\n    return promise.when.apply(promise, args);\n  };\n\n  return Promise;\n\n",
    "js/libs/lavaca.js[405442:407760]": "\n\n  var _htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&apos;'\n  };\n\n  function _noop(s) {\n    return s;\n  }\n\n  /**\n   * Static utility type for working with strings\n   * @class lavaca.util.StringUtils\n   */\n  var StringUtils = {};\n\n  /**\n   * Substitutes arguments into a string\n   * @method format\n   * @static\n   * @param {String} s  The format string. Substitutions should be in the form {0} to sub in\n   *   the first arg, {1} for the second, and so on\n   * @params {Object} arg  Arguments to be substituted in to the string\n   * @return {String}  The format string with the arguments substituted into it\n   */\n  /**\n   * Substitutes arguments into a string\n   * @method format\n   * @static\n   * @param {String} s  The format string. Substitutions should be in the form {0} to sub in\n   *   the first arg, {1} for the second, and so on\n   * @param {Array} args  Arguments to be substituted in to the string\n   * @return {String}  The format string with the arguments substituted into it\n   */\n  /**\n   * Substitutes arguments into a string\n   * @method format\n   * @static\n   * @param {String} s  The format string. Substitutions should be in the form {0} to sub in\n   *   the first arg, {1} for the second, and so on\n   * @param {Array} args  Arguments to be substituted in to the string\n   * @param {Function} fn  A function to call on each argument, the result of which is substituted into the string\n   * @return {String}  The format string with the arguments substituted into it\n   */\n  StringUtils.format = function(s /*[, arg0, arg1, argN]*/) {\n    var args,\n        fn = _noop,\n        i,\n        j;\n    if (arguments[1] instanceof Array) {\n      args = arguments[1];\n      fn = arguments[2] || _noop;\n    } else {\n      args = [].slice.call(arguments, 1);\n    }\n    for (i = 0, j = args.length; i < j; i++) {\n      s = s.split('{' + i + '}').join(fn(args[i] + ''));\n    }\n    return s;\n  };\n\n  /**\n   * Escapes a string for inclusion in HTML\n   * @method escapeHTML\n   * @static\n   *\n   * @param {String} s  The string\n   * @return {String}  The escaped string\n   */\n  StringUtils.escapeHTML = function(s) {\n    s = '' + s;\n    for (var n in _htmlEscapes) {\n      s = s.split(n).join(_htmlEscapes[n]);\n    }\n    return s;\n  };\n\n  return StringUtils;\n\n",
    "js/libs/lavaca.js[407804:408794]": "\n  /**\n   * Wraps setTimeout and delays the execution of a function\n   * @class lavaca.util.delay\n   */\n   /**\n   * Delays the execution of a function\n   * @method delay\n   * @static\n   *\n   * @param {Function} callback  A callback to execute on delay\n   */\n   /**\n   * Delays the execution of a function\n   * @method delay\n   * @static\n   * @param {Function} callback  A callback to execute on delay\n   * @param {Object} thisp  The object to use as the \"this\" keyword\n   * @return {Number}  The timeout ID\n   */\n   /**\n   * Delays the execution of a function\n   * @method delay\n   * @static\n   * @param {Function} callback  A callback to execute on delay\n   * @param {Object} thisp  The object to use as the \"this\" keyword\n   * @param {Number} ms  The number of milliseconds to delay execution\n   * @return {Number}  The timeout ID\n   */\n  var delay = function(callback, thisp, ms) {\n    return setTimeout(function() {\n      callback.call(thisp);\n    }, ms || 0);\n  };\n\n  return delay;\n\n",
    "js/libs/lavaca.js[408837:409275]": "\n  /**\n   * Logs to the console (or alerts if no console exists)\n   * @class lavaca.util.log\n   */\n   /**\n   * Logs to the console (or alerts if no console exists)\n   * @method log\n   * @static\n   *\n   * @params {Object} arg  The content to be logged\n   */\n  var log = function() {\n    if (window.console) {\n      console.log.apply(console, arguments);\n    } else {\n      alert([].join.call(arguments, ' '));\n    }\n  };\n\n  return log;\n\n",
    "js/libs/lavaca.js[409322:410773]": "\n  /**\n   * Looks up or creates an object, given its global path (ie, 'Lavaca.resolve' resolves to this function,\n   * 'no.obj.exists' resolves to null)\n   * @class lavaca.util.resolve\n   */\n   /**\n   * Looks up or creates an object, given its global path (ie, 'Lavaca.resolve' resolves to this function,\n   * 'no.obj.exists' resolves to null)\n   * @method resolve\n   * @static\n   *\n   * @param {String} name  The fully-qualified name of the object to look up\n   * @return {Object}  The resolved object\n   */\n   /**\n   * Looks up or creates an object, given its global path (ie, 'Lavaca.resolve' resolves to this function,\n   * 'no.obj.exists' resolves to null)\n   * @method resolve\n   * @static\n   *\n   * @param {String} name  The fully-qualified name of the object to look up\n   * @param {Boolean} createIfNotExists  When true, any part of the name that doesn't already exist will be created\n   * as an empty object\n   * @return {Object}  The resolved object\n   */\n  var resolve = function(name, createIfNotExists, root) {\n    if (!name) {\n      return null;\n    }\n    name = name.split('.');\n    var last = root || window,\n        o = root || window,\n        i = -1,\n        segment;\n    while (!!(segment = name[++i])) {\n      o = o[segment];\n      if (!o) {\n        if (createIfNotExists) {\n          o = last[segment] = {};\n        } else {\n          return null;\n        }\n      }\n      last = o;\n    }\n    return o;\n  };\n\n  return resolve;\n\n",
    "js/libs/lavaca.js[410817:411368]": "\n\n  var _uuidMap = {};\n  /**\n   * Produces a app specific unique identifier\n   * @class lavaca.util.uuid\n   */\n   /**\n   * Produces a unique identifier\n   * @method uuid\n   * @static\n   * @param {String} namespace  A string served the namespace of a uuid\n   *\n   * @return {Number}  A number that is unique to this page\n   */\n  var uuid = function(namespace) {\n    namespace = namespace || '__defaultNS';\n    if (typeof _uuidMap[namespace] !== 'number') {\n      _uuidMap[namespace] = 0;\n    }\n    return _uuidMap[namespace]++;\n  };\n\n  return uuid;\n\n"
}