/** (github.com/dynamic-deadfunction-detector)
* Instrumentation log function used by the instrumenter
* note that the data object is already stringified.
*/
var logHistory = [];
function instrumentation_log(data) {
    
                function exists(e) { return e.file == jData.file && e.range[0] == jData.range[0] && e.range[1] == jData.range[1]; }
                var jData = JSON.parse(data);
                if (logHistory.some(exists)){ return; }
                logHistory.push(jData);
    fetch("http://127.0.0.1:8004/alivefunction", {
                method: "POST",
                headers: { "Accept": "application/json", "Content-Type": "application/json" },
                body: data
            }).then((response) => { });
}


/*!
 * Exoskeleton.js 0.7.0
 * (c) 2013 Paul Miller <http://paulmillr.com>
 * Based on Backbone.js
 * (c) 2010-2013 Jeremy Ashkenas, DocumentCloud
 * Exoskeleton may be freely distributed under the MIT license.
 * For all details and documentation: <http://exosjs.com>
 */

(function(root, factory) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[299,893],"range":[275,893],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":1,"label":"exoskeleton"}');
  // Set up Backbone appropriately for the environment.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[481,559],"range":[457,559],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":0,"label":"exoskeleton"}');
      root.Backbone = root.Exoskeleton = factory(root, exports, _, $);
    });
  } else if (typeof exports !== 'undefined') {
    var _, $;
    try { _ = require('underscore'); } catch(e) { }
    try { $ = require('jquery'); } catch(e) { }
    factory(root, exports, _, $);
  } else {
    root.Backbone = root.Exoskeleton = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

})(this, function(root, Backbone, _, $) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[932,64326],"range":[901,64326],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":153,"label":"exoskeleton"}');
  'use strict';

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;
  var previousExoskeleton = root.Exoskeleton;

  // Underscore replacement.
  var utils = Backbone.utils = _ = (_ || {});

  // Hold onto a local reference to `$`. Can be changed at any point.
  Backbone.$ = $;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var toString = ({}).toString;

  // Current version of the library. Keep in sync with `package.json`.
  // Backbone.VERSION = '1.0.0';

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[1831,1935],"range":[1820,1935],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":2,"label":"exoskeleton"}');
    root.Backbone = previousBackbone;
    root.Exoskeleton = previousExoskeleton;
    return this;
  };

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  Backbone.extend = function(protoProps, staticProps) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[2212,3318],"range":[2178,3318],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":5,"label":"exoskeleton"}');
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){instrumentation_log('{"type":"FunctionExpression","bodyRange":[2596,2637],"range":[2586,2637],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":3,"label":"exoskeleton"}'); return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){instrumentation_log('{"type":"FunctionExpression","bodyRange":[2903,2932],"range":[2893,2932],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":4,"label":"exoskeleton"}'); this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[3413,3489],"range":[3402,3489],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":6,"label":"exoskeleton"}');
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[3601,3779],"range":[3576,3779],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":8,"label":"exoskeleton"}');
    var error = options.error;
    options.error = function(resp) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[3669,3774],"range":[3654,3774],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":7,"label":"exoskeleton"}');
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  // Checker for utility methods. Useful for custom builds.
  var utilExists = function(method) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[3878,3927],"range":[3861,3927],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":9,"label":"exoskeleton"}');
    return typeof _[method] === 'function';
  };

  utils.result = function result(object, property) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[3981,4110],"range":[3947,4110],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":10,"label":"exoskeleton"}');
    var value = object ? object[property] : undefined;
    return typeof value === 'function' ? object[property]() : value;
  };

  utils.defaults = function defaults(obj) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[4155,4324],"range":[4132,4324],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":12,"label":"exoskeleton"}');
    slice.call(arguments, 1).forEach(function(item) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[4209,4302],"range":[4194,4302],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":11,"label":"exoskeleton"}');
      for (var key in item) if (obj[key] === undefined)
        obj[key] = item[key];
    });
    return obj;
  };

  utils.extend = function extend(obj) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[4365,4498],"range":[4344,4498],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":14,"label":"exoskeleton"}');
    slice.call(arguments, 1).forEach(function(item) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[4419,4476],"range":[4404,4476],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":13,"label":"exoskeleton"}');
      for (var key in item) obj[key] = item[key];
    });
    return obj;
  };

  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  utils.escape = function escape(string) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[4658,4790],"range":[4634,4790],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":16,"label":"exoskeleton"}');
    return string == null ? '' : String(string).replace(/[&<>"']/g, function(match) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[4744,4784],"range":[4728,4784],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":15,"label":"exoskeleton"}');
      return htmlEscapes[match];
    });
  };

  utils.sortBy = function(obj, value, context) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[4840,5486],"range":[4810,5486],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":21,"label":"exoskeleton"}');
    var iterator = typeof value === 'function' ? value : function(obj){instrumentation_log('{"type":"FunctionExpression","bodyRange":[4912,4934],"range":[4899,4934],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":17,"label":"exoskeleton"}'); return obj[value]; };
    return obj
      .map(function(value, index, list) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[4991,5139],"range":[4962,5139],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":18,"label":"exoskeleton"}');
        return {
          value: value,
          index: index,
          criteria: iterator.call(context, value, index, list)
        };
      })
      .sort(function(left, right) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[5175,5416],"range":[5153,5416],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":19,"label":"exoskeleton"}');
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      })
      .map(function(item) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[5444,5480],"range":[5429,5480],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":20,"label":"exoskeleton"}');
        return item.value;
      });
  };

  /** Used to generate unique IDs */
  var idCounter = 0;

  utils.uniqueId = function uniqueId(prefix) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[5593,5667],"range":[5567,5667],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":22,"label":"exoskeleton"}');
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  utils.has = function(obj, key) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[5703,5757],"range":[5684,5757],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":23,"label":"exoskeleton"}');
    return Object.hasOwnProperty.call(obj, key);
  };

  var eq = function(a, b, aStack, bStack) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[5802,9551],"range":[5771,9551],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":24,"label":"exoskeleton"}');
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    //if (a instanceof _) a = a._wrapped;
    //if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a !== +a ? b !== +b : (a === 0 ? 1 / a === 1 / b : a === +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(typeof aCtor === 'function' && (aCtor instanceof aCtor) &&
                             typeof bCtor === 'function' && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className === '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size === b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  utils.isEqual = function(a, b) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[9653,9687],"range":[9638,9687],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":25,"label":"exoskeleton"}');
    return eq(a, b, [], []);
  };

// Backbone.Events
// ---------------

// A module that can be mixed in to *any object* in order to provide it with
// custom events. You may bind with `on` or remove with `off` callback
// functions to an event; `trigger`-ing an event fires all callbacks in
// succession.
//
//     var object = {};
//     _.extend(object, Backbone.Events);
//     object.on('expand', function(){ alert('expanded'); });
//     object.trigger('expand');
//
var Events = Backbone.Events = {

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  on: function(name, callback, context) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[10315,10608],"range":[10281,10608],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":26,"label":"exoskeleton"}');
    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
    this._events || (this._events = {});
    var events = this._events[name] || (this._events[name] = []);
    events.push({callback: callback, context: context, ctx: context || this});
    return this;
  },

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, it will be removed.
  once: function(name, callback, context) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[10779,11120],"range":[10745,11120],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":28,"label":"exoskeleton"}');
    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
    var self = this;
    var ran;
    var once = function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[10928,11043],"range":[10917,11043],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":27,"label":"exoskeleton"}');
      if (ran) return;
      ran = true;
      self.off(name, once);
      callback.apply(this, arguments);
    };
    once._callback = callback;
    return this.on(name, once, context);
  },

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  off: function(name, callback, context) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[11401,12271],"range":[11367,12271],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":29,"label":"exoskeleton"}');
    var retain, ev, events, names, i, l, j, k;
    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
    if (!name && !callback && !context) {
      this._events = void 0;
      return this;
    }
    names = name ? [name] : Object.keys(this._events);
    for (i = 0, l = names.length; i < l; i++) {
      name = names[i];
      if (events = this._events[name]) {
        this._events[name] = retain = [];
        if (callback || context) {
          for (j = 0, k = events.length; j < k; j++) {
            ev = events[j];
            if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                (context && context !== ev.context)) {
              retain.push(ev);
            }
          }
        }
        if (!retain.length) delete this._events[name];
      }
    }

    return this;
  },

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  trigger: function(name) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[12589,12926],"range":[12574,12926],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":30,"label":"exoskeleton"}');
    if (!this._events) return this;
    var args = slice.call(arguments, 1);
    if (!eventsApi(this, 'trigger', name, args)) return this;
    var events = this._events[name];
    var allEvents = this._events.all;
    if (events) triggerEvents(events, args);
    if (allEvents) triggerEvents(allEvents, arguments);
    return this;
  },

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  stopListening: function(obj, name, callback) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[13099,13542],"range":[13069,13542],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":31,"label":"exoskeleton"}');
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;
    var remove = !name && !callback;
    if (!callback && typeof name === 'object') callback = this;
    if (obj) (listeningTo = {})[obj._listenId] = obj;
    for (var id in listeningTo) {
      obj = listeningTo[id];
      obj.off(name, callback, this);
      if (remove || !Object.keys(obj._events).length) delete this._listeningTo[id];
    }
    return this;
  }

};

// Regular expression used to split event strings.
var eventSplitter = /\s+/;

// Implement fancy features of the Events API such as multiple event
// names `"change blur"` and jQuery-style event maps `{change: action}`
// in terms of the existing API.
var eventsApi = function(obj, action, name, rest) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[13851,14326],"range":[13817,14326],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":32,"label":"exoskeleton"}');
  if (!name) return true;

  // Handle event maps.
  if (typeof name === 'object') {
    for (var key in name) {
      obj[action].apply(obj, [key, name[key]].concat(rest));
    }
    return false;
  }

  // Handle space separated event names.
  if (eventSplitter.test(name)) {
    var names = name.split(eventSplitter);
    for (var i = 0, l = names.length; i < l; i++) {
      obj[action].apply(obj, [names[i]].concat(rest));
    }
    return false;
  }

  return true;
};

// A difficult-to-believe, but optimized internal dispatch function for
// triggering events. Tries to keep the usual cases speedy (most internal
// Backbone events have 3 arguments).
var triggerEvents = function(events, args) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[14556,15079],"range":[14533,15079],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":33,"label":"exoskeleton"}');
  var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
  switch (args.length) {
    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
  }
};

var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

// Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it's
// listening to.
Object.keys(listenMethods).forEach(function(method) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[15358,15752],"range":[15341,15752],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":35,"label":"exoskeleton"}');
  var implementation = listenMethods[method];
  Events[method] = function(obj, name, callback) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[15455,15749],"range":[15425,15749],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":34,"label":"exoskeleton"}');
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
    listeningTo[id] = obj;
    if (!callback && typeof name === 'object') callback = this;
    obj[implementation](name, callback, this);
    return this;
  };
});

// Aliases for backwards compatibility.
Events.bind   = Events.on;
Events.unbind = Events.off;

// Allow the `Backbone` object to serve as a global event bus, for folks who
// want global "pubsub" in a convenient place.
_.extend(Backbone, Events);

// Backbone.Model
// --------------

// Backbone **Models** are the basic data object in the framework --
// frequently representing a row in a table in a database on your server.
// A discrete chunk of data and a bunch of useful, related methods for
// performing computations and transformations on that data.

// Create a new model with the specified attributes. A client id (`cid`)
// is automatically generated and assigned for you.
var Model = Backbone.Model = function(attributes, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[16502,16933],"range":[16472,16933],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":36,"label":"exoskeleton"}');
  var attrs = attributes || {};
  options || (options = {});
  this.cid = _.uniqueId('c');
  this.attributes = Object.create(null);
  if (options.collection) this.collection = options.collection;
  if (options.parse) attrs = this.parse(attrs, options) || {};
  attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
  this.set(attrs, options);
  this.changed = Object.create(null);
  this.initialize.apply(this, arguments);
};

// Attach all inheritable methods to the Model prototype.
_.extend(Model.prototype, Events, {

  // A hash of attributes whose current and previous value differ.
  changed: null,

  // The value returned during the last failed validation.
  validationError: null,

  // The default name for the JSON `id` attribute is `"id"`. MongoDB and
  // CouchDB users may want to set this to `"_id"`.
  idAttribute: 'id',

  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function(){instrumentation_log('{"type":"FunctionExpression","bodyRange":[17474,17476],"range":[17464,17476],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":37,"label":"exoskeleton"}');},

  // Return a copy of the model's `attributes` object.
  toJSON: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[17562,17609],"range":[17544,17609],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":38,"label":"exoskeleton"}');
    return _.extend({}, this.attributes);
  },

  // Proxy `Backbone.sync` by default -- but override this if you need
  // custom syncing semantics for *this* particular model.
  sync: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[17761,17815],"range":[17750,17815],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":39,"label":"exoskeleton"}');
    return Backbone.sync.apply(this, arguments);
  },

  // Get the value of an attribute.
  get: function(attr) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[17876,17915],"range":[17861,17915],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":40,"label":"exoskeleton"}');
    return this.attributes[attr];
  },

  // Get the HTML-escaped value of an attribute.
  escape: function(attr) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[17992,18034],"range":[17977,18034],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":41,"label":"exoskeleton"}');
    return _.escape(this.get(attr));
  },

  // Returns `true` if the attribute contains a value that is not null
  // or undefined.
  has: function(attr) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[18149,18189],"range":[18134,18189],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":42,"label":"exoskeleton"}');
    return this.get(attr) != null;
  },

  // Set a hash of model attributes on the object, firing `"change"`. This is
  // the core primitive operation of a model, updating the data and notifying
  // anyone who needs to know about the change in state. The heart of the beast.
  set: function(key, val, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[18464,20449],"range":[18436,20449],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":43,"label":"exoskeleton"}');
    var attr, attrs, unset, changes, silent, changing, prev, current;
    if (key == null) return this;

    // Handle both `"key", value` and `{key: value}` -style arguments.
    if (typeof key === 'object') {
      attrs = key;
      options = val;
    } else {
      (attrs = {})[key] = val;
    }

    options || (options = {});

    // Run validation.
    if (!this._validate(attrs, options)) return false;

    // Extract attributes and options.
    unset           = options.unset;
    silent          = options.silent;
    changes         = [];
    changing        = this._changing;
    this._changing  = true;

    if (!changing) {
      this._previousAttributes = _.extend(Object.create(null), this.attributes);
      this.changed = {};
    }
    current = this.attributes, prev = this._previousAttributes;

    // Check for changes of `id`.
    if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

    // For each `set` attribute, update or delete the current value.
    for (attr in attrs) {
      val = attrs[attr];
      if (!_.isEqual(current[attr], val)) changes.push(attr);
      if (!_.isEqual(prev[attr], val)) {
        this.changed[attr] = val;
      } else {
        delete this.changed[attr];
      }
      unset ? delete current[attr] : current[attr] = val;
    }

    // Trigger all relevant attribute changes.
    if (!silent) {
      if (changes.length) this._pending = options;
      for (var i = 0, l = changes.length; i < l; i++) {
        this.trigger('change:' + changes[i], this, current[changes[i]], options);
      }
    }

    // You might be wondering why there's a `while` loop here. Changes can
    // be recursively nested within `"change"` events.
    if (changing) return this;
    if (!silent) {
      while (this._pending) {
        options = this._pending;
        this._pending = false;
        this.trigger('change', this, options);
      }
    }
    this._pending = false;
    this._changing = false;
    return this;
  },

  // Remove an attribute from the model, firing `"change"`. `unset` is a noop
  // if the attribute doesn't exist.
  unset: function(attr, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[20600,20678],"range":[20576,20678],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":44,"label":"exoskeleton"}');
    return this.set(attr, void 0, _.extend({}, options, {unset: true}));
  },

  // Clear all attributes on the model, firing `"change"`.
  clear: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[20767,20916],"range":[20749,20916],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":45,"label":"exoskeleton"}');
    var attrs = {};
    for (var key in this.attributes) attrs[key] = void 0;
    return this.set(attrs, _.extend({}, options, {unset: true}));
  },

  // Determine if the model has changed since the last `"change"` event.
  // If you specify an attribute name, determine if that attribute has changed.
  hasChanged: function(attr) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[21101,21209],"range":[21086,21209],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":46,"label":"exoskeleton"}');
    if (attr == null) return !!Object.keys(this.changed).length;
    return _.has(this.changed, attr);
  },

  // Return an object containing all the attributes that have changed, or
  // false if there are no changed attributes. Useful for determining what
  // parts of a view need to be updated and/or what attributes need to be
  // persisted to the server. Unset attributes will be set to undefined.
  // You can also pass an attributes object to diff against the model,
  // determining if there *would be* a change.
  changedAttributes: function(diff) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[21662,22031],"range":[21647,22031],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":47,"label":"exoskeleton"}');
    if (!diff) return this.hasChanged() ? _.extend(Object.create(null), this.changed) : false;
    var val, changed = false;
    var old = this._changing ? this._previousAttributes : this.attributes;
    for (var attr in diff) {
      if (_.isEqual(old[attr], (val = diff[attr]))) continue;
      (changed || (changed = {}))[attr] = val;
    }
    return changed;
  },

  // Get the previous value of an attribute, recorded at the time the last
  // `"change"` event was fired.
  previous: function(attr) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[22169,22281],"range":[22154,22281],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":48,"label":"exoskeleton"}');
    if (attr == null || !this._previousAttributes) return null;
    return this._previousAttributes[attr];
  },

  // Get all of the attributes of the model at the time of the previous
  // `"change"` event.
  previousAttributes: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[22412,22485],"range":[22401,22485],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":49,"label":"exoskeleton"}');
    return _.extend(Object.create(null), this._previousAttributes);
  },

  // Fetch the model from the server. If the server's representation of the
  // model differs from its current attributes, they will be overridden,
  // triggering a `"change"` event.
  fetch: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[22700,23165],"range":[22682,23165],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":51,"label":"exoskeleton"}');
    options = options ? _.extend({}, options) : {};
    if (options.parse === void 0) options.parse = true;
    var model = this;
    var success = options.success;
    options.success = function(resp) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[22904,23085],"range":[22889,23085],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":50,"label":"exoskeleton"}');
      if (!model.set(model.parse(resp, options), options)) return false;
      if (success) success(model, resp, options);
      model.trigger('sync', model, resp, options);
    };
    wrapError(this, options);
    return this.sync('read', this, options);
  },

  // Set a hash of model attributes, and sync the model to the server.
  // If the server returns an attributes hash that differs, the model's
  // state will be `set` again.
  save: function(key, val, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[23379,25277],"range":[23351,25277],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":53,"label":"exoskeleton"}');
    var attrs, method, xhr, attributes = this.attributes;

    // Handle both `"key", value` and `{key: value}` -style arguments.
    if (key == null || typeof key === 'object') {
      attrs = key;
      options = val;
    } else {
      (attrs = {})[key] = val;
    }

    options = _.extend({validate: true}, options);

    // If we're not waiting and attributes exist, save acts as
    // `set(attr).save(null, opts)` with validation. Otherwise, check if
    // the model will be valid when the attributes, if any, are set.
    if (attrs && !options.wait) {
      if (!this.set(attrs, options)) return false;
    } else {
      if (!this._validate(attrs, options)) return false;
    }

    // Set temporary attributes if `{wait: true}`.
    if (attrs && options.wait) {
      this.attributes = _.extend(Object.create(null), attributes, attrs);
    }

    // After a successful server-side save, the client is (optionally)
    // updated with the server-side state.
    if (options.parse === void 0) options.parse = true;
    var model = this;
    var success = options.success;
    options.success = function(resp) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[24500,24963],"range":[24485,24963],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":52,"label":"exoskeleton"}');
      // Ensure attributes are restored during synchronous saves.
      model.attributes = attributes;
      var serverAttrs = model.parse(resp, options);
      if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
      if (serverAttrs && typeof serverAttrs === 'object' && !model.set(serverAttrs, options)) {
        return false;
      }
      if (success) success(model, resp, options);
      model.trigger('sync', model, resp, options);
    };
    wrapError(this, options);

    method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
    if (method === 'patch') options.attrs = attrs;
    xhr = this.sync(method, this, options);

    // Restore attributes.
    if (attrs && options.wait) this.attributes = attributes;

    return xhr;
  },

  // Destroy this model on the server if it was already persisted.
  // Optimistically removes the model from its collection, if it has one.
  // If `wait: true` is passed, waits for the server to respond before removal.
  destroy: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[25530,26176],"range":[25512,26176],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":56,"label":"exoskeleton"}');
    options = options ? _.extend({}, options) : {};
    var model = this;
    var success = options.success;

    var destroy = function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[25671,25744],"range":[25660,25744],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":54,"label":"exoskeleton"}');
      model.trigger('destroy', model, model.collection, options);
    };

    options.success = function(resp) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[25784,25964],"range":[25769,25964],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":55,"label":"exoskeleton"}');
      if (options.wait || model.isNew()) destroy();
      if (success) success(model, resp, options);
      if (!model.isNew()) model.trigger('sync', model, resp, options);
    };

    if (this.isNew()) {
      options.success();
      return false;
    }
    wrapError(this, options);

    var xhr = this.sync('delete', this, options);
    if (!options.wait) destroy();
    return xhr;
  },

  // Default URL for the model's representation on the server -- if you're
  // using Backbone's restful methods, override this to change the endpoint
  // that will be called.
  url: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[26374,26598],"range":[26363,26598],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":57,"label":"exoskeleton"}');
    var base =
      _.result(this, 'urlRoot') ||
      _.result(this.collection, 'url') ||
      urlError();
    if (this.isNew()) return base;
    return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
  },

  // **parse** converts a response into the hash of attributes to be `set` on
  // the model. The default implementation is just to pass the response along.
  parse: function(resp, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[26791,26813],"range":[26767,26813],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":58,"label":"exoskeleton"}');
    return resp;
  },

  // Create a new model with identical attributes to this one.
  clone: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[26899,26954],"range":[26888,26954],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":59,"label":"exoskeleton"}');
    return new this.constructor(this.attributes);
  },

  // A model is new if it has never been saved to the server, and lacks an id.
  isNew: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[27056,27101],"range":[27045,27101],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":60,"label":"exoskeleton"}');
    return !this.has(this.idAttribute);
  },

  // Check if the model is currently in a valid state.
  isValid: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[27188,27269],"range":[27170,27269],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":61,"label":"exoskeleton"}');
    return this._validate({}, _.extend(options || {}, { validate: true }));
  },

  // Run validation against the next complete set of model attributes,
  // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
  _validate: function(attrs, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[27457,27799],"range":[27432,27799],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":62,"label":"exoskeleton"}');
    if (!options.validate || !this.validate) return true;
    attrs = _.extend(Object.create(null), this.attributes, attrs);
    var error = this.validationError = this.validate(attrs, options) || null;
    if (!error) return true;
    this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
    return false;
  }

});

if (_.keys) {
  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  modelMethods.filter(utilExists).forEach(function(method) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[28089,28260],"range":[28072,28260],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":64,"label":"exoskeleton"}');
    Model.prototype[method] = function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[28132,28255],"range":[28121,28255],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":63,"label":"exoskeleton"}');
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });
}

// Backbone.Collection
// -------------------

// If models tend to represent a single row of data, a Backbone Collection is
// more analagous to a table full of data ... or a small slice or page of that
// table, or a collection of rows that belong together for a particular reason
// -- all of the messages in this particular folder, all of the documents
// belonging to this particular author, and so on. Collections maintain
// indexes of their models, both in order, and for lookup by `id`.

// Create a new **Collection**, perhaps to contain a specific type of `model`.
// If a `comparator` is specified, the Collection will maintain
// its models in sort order, as they're added and removed.
var Collection = Backbone.Collection = function(models, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[29030,29314],"range":[29004,29314],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":65,"label":"exoskeleton"}');
  options || (options = {});
  if (options.model) this.model = options.model;
  if (options.comparator !== void 0) this.comparator = options.comparator;
  this._reset();
  this.initialize.apply(this, arguments);
  if (models) this.reset(models, _.extend({silent: true}, options));
};

// Default options for `Collection#set`.
var setOptions = {add: true, remove: true, merge: true};
var addOptions = {add: true, remove: false};

// Define the Collection's inheritable methods.
_.extend(Collection.prototype, Events, {

  // The default model for a collection is just a **Backbone.Model**.
  // This should be overridden in most cases.
  model: typeof Model === 'undefined' ? null : Model,

  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function(){instrumentation_log('{"type":"FunctionExpression","bodyRange":[29848,29850],"range":[29838,29850],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":66,"label":"exoskeleton"}');},

  // The JSON representation of a Collection is an array of the
  // models' attributes.
  toJSON: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[29970,30046],"range":[29952,30046],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":68,"label":"exoskeleton"}');
    return this.map(function(model){instrumentation_log('{"type":"FunctionExpression","bodyRange":[30007,30040],"range":[29992,30040],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":67,"label":"exoskeleton"}'); return model.toJSON(options); });
  },

  // Proxy `Backbone.sync` by default.
  sync: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[30107,30161],"range":[30096,30161],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":69,"label":"exoskeleton"}');
    return Backbone.sync.apply(this, arguments);
  },

  // Add a model, or list of models to the set.
  add: function(models, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[30245,30326],"range":[30219,30326],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":70,"label":"exoskeleton"}');
    return this.set(models, _.extend({merge: false}, options, addOptions));
  },

  // Remove a model, or a list of models from the set.
  remove: function(models, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[30420,31081],"range":[30394,31081],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":71,"label":"exoskeleton"}');
    var singular = !Array.isArray(models);
    models = singular ? [models] : models.slice();
    options || (options = {});
    var i, l, index, model;
    for (i = 0, l = models.length; i < l; i++) {
      model = models[i] = this.get(models[i]);
      if (!model) continue;
      delete this._byId[model.id];
      delete this._byId[model.cid];
      index = this.indexOf(model);
      this.models.splice(index, 1);
      this.length--;
      if (!options.silent) {
        options.index = index;
        model.trigger('remove', model, this, options);
      }
      this._removeReference(model, options);
    }
    return singular ? models[0] : models;
  },

  // Update a collection by `set`-ing a new list of models, adding new ones,
  // removing models that are no longer present, and merging models that
  // already exist in the collection, as necessary. Similar to **Model#set**,
  // the core operation for updating the data contained by the collection.
  set: function(models, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[31420,34753],"range":[31394,34753],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":72,"label":"exoskeleton"}');
    options = _.defaults({}, options, setOptions);
    if (options.parse) models = this.parse(models, options);
    var singular = !Array.isArray(models);
    models = singular ? (models ? [models] : []) : models.slice();
    var i, l, id, model, attrs, existing, sort;
    var at = options.at;
    var targetModel = this.model;
    var sortable = this.comparator && (at == null) && options.sort !== false;
    var sortAttr = typeof this.comparator === 'string' ? this.comparator : null;
    var toAdd = [], toRemove = [], modelMap = {};
    var add = options.add, merge = options.merge, remove = options.remove;
    var order = !sortable && add && remove ? [] : false;

    // Turn bare objects into model references, and prevent invalid models
    // from being added.
    for (i = 0, l = models.length; i < l; i++) {
      attrs = models[i] || {};
      if (attrs instanceof Model) {
        id = model = attrs;
      } else {
        id = attrs[targetModel.prototype.idAttribute || 'id'];
      }

      // If a duplicate is found, prevent it from being added and
      // optionally merge it into the existing model.
      if (existing = this.get(id)) {
        if (remove) modelMap[existing.cid] = true;
        if (merge) {
          attrs = attrs === model ? model.attributes : attrs;
          if (options.parse) attrs = existing.parse(attrs, options);
          existing.set(attrs, options);
          if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
        }
        models[i] = existing;

      // If this is a new, valid model, push it to the `toAdd` list.
      } else if (add) {
        model = models[i] = this._prepareModel(attrs, options);
        if (!model) continue;
        toAdd.push(model);
        this._addReference(model, options);
      }

      // Do not add multiple models with the same `id`.
      model = existing || model;
      if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
      modelMap[model.id] = true;
    }

    // Remove nonexistent models if appropriate.
    if (remove) {
      for (i = 0, l = this.length; i < l; ++i) {
        if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
      }
      if (toRemove.length) this.remove(toRemove, options);
    }

    // See if sorting is needed, update `length` and splice in new models.
    if (toAdd.length || (order && order.length)) {
      if (sortable) sort = true;
      this.length += toAdd.length;
      if (at != null) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          this.models.splice(at + i, 0, toAdd[i]);
        }
      } else {
        if (order) this.models.length = 0;
        var orderedModels = order || toAdd;
        for (i = 0, l = orderedModels.length; i < l; i++) {
          this.models.push(orderedModels[i]);
        }
      }
    }

    // Silently sort the collection if appropriate.
    if (sort) this.sort({silent: true});

    // Unless silenced, it's time to fire all appropriate add/sort events.
    if (!options.silent) {
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }
      if (sort || (order && order.length)) this.trigger('sort', this, options);
    }

    // Return the added (or merged) model (or models).
    return singular ? models[0] : models;
  },

  // When you have more items than you want to add or remove individually,
  // you can reset the entire set with a new list of models, without firing
  // any granular `add` or `remove` events. Fires `reset` when finished.
  // Useful for bulk operations and optimizations.
  reset: function(models, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[35066,35429],"range":[35040,35429],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":73,"label":"exoskeleton"}');
    options || (options = {});
    for (var i = 0, l = this.models.length; i < l; i++) {
      this._removeReference(this.models[i], options);
    }
    options.previousModels = this.models;
    this._reset();
    models = this.add(models, _.extend({silent: true}, options));
    if (!options.silent) this.trigger('reset', this, options);
    return models;
  },

  // Add a model to the end of the collection.
  push: function(model, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[35512,35583],"range":[35487,35583],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":74,"label":"exoskeleton"}');
    return this.add(model, _.extend({at: this.length}, options));
  },

  // Remove a model from the end of the collection.
  pop: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[35663,35761],"range":[35645,35761],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":75,"label":"exoskeleton"}');
    var model = this.at(this.length - 1);
    this.remove(model, options);
    return model;
  },

  // Add a model to the beginning of the collection.
  unshift: function(model, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[35853,35914],"range":[35828,35914],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":76,"label":"exoskeleton"}');
    return this.add(model, _.extend({at: 0}, options));
  },

  // Remove a model from the beginning of the collection.
  shift: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[36002,36086],"range":[35984,36086],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":77,"label":"exoskeleton"}');
    var model = this.at(0);
    this.remove(model, options);
    return model;
  },

  // Slice out a sub-array of models from the collection.
  slice: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[36167,36220],"range":[36156,36220],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":78,"label":"exoskeleton"}');
    return slice.apply(this.models, arguments);
  },

  // Get a model from the set by id.
  get: function(obj) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[36281,36395],"range":[36267,36395],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":79,"label":"exoskeleton"}');
    if (obj == null) return void 0;
    return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
  },

  // Get the model at the given index.
  at: function(index) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[36459,36495],"range":[36443,36495],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":80,"label":"exoskeleton"}');
    return this.models[index];
  },

  // Return models with matching attributes. Useful for simple cases of
  // `filter`.
  where: function(attrs, first) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[36617,36880],"range":[36594,36880],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":82,"label":"exoskeleton"}');
    if (!attrs || !Object.keys(attrs).length) return first ? void 0 : [];
    return this[first ? 'find' : 'filter'](function(model) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[36752,36874],"range":[36736,36874],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":81,"label":"exoskeleton"}');
      for (var key in attrs) {
        if (attrs[key] !== model.get(key)) return false;
      }
      return true;
    });
  },

  // Return the first model with matching attributes. Useful for simple cases
  // of `find`.
  findWhere: function(attrs) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[37006,37047],"range":[36990,37047],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":83,"label":"exoskeleton"}');
    return this.where(attrs, true);
  },

  // Force the collection to re-sort itself. You don't need to call this under
  // normal circumstances, as the set will maintain sort order as each item
  // is added.
  sort: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[37246,37701],"range":[37228,37701],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":84,"label":"exoskeleton"}');
    if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
    options || (options = {});

    // Run sort based on type of `comparator`.
    if (typeof this.comparator === 'string' || this.comparator.length === 1) {
      this.models = this.sortBy(this.comparator, this);
    } else {
      this.models.sort(this.comparator.bind(this));
    }

    if (!options.silent) this.trigger('sort', this, options);
    return this;
  },

  // Pluck an attribute from each model in the collection.
  pluck: function(attr) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[37787,37875],"range":[37772,37875],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":86,"label":"exoskeleton"}');
    return this.models.map(function(model) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[37832,37869],"range":[37816,37869],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":85,"label":"exoskeleton"}');
      return model.get(attr);
    });
  },

  // Fetch the default set of models for this collection, resetting the
  // collection when they arrive. If `reset: true` is passed, the response
  // data will be passed through the `reset` method instead of `set`.
  fetch: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[38122,38627],"range":[38104,38627],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":88,"label":"exoskeleton"}');
    options = options ? _.extend({}, options) : {};
    if (options.parse === void 0) options.parse = true;
    var success = options.success;
    var collection = this;
    options.success = function(resp) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[38331,38547],"range":[38316,38547],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":87,"label":"exoskeleton"}');
      var method = options.reset ? 'reset' : 'set';
      collection[method](resp, options);
      if (success) success(collection, resp, options);
      collection.trigger('sync', collection, resp, options);
    };
    wrapError(this, options);
    return this.sync('read', this, options);
  },

  // Create a new instance of a model in this collection. Add the model to the
  // collection immediately, unless `wait: true` is passed, in which case we
  // wait for the server to agree.
  create: function(model, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[38856,39301],"range":[38831,39301],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":90,"label":"exoskeleton"}');
    options = options ? _.extend({}, options) : {};
    if (!(model = this._prepareModel(model, options))) return false;
    if (!options.wait) this.add(model, options);
    var collection = this;
    var success = options.success;
    options.success = function(model, resp) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[39134,39247],"range":[39112,39247],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":89,"label":"exoskeleton"}');
      if (options.wait) collection.add(model, options);
      if (success) success(model, resp, options);
    };
    model.save(null, options);
    return model;
  },

  // **parse** converts a response into a list of models to be added to the
  // collection. The default implementation is just to pass it through.
  parse: function(resp, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[39485,39507],"range":[39461,39507],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":91,"label":"exoskeleton"}');
    return resp;
  },

  // Create a new collection with an identical list of models as this one.
  clone: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[39605,39656],"range":[39594,39656],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":92,"label":"exoskeleton"}');
    return new this.constructor(this.models);
  },

  // Private method to reset all internal state. Called when the collection
  // is first initialized or reset.
  _reset: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[39792,39879],"range":[39781,39879],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":93,"label":"exoskeleton"}');
    this.length = 0;
    this.models = [];
    this._byId  = Object.create(null);
  },

  // Prepare a hash of attributes (or other model) to be added to this
  // collection.
  _prepareModel: function(attrs, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[40012,40310],"range":[39987,40310],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":94,"label":"exoskeleton"}');
    if (attrs instanceof Model) return attrs;
    options = _.extend({}, options);
    options.collection = this;
    var model = new this.model(attrs, options);
    if (!model.validationError) return model;
    this.trigger('invalid', this, model.validationError, options);
    return false;
  },

  // Internal method to create a model's ties to a collection.
  _addReference: function(model, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[40418,40613],"range":[40393,40613],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":95,"label":"exoskeleton"}');
    this._byId[model.cid] = model;
    if (model.id != null) this._byId[model.id] = model;
    if (!model.collection) model.collection = this;
    model.on('all', this._onModelEvent, this);
  },

  // Internal method to sever a model's ties to a collection.
  _removeReference: function(model, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[40723,40836],"range":[40698,40836],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":96,"label":"exoskeleton"}');
    if (this === model.collection) delete model.collection;
    model.off('all', this._onModelEvent, this);
  },

  // Internal method called every time a model in the set fires an event.
  // Sets need to update their indexes when models change ids. All other
  // events simply proxy through. "add" and "remove" events that originate
  // in other collections are ignored.
  _onModelEvent: function(event, model, collection, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[41161,41529],"range":[41117,41529],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":97,"label":"exoskeleton"}');
    if ((event === 'add' || event === 'remove') && collection !== this) return;
    if (event === 'destroy') this.remove(model, options);
    if (model && event === 'change:' + model.idAttribute) {
      delete this._byId[model.previous(model.idAttribute)];
      if (model.id != null) this._byId[model.id] = model;
    }
    this.trigger.apply(this, arguments);
  }

});

if (utilExists('each')) {
  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  methods.filter(utilExists).forEach(function(method) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[42276,42448],"range":[42259,42448],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":99,"label":"exoskeleton"}');
    Collection.prototype[method] = function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[42324,42443],"range":[42313,42443],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":98,"label":"exoskeleton"}');
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

  // Use attributes instead of properties.
  attributeMethods.filter(utilExists).forEach(function(method) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[42684,42933],"range":[42667,42933],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":102,"label":"exoskeleton"}');
    Collection.prototype[method] = function(value, context) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[42746,42928],"range":[42721,42928],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":101,"label":"exoskeleton"}');
      var iterator = typeof value === 'function' ? value : function(model) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[42823,42865],"range":[42807,42865],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":100,"label":"exoskeleton"}');
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });
} else {
  ['forEach', 'map', 'filter', 'some', 'every', 'reduce', 'reduceRight',
    'indexOf', 'lastIndexOf'].forEach(function(method) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[43073,43193],"range":[43056,43193],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":104,"label":"exoskeleton"}');
    Collection.prototype[method] = function(arg, context) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[43133,43188],"range":[43110,43188],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":103,"label":"exoskeleton"}');
      return this.models[method](arg, context);
    };
  });

  // Exoskeleton-specific:
  Collection.prototype.find = function(iterator, context) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[43282,43484],"range":[43254,43484],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":106,"label":"exoskeleton"}');
    var result;
    this.some(function(value, index, list) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[43343,43459],"range":[43314,43459],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":105,"label":"exoskeleton"}');
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Underscore methods that take a property name as an argument.
  ['sortBy'].forEach(function(method) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[43591,43840],"range":[43574,43840],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":109,"label":"exoskeleton"}');
    Collection.prototype[method] = function(value, context) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[43653,43835],"range":[43628,43835],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":108,"label":"exoskeleton"}');
      var iterator = typeof value === 'function' ? value : function(model) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[43730,43772],"range":[43714,43772],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":107,"label":"exoskeleton"}');
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });
}

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[44597,44855],"range":[44579,44855],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":111,"label":"exoskeleton"}');
    this.cid = _.uniqueId('view');

    if (options) Object.keys(options).forEach(function(key) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[44695,44771],"range":[44681,44771],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":110,"label":"exoskeleton"}');
      if (viewOptions.indexOf(key) !== -1) this[key] = options[key];
    }, this);

    this._ensureElement();
    this.initialize.apply(this, arguments);
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[45488,45533],"range":[45469,45533],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":112,"label":"exoskeleton"}');
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){instrumentation_log('{"type":"FunctionExpression","bodyRange":[45668,45670],"range":[45658,45670],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":113,"label":"exoskeleton"}');},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[45912,45938],"range":[45901,45938],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":114,"label":"exoskeleton"}');
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[46088,46171],"range":[46077,46171],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":115,"label":"exoskeleton"}');
      this._removeElement();
      this.stopListening();
      return this;
    },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[46377,46409],"range":[46366,46409],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":116,"label":"exoskeleton"}');
      this.$el.remove();
    },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function(element) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[46561,46680],"range":[46543,46680],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":117,"label":"exoskeleton"}');
      this.undelegateEvents();
      this._setElement(element);
      this.delegateEvents();
      return this;
    },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el` and a hash of `attributes`. `el` can be a CSS selector or an
    // HTML string, a jQuery context or an element. Subclasses can override
    // this to utilize an alternative DOM manipulation API and are only required
    // to set the `this.el` property.
    _setElement: function(el) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[47066,47314],"range":[47053,47314],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":118,"label":"exoskeleton"}');
      if (!Backbone.$) throw new Error('You must either include jQuery or override Backbone.View.prototype methods (Google Backbone.NativeView)');
      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
      this.el = this.$el[0];
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function(events) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[47815,48239],"range":[47798,48239],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":119,"label":"exoskeleton"}');
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (typeof method !== 'function') method = this[events[key]];
        // if (!method) continue;
        var match = key.match(delegateEventSplitter);
        this.delegate(match[1], match[2], method.bind(this));
      }
      return this;
    },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function(eventName, selector, listener) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[48531,48619],"range":[48491,48619],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":120,"label":"exoskeleton"}');
      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
    },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[48869,48959],"range":[48858,48959],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":121,"label":"exoskeleton"}');
      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function(eventName, selector, listener) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[49151,49240],"range":[49111,49240],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":122,"label":"exoskeleton"}');
      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
    },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function(tagName) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[49413,49466],"range":[49395,49466],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":123,"label":"exoskeleton"}');
      return document.createElement(tagName);
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[49773,50173],"range":[49762,50173],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":124,"label":"exoskeleton"}');
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        this.setElement(this._createElement(_.result(this, 'tagName')));
        this._setAttributes(attrs);
      } else {
        this.setElement(_.result(this, 'el'));
      }
    },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function(attributes) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[50349,50389],"range":[50328,50389],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":125,"label":"exoskeleton"}');
      this.$el.attr(attributes);
    }
  });
  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  Backbone.sync = function(method, model, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[50954,51864],"range":[50921,51864],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":126,"label":"exoskeleton"}');
    options || (options = {})

    var type = methodMap[method];

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET') {
      params.processData = false;
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[52248,52437],"range":[52237,52437],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":127,"label":"exoskeleton"}');
    if (!Backbone.$) throw new Error('You must either include jQuery or override Backbone.ajax (Google Backbone.NativeAjax)');
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[52685,52843],"range":[52667,52843],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":128,"label":"exoskeleton"}');
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  var isRegExp = function(value) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[53141,53248],"range":[53125,53248],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":129,"label":"exoskeleton"}');
    return value ? (typeof value === 'object' && toString.call(value) === '[object RegExp]') : false;
  };

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){instrumentation_log('{"type":"FunctionExpression","bodyRange":[53495,53497],"range":[53485,53497],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":130,"label":"exoskeleton"}');},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[53737,54336],"range":[53705,54336],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":132,"label":"exoskeleton"}');
      if (!isRegExp(route)) route = this._routeToRegExp(route);
      if (typeof name === 'function') {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[54019,54309],"range":[54000,54309],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":131,"label":"exoskeleton"}');
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[54518,54573],"range":[54493,54573],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":133,"label":"exoskeleton"}');
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[54697,54775],"range":[54669,54775],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":134,"label":"exoskeleton"}');
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[55019,55258],"range":[55008,55258],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":135,"label":"exoskeleton"}');
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = Object.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[55418,55794],"range":[55402,55794],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":137,"label":"exoskeleton"}');
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[55590,55671],"range":[55564,55671],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":136,"label":"exoskeleton"}');
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[56062,56333],"range":[56036,56333],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":139,"label":"exoskeleton"}');
      var params = route.exec(fragment).slice(1);
      return params.map(function(param, i) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[56157,56325],"range":[56138,56325],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":138,"label":"exoskeleton"}');
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments.
  var History = Backbone.History = function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[56681,56945],"range":[56670,56945],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":140,"label":"exoskeleton"}');
    this.handlers = [];
    this.checkUrl = this.checkUrl.bind(this);

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash and query.
  var pathStripper = /[#].*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // Are we at the app root?
    atRoot: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[57573,57656],"range":[57562,57656],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":141,"label":"exoskeleton"}');
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[57829,57938],"range":[57812,57938],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":142,"label":"exoskeleton"}');
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[58102,58540],"range":[58067,58540],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":143,"label":"exoskeleton"}');
      if (fragment == null) {
        if (this._wantsPushState || !this._wantsHashChange) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[58704,60468],"range":[58686,60468],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":144,"label":"exoskeleton"}');
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration.
      // Is pushState desired or should we use hashchange only?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      var fragment          = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Depending on whether we're using pushState or hashes, determine how we
      // check the URL state.
      if (this._wantsPushState) {
        window.addEventListener('popstate', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        window.addEventListener('hashchange', this.checkUrl, false);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        if (this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[60625,60787],"range":[60614,60787],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":145,"label":"exoskeleton"}');
      window.removeEventListener('popstate', this.checkUrl);
      window.removeEventListener('hashchange', this.checkUrl);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[60942,61014],"range":[60916,61014],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":146,"label":"exoskeleton"}');
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`.
    checkUrl: function() {instrumentation_log('{"type":"FunctionExpression","bodyRange":[61137,61257],"range":[61126,61257],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":147,"label":"exoskeleton"}');
      var current = this.getFragment();
      if (current === this.fragment) return false;
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[61465,61710],"range":[61446,61710],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":149,"label":"exoskeleton"}');
      fragment = this.fragment = this.getFragment(fragment);
      return this.handlers.some(function(handler) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[61578,61702],"range":[61560,61702],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":148,"label":"exoskeleton"}');
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[62192,63377],"range":[62164,63377],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":150,"label":"exoskeleton"}');
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If we're using pushState we use it to set the fragment as a real URL.
      if (this._wantsPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[63555,63830],"range":[63517,63830],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":151,"label":"exoskeleton"}');
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // !!!
  // Init.
  ['Model', 'Collection', 'Router', 'View', 'History'].forEach(function(name) {instrumentation_log('{"type":"FunctionExpression","bodyRange":[63937,64018],"range":[63922,64018],"file":"todomvc/examples.lacunized.instrumented/exoskeleton/node_modules/exoskeleton/exoskeleton.js","index":152,"label":"exoskeleton"}');
    var item = Backbone[name];
    if (item) item.extend = Backbone.extend;
  });

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Create the default Backbone.history if the History module is included.
  if (History) Backbone.history = new History();
  return Backbone;
});
